<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 基本使用</title>
    <url>/2016/10/30/Git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li><p>配置用户名和email地址  </p>
<p><code>$ git config --global user.name &quot;Your Name&quot;</code>  </p>
<p><code>$ git config --global user.email &quot;email@example.com&quot;</code></p>
</li>
</ul>
<ul>
<li><p>初始化仓库  </p>
<p> <code>$ git init</code></p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>添加到暂存区，提交  </p>
<p><code>$ git add &lt;filename&gt;</code>  </p>
<p><code>$ git commit -m &#39;xxx, xxx, xxx&#39;</code></p>
</li>
</ul>
<ul>
<li><p>查看当前状态  </p>
<p><code>$ git status</code></p>
</li>
</ul>
<ul>
<li><p>查看修改   </p>
<p><code>$ git diff &lt;filename&gt;</code></p>
</li>
</ul>
<ul>
<li><p>查看提交日志  </p>
<p><code>$ git log</code> (–pretty=oneline 显示单行信息)</p>
</li>
</ul>
<ul>
<li><p>查看命令日志  </p>
<p><code>$ git reflog</code></p>
</li>
</ul>
<ul>
<li><p>回退到某一版本   </p>
<p><code>$ git reset --hard xxx</code><br><code>$ git reset --hard HEAD^</code> (上一版本)</p>
</li>
</ul>
<ul>
<li><p>丢弃工作区的修改  </p>
<p><code>$ git checkout -- &lt;filename&gt;</code></p>
</li>
</ul>
<ul>
<li><p>撤销暂存区的修改   </p>
<p><code>$ git reset HEAD &lt;filename&gt;</code></p>
</li>
</ul>
<ul>
<li><p>从版本库中删除   </p>
<p><code>$ git rm &lt;filename&gt;</code></p>
</li>
</ul>
<ul>
<li><p>创建ssh key  </p>
<p><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p>
</li>
</ul>
<ul>
<li><p>关联远程仓库   </p>
<p><code>$ git remote add origin git@github.com:GitUsername/RepositoryName.git</code></p>
</li>
</ul>
<ul>
<li><p>取消关联远程仓库   </p>
<p><code>$ git remote remove origin</code></p>
</li>
</ul>
<ul>
<li><p>推送到远程仓库   </p>
<p><code>$ git push -u origin master</code> (-u将本地master和远程master关联)</p>
</li>
</ul>
<ul>
<li><p>克隆远程仓库  </p>
<p><code>$ git clone git@github.com:&lt;GitUsername&gt;/&lt;RepositoryName&gt;.git</code></p>
</li>
</ul>
<ul>
<li><p>创建分支并切换  </p>
<p><code>$ git checkout -b &lt;name&gt;</code> (相当于 <code>$ git branch &lt;name&gt;</code> 和 <code>$ git checkout &lt;name&gt;</code> 两条指令)</p>
</li>
</ul>
<ul>
<li><p>切换到 \&lt;name> 分支  </p>
<p><code>$ git checkout &lt;name&gt;</code></p>
</li>
</ul>
<ul>
<li><p>合并 \&lt;name> 分支到当前分支   </p>
<p><code>$ git merge &lt;name&gt;</code></p>
</li>
</ul>
<ul>
<li><p>删除 \&lt;name> 分支   </p>
<p><code>$ git branch -d &lt;name&gt;</code></p>
</li>
</ul>
<ul>
<li><p>查看分支   </p>
<p><code>$ git branch</code></p>
</li>
</ul>
<ul>
<li><p>禁用fast forward模式合并分支   </p>
<p><code>$ git merge --no-ff -m &#39;merge with no-ff&#39; &lt;name&gt;</code></p>
</li>
</ul>
<ul>
<li><p>储存当前现场   </p>
<p><code>$ git stash</code></p>
</li>
</ul>
<ul>
<li><p>查看工作现场   </p>
<p><code>$ git stash list</code></p>
</li>
</ul>
<ul>
<li><p>恢复工作现场   </p>
<p><code>$ git stash apply</code> (不删除stash)</p>
</li>
</ul>
<ul>
<li><p>删除工作现场  </p>
<p><code>$ git stash drop</code></p>
</li>
</ul>
<ul>
<li><p>恢复工作现场并删除   </p>
<p><code>$ git stash pop</code></p>
</li>
</ul>
<ul>
<li><p>强制删除分支   </p>
<p><code>$ git branch -D &lt;name&gt;</code></p>
</li>
</ul>
<ul>
<li><p>查看远程库信息   </p>
<p><code>$ git remote</code> (-v更详细的信息)</p>
</li>
</ul>
<ul>
<li><p>创建标签  </p>
<p><code>$ git tag &lt;name&gt;</code> </p>
</li>
</ul>
<ul>
<li><p>查看所有标签  </p>
<p><code>$ git tag</code></p>
</li>
</ul>
<ul>
<li><p>查看标签信息   </p>
<p><code>$ git show &lt;tagname&gt;</code></p>
</li>
</ul>
<ul>
<li><p>删除本地标签   </p>
<p><code>$ git tag -d &lt;tagname&gt;</code></p>
</li>
</ul>
<ul>
<li><p>推送本地标签   </p>
<p><code>$ git push origin &lt;tagname&gt;</code>(推送全部未推送的本地标签 git push origin –tags)</p>
</li>
</ul>
<ul>
<li><p>删除一个远程标签  </p>
<p><code>$ git push origin :refs/tags/&lt;tagname&gt;</code></p>
</li>
</ul>
<ul>
<li><p>强制添加忽略的文件   </p>
<p><code>$ git add -f &lt;filename&gt;</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Github 搭建博客</title>
    <url>/2018/04/09/Hexo-Github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一款基于 Node.js 的静态博客框架，支持 Github Flavored Markdown 语法，可一键部署到 Github Pages。</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>安装 Hexo 前，需要检查是否已经安装下列应用:</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>如已安装上述必备程序，通过 <code>sudo npm install -g hexo-cli</code> 安装Hexo。</p>
<a id="more"></a>
<h2 id="建站流程"><a href="#建站流程" class="headerlink" title="建站流程"></a>建站流程</h2><ul>
<li>在 Github 中创建仓库 <code>username.github.io</code></li>
<li>创建本地目录 <code>username.github.io</code> 并在目录中执行 <code>hexo init</code></li>
<li>修改目录中的 <code>_config.yml</code> ，详见 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo 配置</a> ，如下为部署相关配置：</li>
</ul>
<figure class="highlight plain"><figcaption><span>hexo-deployer-git，npm install hexo-deployer-git --save</span></figcaption><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:User/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<ul>
<li>安装 hexo-deployer-git，<code>npm install hexo-deployer-git --save</code></li>
<li>初始化本地 git 仓库，<code>git init</code></li>
<li>本地仓库关联远程仓库，<code>git remote add origin git@github.com:User/username.github.io.git</code></li>
<li>本地创建并切换到 hexo 分支 <code>git checkout -b hexo</code> </li>
<li>提交本地 hexo 分支，推送并关联远程 hexo 分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git add .</span><br><span class="line"><span class="meta">$</span> git commit -m'init hexo branch'</span><br><span class="line"><span class="meta">$</span> git push -u origin hexo</span><br></pre></td></tr></table></figure>
<ul>
<li>将 hexo 分支设置为默认分支（使 clone 操作获取 hexo 分支内容）</li>
<li>生成静态页面并部署至 Github，<code>hexo g -d</code></li>
</ul>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><code>hexo new [layout] &lt;title&gt;</code> 命令用于创建新文章，layout 默认为 post，可以通过修改 -config.yml 指定默认布局。</p>
<p>使用 layout 参数创建文章时，Hexo 会尝试在 scaffold 目录中寻找对应的模板，根据模板创建文件。</p>
<p>默认布局中 draft 不会显示在页面中，可通过命令 <code>hexo publish [layout] &lt;title&gt;</code> 发布文章。</p>
<p>文章上方以 <code>—</code> 分隔的区域用于指定标题等变量，如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2018/4/9 13:46:25</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>tech</span><br><span class="line"><span class="bullet">- </span>java</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>spring</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>常用参数有 title、date、updated、tags、categories、comments 等。</p>
<p>Hexo 中分类具有顺序性和层次性，不支持一篇文章有多个同级分类，多个类别时会成为子分类而不是并列分类。</p>
<h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>首先在 Hexo 根目录下安装主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>
<p>修改 hexo 根目录配置 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">yilia</span></span><br></pre></td></tr></table></figure>
<p>调整主题配置，修改 <code>theme/yilia/_config.yml</code> ，如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Header</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span></span><br><span class="line">  <span class="string">随笔:</span> <span class="string">/tags/随笔/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SubNav</span></span><br><span class="line"><span class="attr">subnav:</span></span><br><span class="line"><span class="attr">  github:</span> <span class="string">"#"</span></span><br><span class="line"><span class="attr">  weibo:</span> <span class="string">"#"</span></span><br><span class="line"><span class="attr">  rss:</span> <span class="string">"#"</span></span><br><span class="line"><span class="attr">  zhihu:</span> <span class="string">"#"</span></span><br><span class="line">  <span class="comment">#qq: "#"</span></span><br><span class="line">  <span class="comment">#weixin: "#"</span></span><br><span class="line">  <span class="comment">#jianshu: "#"</span></span><br><span class="line">  <span class="comment">#douban: "#"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM GC 与 内存分配策略</title>
    <url>/2018/03/28/JVM-GC-%E4%B8%8E-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="对象存活算法"><a href="#对象存活算法" class="headerlink" title="对象存活算法"></a>对象存活算法</h2><p>Java 堆中存放着几乎所有的对象实例，垃圾收集器在对堆进行回收前，需要确定对象是否存活。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，每当一个地方引用它时，计数器的值加 1；引用失效时减 1。</p>
<p>主流 JVM 没有选用此种算法管理内存，主要原因是它难以解决对象间循环引用的问题。</p>
<a id="more"></a>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>可达性分析算法是 JVM 主流实现中采用的算法。基本思路是通过一系列 <code>GC Roots</code> 对象为起点向下搜索，搜索所走过的路径称为 <code>引用链</code> 。当一个对象到 GC Roots 没有任何引用链相连时，会被判定为可回收对象。</p>
<p>GC Roots 对象包括以下几种：虚拟机栈中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；本地方法栈中引用的对象。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>JDK 1.2 后，Java 中的引用分为强引用、软引用、弱引用和虚引用 4 种。</p>
<p>强引用在代码中普遍存在，如 <code>Object o = new Object()</code> ，只要强引用在，垃圾回收器就永远不会回收被引用的对象。</p>
<p>软引用用来描述有用但非必须的对象，在发生内存溢出异常之前被回收。</p>
<p>弱引用和软引用类似，强度更弱，只能生存到下一次垃圾收集之前。</p>
<p>虚引用不会对生存时间构成影响，也无法通过虚引用取得实例，设置虚引用的唯一目的就是能在这个对象被回收时受到系统通知。</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区的回收主要包括废弃常量和无用的类。</p>
<p>废弃常量和堆中的对象类似，当发生垃圾回收时，如果常量池中的常量不存在任何引用，必要情况下回被清理。</p>
<p>判断一个类无用的条件很苛刻，需要所有实例都已经被回收、加载该类的 ClassLoader 已经被回收，并且该类对应的 java.lang.Class 对象没有在任何地方被引用，无法通过反射访问该类的方法，满足以上条件的无用类才能被回收。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-—-清除算法"><a href="#标记-—-清除算法" class="headerlink" title="标记 — 清除算法"></a>标记 — 清除算法</h3><p>先标记出所有需要回收的对象，然后统一回收。两个阶段效率都不高，另外标记清除后会产生大量不连续的内存碎片。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存分为大小相等两块，每次使用其中一块。内存用完时将还存活的对象复制到另一块上，再把已使用的空间一次清理掉。</p>
<p>新生代中大多对象朝生夕死，不需要按照 1 : 1 分配内存空间，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor 空间。回收时将 Eden 和 Survivor 中存活的对象一次性复制到另一块 Survivor 空间，再清理掉之前使用的两块内存空间。HotSpot 默认 Eden 和 Survivor 的大小比例为 8 : 1，可用空间为 90%。当 Survivor 内存不够时需依赖老年代进行分配担保。</p>
<h3 id="标记-—-整理算法"><a href="#标记-—-整理算法" class="headerlink" title="标记 — 整理算法"></a>标记 — 整理算法</h3><p>标记整理算法更适合于老年代，标记之后不直接对可回收对象进行清理，而是让存活对象都向一段移动，然后清理掉边界以外的内存。</p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>当前商业虚拟机都采用分代收集，根据对象存活周期把内存划分为几块。一般把 Java 堆分为新生代和老年代，新生代采用复制算法，老年代使用标记清理算法或标记整理算法。</p>
<h2 id="HotSpot-算法实现"><a href="#HotSpot-算法实现" class="headerlink" title="HotSpot 算法实现"></a>HotSpot 算法实现</h2><p>HotSpot 实现上述算法时，须对算法的执行效率严格考量，才能保证虚拟机高效运行。</p>
<h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>主流虚拟机都使用 <code>准确式 GC</code> ，即知道内存中数据的具体类型，所以不需要一个不漏地检查所有执行上下文和全局的引用位置。JVM 有办法直接得知哪些地方存放着对象引用，HotSpot 使用一组称为 <code>OopMap</code> 的数据类型达到这个目的。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>导致 OopMap 变化的指令很多，如果针对每次变化采取措施 GC 的成本会变得很高。实际上，HotSpot 没有为每条指令生成 OopMap，只在特定位置记录这些信息，这些位置称为 <code>安全点</code> ，程序只有在安全点才能暂停。安全点既不能太少又不能太多，基本选在方法调用、循环跳转等具有让程序长时间执行特性的位置。</p>
<p>让程序在安全点暂停主要有 抢先式中断 和 主动式中断 两种方案。抢先式先把所有线程中断，再让不处于安全点的线程继续执行到安全点。主动式则是在安全点的位置有是否需要中断的标志，线程执行到安全点时依据标志中断挂起。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域指在一段代码片段内不会引起引用变化的区域，如线程处于 Sleep 状态挥着 Blocked 状态，线程无法响应 JVM 的中断请求。</p>
<p>程序进入安全区域时，先标记自己已经进入安全区域，如在这个时候发起 GC，不需要处理标记进去安全区域的线程。在线程离开安全区域时，需要检查是否完成枚举根节点或整个 GC 过程，已完成则继续执行，否则需要等到接收可以安全离开的信号为止。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集器是内存回收的具体实现，目前没有最好的收集器，只有最合适的收集器，所以 JVM 实现了几个不同的收集器。</p>
<h3 id="Serial-Serial-Old-收集器"><a href="#Serial-Serial-Old-收集器" class="headerlink" title="Serial / Serial Old 收集器"></a>Serial / Serial Old 收集器</h3><p>单线程收集器，只使用一个 CPU 和一个收集线程，垃圾回收时暂停其他所有的工作线程，直到收集结束。</p>
<p>与其他收集器的单线程比简单高效，对于运行在 Client 模式下的虚拟机是一个好选择。</p>
<p>新生代采用复制算法，老年代采用标记整理算法。</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>Serial 的多线程版本，能与 CMS 收集器配置工作，所以是许多运行在 Server 模式下的首选新生代收集器。</p>
<p>在垃圾收集器的上下文中，先明确两个概念：</p>
<blockquote>
<p>并行：多条垃圾线程并行工作，用户线程仍然处于等待状态</p>
<p>并发：用户线程和垃圾回收线程同时执行（不一定并行，可能会交替执行）</p>
</blockquote>
<h3 id="Parallel-Scavenge-Parallel-Old-收集器"><a href="#Parallel-Scavenge-Parallel-Old-收集器" class="headerlink" title="Parallel Scavenge / Parallel Old 收集器"></a>Parallel Scavenge / Parallel Old 收集器</h3><p>使用复制算法的新生代多线程收集器，特点是更关注吞吐量，即运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。</p>
<p>Parallel Scavenge 收集有一个参数开关 -XX:+UseAdaptiveSizePolicy，打开后就不需要手动设置新生代大小、Eden 与 Survivor 区的比例等细节参数，JVM 会根据当前系统运行情况动态调整，以提供最合适的停顿时间或最大吞吐量。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>Concurrent Mark Sweep 以获取最短收回停顿时间为目标，使用标记清除算法。收集过程分为 4 部：初始标记、并发标记、重新标记和并发清理。初始标记和重新标记耗时很少，并发标记和并发清理两部耗时较长，但都可以与用户线程一起并发执行。</p>
<p>CMS 收集器有 3 个明显缺点：1.对 CPU 资源敏感，并发阶段占用一部分 CPU 资源导致应用程序变慢。2.无法收集浮动垃圾，即并发清理阶段由于程序还在运行产生的垃圾，可能导致另一次 Full GC。3.标记清除算法导致收集结束后存在大量空间碎片，可配置 Full GC 执行多少次时伴随一次空间压缩。</p>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>Garbge-First 面向服务端应用，具有并发并行、分代收集、空间整合、可预测停顿等特点。</p>
<p>使用 G1 时，Java 堆的内存分为多个大小相等的独立区域，虽然保留新生代和老年代的概念，但不再是物理隔离。G1 跟踪各个 Region 里垃圾堆积的价值，在后台维护一个优先列表，优先回收价值最大的 Region。</p>
<p>G1 的运作大致分为初始标记、并发标记、最终标记和筛选回收。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>多数情况下，对象在新生代 Eden 区分配。Eden 没有足够的空间时进行一次 Minor GC。当存活对象无法放入 Survivor 区时，通过分配担保提前转移到老年代。</p>
<p>需要大量连续内存空间的大对象会直接进入老年代，如很长的字符串或数组。经常出现大对象容易导致内存还有不少空间时就触发 GC。</p>
<p>长期存活的对象进入老年代。每经过一次 Minor GC，对象中的年龄计数器会加 1，加到一定程度（默认 15）时晋升到老年代。如果 Survivor 空间中相同年龄的所有对象带下总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
<p>在发生 Minor GC 之前，JVM 会先检查老年代中最大可用连续空间是否大于新生代所有对象总和，如果大于，Minor GC 可以确定是安全的。否则要根据是否允许担保失败判断是否进行 Full GC。允许担保失败时，会根据之前晋升老年代的平均大小作为经验来判定是否进行尝试。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 内存区域</title>
    <url>/2018/03/27/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为如下几个数据区域：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈 </li>
<li>堆</li>
<li>方法区</li>
</ul>
<a id="more"></a>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块很小的内存空间，是当前线程所执行字节码的行号指示器，线程间私有不共享。执行 Java 方法时计数器的值为字节码指令的地址，执行 Native 方法时值为空。不会出现OutOfMemoryError。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈为线程私有，生命周期与线程相同，描述 Java 方法执行的内存模型。方法执行时创建栈帧，用于存储局部变量表、操作数栈、方法出口等信息。</p>
<p>局部变量表存放了编译器可知的基本数据类型、对象引用和 returnAddress类型（字节码指令地址），所需内存空间在编译器完成分配，运行期间不改变大小。</p>
<p>线程请求栈深度大于虚拟机允许深度时抛出 StackOverflowError（大部分虚拟机可以动态扩容，但也允许固定长度的虚拟机栈），扩展时无法申请到足够内存抛出 OutOfMemoryError。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈为虚拟机执行 Native 方法服务，线程隔离。虚拟机规范中无强制规定，Sun HostSpot 将本地方法栈和虚拟机栈合二为一。能够抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>Java 堆是 JVM 所管理内存中最大的一块，所有线程共享，在虚拟机启动时创建，用于存放对象实例，是垃圾回收的主要区域。</p>
<p>从内存回收的角度可分为新生代和老年代，再细致划分可分为 Eden 空间、From Survivor 空间 和 To Survivor 空间等。</p>
<p>Java 堆可以处于物理上不连续的内存空间内，只要逻辑上连续即可。</p>
<p>在堆中没有内存完成实例分配也无法再扩展时抛出 OutOfMemoryError。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区由各个线程共享，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等。</p>
<p>JVM 规范把方法区描述为堆的一个逻辑部分，别名 Non-Heap（目的是与 Java 堆区分开）。</p>
<p>在 JDK6 和 JDK7 中，HotSpot 选择将 GC 分代收集扩展至方法区，可以理解为 永久代。</p>
<p>在 JDK8 中使用元数据区 Metaspace 取代永久代，元数据被分配到本地内存中进行管理，Metaspace 默认上限是本地内存大小。</p>
<p>JVM 规范对方法区的限制非常宽松，不需要连续内存、固定大小或可扩展均可，还可以不实现垃圾回收。垃圾收集行为在这个区域较少出现。</p>
<p>方法区包含运行时常量池，Class 文件中的常量信息在类加载后存放于运行时常量池中。运行时常量池具备动态性，运行期间也可能将新的常量放入池中。</p>
<p>当方法区无法满足内存分配需求时会抛出 OutOfMemoryError。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存 *"></a>直接内存 *</h2><p>直接内存不是 JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但这部分内存会被频繁使用，而且可能会导致 OutOfMemoryError 异常。</p>
<p>JDK 1.4 中新加入的NIO（New Input / Output）类引入了一种基于通道与缓冲区的 IO 方式，可以使用 Native 函数库直接分配堆外内存，再通过存储在 Java 堆中的DirectByteBuffer 对象做为这块内存的引用进行操作。</p>
<p>与堆相比，直接内存的申请成本更高，IO 读写的性能更强。</p>
<p>直接内存不受 Java 堆大小限制，但会受到本机总内存及处理器寻址空间限制，动态扩展超出限制会抛出 OutOfMemoryError 异常。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 性能监控与故障处理工具</title>
    <url>/2018/03/29/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>JDK 中包含一些命令行工具，这些工具能在处理应用程序性能问题、定位故障时发挥很大的作用。</p>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>JVM Process Status Tool，用于显示系统内所有的 HotSpot 虚拟机进程。</p>
<p>jps 可以列出正在运行的 JVM 进程，显示 JVM 执行主类及进程的本地虚拟机唯一 ID（与操作系统进程 ID 一致）。</p>
<p>常用选项：</p>
<ul>
<li>-q：只输出进程 ID，隐藏主类名称</li>
<li>-m：输出进程启动时传递给主类 main() 函数的参数</li>
<li>-l：输出主类全名，如进程执行的是 Jar 包，输出 Jar 路径</li>
<li>-v：输出虚拟机进程启动时 JVM 参数</li>
</ul>
<a id="more"></a>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>JVM Statistics Monitoring Tool，用于收集 HotSpot 各方面的运行数据。</p>
<p>可以显示 JVM 进程中的类装载、内存、垃圾收集、JIT 编译等运行数据，格式为 </p>
<p><code>jstat option vmid [interval] [count]</code></p>
<p>interval 参数为查询间隔，count 参数为查询次数，省略这两个参数则只查询一次。</p>
<p>主要选项：</p>
<ul>
<li>-class：监视类装载、卸载数量、总空间及耗时</li>
<li>-gc：监视 Java 堆状态，包括各个区的容量、已用空间、GC 时间合计等信息</li>
<li>-gccapacity：与 -gc 类似，更关注堆内各区使用到的最大、最小空间</li>
<li>-gcutil：与 -gc 类似，更关注已使用空间占比</li>
<li>-gccause：与 -gcutil 类似，额外输出上一次 GC 原因</li>
<li>-gcnew：监视新生代 GC 状况</li>
<li>-gcnewcapacity：与 -gcnew 类似，更关注使用到的最大、最小空间</li>
<li>-gcold：监视老年代 GC 状况</li>
<li>-gcoldcapacity：与 -gcold 类似，更关注使用到的最大、最小空间</li>
</ul>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>Configuration Info for Java，用于显示虚拟机配置信息，可以实时查看和调整虚拟机各项参数。</p>
<p>jps -v 命令可以查看 JVM 启动时显示指定的参数列表，各项参数的默认值可以通过 jinfo 的 -flag 选项进行查询，还可以通过 -sysprops 选项打印出进程 System.getProperties() 的内容。</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>Memory Map for Java，用于生成 JVM 内存转储快照（heapdump文件）。命令格式 <code>jmap [option] vmid</code> ，主要选项：</p>
<ul>
<li>-dump：生成 Java 堆转储快照</li>
<li>-head：显示 Java 堆详细信息</li>
<li>-histo：显示堆中对象的统计信息</li>
</ul>
<h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>JVM Heap Dump Browser，用于分析 heapdump 文件，建立 HTTP / HTML 服务器，可以在浏览器上查看分析结果。</p>
<p>实际工作中一般不使用jhat 来分析 dump 文件，因为通常不会再服务器上直接分析 dump 文件，耗时且消耗资源，功能也相对简陋。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>Stack Trace for Java，用于生成虚拟机线程快照，目的是定位线程出现长时间停顿的原因。常见参数：</p>
<ul>
<li>-F：当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li>-l：除堆栈外，显示关于锁的附加信息</li>
<li>-m：如调用本地方法，可以显示 C / C++ 的堆栈</li>
</ul>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>Java Monitoring and Management Console，基于 JMX 的可视化 Java 监视与管理控制台。</p>
<h2 id="Visual-VM"><a href="#Visual-VM" class="headerlink" title="Visual VM"></a>Visual VM</h2><p>All-in-One Java Troubleshooting Tool，功能强大的运行监视和故障处理程序。不需要被监视程序基于特殊 Agent 运行，对程序的实际性能影响很小。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内部类</title>
    <url>/2017/06/08/Java-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>内部类，即定义在另一个类中的类。</p>
<a id="more"></a>
<h3 id="使用内部类的原因"><a href="#使用内部类的原因" class="headerlink" title="使用内部类的原因"></a>使用内部类的原因</h3><h4 id="1-访问外部类作用域的数据"><a href="#1-访问外部类作用域的数据" class="headerlink" title="1. 访问外部类作用域的数据"></a>1. 访问外部类作用域的数据</h4><p>内部类的对象包含一个隐式引用，指向创建它的外部类对象，所以可以直接访问外部类作用域中的数据，包括私有数据。</p>
<p>当需要访问其他类的数据域时，使用内部类可以免去对所需数据域的显式引用。</p>
<h4 id="2-对其他类隐藏"><a href="#2-对其他类隐藏" class="headerlink" title="2. 对其他类隐藏"></a>2. 对其他类隐藏</h4><p>内部类的声明是私有的，只有所在外部类的方法才能构造内部类对象。</p>
<h4 id="3-定义回调函数"><a href="#3-定义回调函数" class="headerlink" title="3. 定义回调函数"></a>3. 定义回调函数</h4><p>匿名内部类在定义回调函数时很便捷，不过 Java8 之后更好的方式是使用 Lambda 表达式。</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>如果内部类的名字仅在某一方法中创建内部类对象时使用了一次，则可以将内部类的定义挪到对应的方法中。</p>
<p>局部内部类不使用 public 或 private 等访问修饰符，作用域被限定在声明该类的代码块中，即使外部类的其他代码也不能访问，对外部代码完全隐藏。</p>
<p>局部内部类还可以访问局部变量，通过此特性可以减少需要显式编写的实例域。不过要访问的局部变量必须为事实上 final 的。</p>
<p>局部内部类示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outerNumber;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">int</span> outerNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outerNumber = outerNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localInnerAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> methodNumber = outerNumber * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalInner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//methodNumber++; 必须为事实上final</span></span><br><span class="line">                System.out.println(<span class="string">"outerNumber: "</span> + outerNumber);</span><br><span class="line">                System.out.println(<span class="string">"methodNumber: "</span> + methodNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalInner localInner = <span class="keyword">new</span> LocalInner();</span><br><span class="line">        localInner.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="number">100</span>);</span><br><span class="line">        outer.localInnerAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>如果对某个类仅要创建一个对象，就不必给类命名，这种类称为匿名内部类。</p>
<p>匿名内部类常用于实现某个接口，也可以扩展一个已有的类。语法上只需在构造方法后增加一对大括号，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anonymousInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>有时使用内部类只是为了把类隐藏在另一个类的内部，并不需要引用外部类对象，这种情况可以将内部类声明为 static ，以便取消产生的外部类隐式引用。</p>
<p>静态内部类的对象，除没有外部类对象的引用外，跟其他内部类没有区别。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合概述</title>
    <url>/2017/07/05/Java-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>实现方法时，选择不同的数据结构会使实现风格和性能有很大的差异。本篇文章讲述如何使用 Java 标准库中的集合类。</p>
<a id="more"></a>
<h2 id="集合的接口"><a href="#集合的接口" class="headerlink" title="集合的接口"></a>集合的接口</h2><p>Java 集合类库将接口与实现分离，比如队列接口包含 add、remove、size 等方法，并没有说明队列是如何实现的。队列通常有两种实现方式：循环数组（ArrayDeque）和链表（LinkedList），每个实现都通过实现 Queue 接口的类表示。</p>
<p>使用集合时，通常使用接口类型存放集合的引用，只有在构建集合对象时才使用具体的类。一旦想要改变实现类，可以轻松地使用另一种不同的实现。</p>
<p>Java 中集合类的基本接口为 Collection，包含 add、iterator 等接口。add 方法用于向集合添加元素，如果确实改变了集合就返回 true；iterator 接口返回一个实现了 Iterator 接口的对象，可以使用这个对象一次访问集合中的元素。</p>
<p>Iterator 接口包含 next、hasNext、remove 等方法。反复调用 next 方法可以逐个访问集合中的元素（到达集合末尾抛异常）；hasNext 用于判断是否还有可供访问的元素；remove 方法将会删除上次调用 next 时返回的元素，如果要删除两个相邻的元素必须分别在调用 next 后调用 remove 方法。</p>
<p>使用 for each 循环可以更加简练地遍历元素，可以对任意实现了 Iterable 接口的对象使用 for each。Iterable 接口包含 iterator 方法。Collection 接口扩展了 Iterable 接口，所以标准库中的任何集合都可以使用 for each 循环。</p>
<p>List 是一个有序集合，可以采用迭代器访问或使用整数索引来随机访问，Java 1.4 引入一个不包含任何方法接口 RandomAccess 来标记是否支持高效的随机访问。</p>
<p>Set 相比于 Collection 有更严格的定义，add 方法不允许添加重复的数据。</p>
<h2 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h2><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>数组列表（ArrayList）在中间位置删除或插入元素时，被删除或插入的元素后面所有的元素都要移动，所以要付出很高的代价，LinkedList 通过将每个对象存放在单独的节点并保存相邻节点的引用来解决这个问题。</p>
<p>LinkedList.add 方法会将对象添加到链表的尾部，如果要将元素添加到链表的中间，可以通过迭代器来完成。另外LinkedList.listIterator 方法返回一个 ListIterator 对象，此对象的 add 方法没有返回值，假定添加操作都会改变链表，另外提供 previous 和 hasPrevious 方法来反向遍历链表。</p>
<p>如果迭代器发现它的集合被另一个迭代器修改了，会抛出异常。</p>
<p>尽管 LinkedList 提供了随机访问的方法，但每次访问需要从头开始，所以应该尽量避免。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 封装了一个动态数组，支持高效地随机访问。</p>
<p>在数组空间不够时创建新数组，并将旧数组中的数据拷贝到新数组中。</p>
<p>ArrayList 的方法不是同步的，只能在不需要同步时使用 ArrayList。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>如果要查找链表或数组中某元素的位置，就需要遍历所有元素，直到找到为止，在集合包含大量元素时很耗时间。</p>
<p>散列表 HashMap 可以快速地查找需要的对象，Java 中用链表数组实现，每个列表称为桶。HashMap 计算元素的散列码 hash code，与桶的总数取余得到元素的桶索引，并将不同（equals 方法判断）的元素添加到链表中。</p>
<p>如果想更多地控制性能，可以指定初始的桶数，通常将桶数设置为预计元素个数的 75% ~ 150%。标准库使用的桶数为 2 的幂，默认为 16。</p>
<p>散列表填满到一定程度后会进行再散列，创建一个桶数为 2 倍的散列表并将所有的元素填入新表。填装因子 load factor 决定何时进行再散列，默认为 0.75（对大多应用都比较合理），即超过 75% 的位置填入元素就进行再散列。</p>
<p>HashSet 是基于 HashMap 的集合，通过 add 方法添加元素，contains 方法被重新定义，可以快速查看某个元素是否在集合中。</p>
<p>HashSet 在遍历时依次访问所有的桶，所以访问顺序集合是随机的，只有在不要求元素顺序时才使用 HashSet。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet 和 HashSet 类似，不过 TreeSet 基于红黑树，是一个有序集，需要指定排序方式，在添加元素时会放置到正确排序的位置上。</p>
<p>添加元素到树集比添加到散列集慢，在不需要排序时就没必要付出排序的开销。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>映射 Map 用来存放键值对，通过键可以找到值。</p>
<p>HashMap 对键进行散列，散列和比较函数仅作用于键。跟 TreeSet 相比，散列的性能更好一点。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>进行垃圾回收时只会检查对象是否存活，只要对象存活，所有的桶都存活，即 Map 中无用的值也不会被回收。</p>
<p>WeakHashMap 使用弱引用来保存键，在垃圾回收时只存在若引用的对象会被回收，放入一个若引用的队列，WeakHashMap 会周期性地检查队列，删除对应的条目。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashSet 和 LinkedHashMap 通过维护一个双向链表来维护元素的顺序，默认为元素插入的顺序。如果将顺序设置为访问顺序，每次在调用 get 或 put 时，受影响的条目将从链表中删除，并放到链表的尾部。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 可靠的数据传递</title>
    <url>/2018/07/24/Kafka-%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>Kafka 在数据传递可靠性方面具有很大的灵活性，是高度可配置的，通过使用客户端 API 可以满足不同程度的可靠性需求。</p>
<p>Kafka 有一些基本的保证：1. Kafka 可以保证分区内消息的顺序；2. 消息被写入到分区的所有同步副本才算是已经提交的消息；3. 只要有一个副本活跃，已经提交的消息就不会丢失；4. 消费者只能读取已经提交的消息。</p>
<p>以上的基本保证用于构建可靠的系统，开发者在配置参数上作出权衡（可靠性、一致性的重要程度与可用性、高吞吐量、低延迟和硬件成本重要程度之间的权衡），从而获得想要达到的可靠性。</p>
<a id="more"></a>
<h2 id="配置-broker"><a href="#配置-broker" class="headerlink" title="配置 broker"></a>配置 broker</h2><p>broker 有 3 个配置会影响消息存储的可靠性，应用在 broker 级别时控制所有主题的行为，应用在主题级别时控制个别主题的行为。</p>
<h3 id="复制系数"><a href="#复制系数" class="headerlink" title="复制系数"></a>复制系数</h3><p>复制系数即数据数据副本的个数，复制系数 N 需要至少 N 个 broker，在 N - 1 个 broker 失效的情况下仍然可用，默认为 3。主题级别的配置是 replication.factor，而 broker 级别通过 default.replication.factor 来配合自动创建主题的复制系数。</p>
<p>更高的复制系数会带来更高的可用性和更少的故障，不过会占用 N 倍的磁盘空间，一般要在可用性和存储硬件之间作出权衡。</p>
<p>如果重启等导致主题不可用是可以接受的，那么复制系数设为 1 就可以，不过在节省硬件成本的同时也降低了可用性。复制系数为 2 可以容忍 1 个 broker 失效，不过有时候 1 个broker 失效会导致集群不稳定（通常是旧版 Kafka）。建议在要求可用性的场景把复制系数设置为 3，在大多数情况下足够安全。</p>
<p>同时注意副本的分布也很重要，Kafka 会保证分区的每个副本在不同的 broker 上，如果把 broker 分布在不同机架上，并使用 broker.rack 配置机架信息，可以获得更高的可用性。</p>
<h3 id="不完全首领选举"><a href="#不完全首领选举" class="headerlink" title="不完全首领选举"></a>不完全首领选举</h3><p>当分区首领不可用时，一个同步副本会被选为新首领。但如果首领不可用时其他副本都是不同步的，就要做出一个艰难的选择。</p>
<p>如果将不同步副本提升为新首领，则副本不同步后写入旧首领的消息丢失，导致数据不一致，否则分区在旧首领（最后一个同步副本）恢复之前不可用。</p>
<p>默认情况下 unclean.leader.election.enable 的值为 true，即允许【不完全的选举】。</p>
<h3 id="最少同步副本"><a href="#最少同步副本" class="headerlink" title="最少同步副本"></a>最少同步副本</h3><p>尽管可以将复制系数设为 3，可还是会出现只有一个同步副本的情况，如果唯一的同步副本不可用，就必须在可用性和一致性间做选择。如果要确保已提交的消息被写入到不止一个副本，就需要把最小同步副本的值设置大一点。</p>
<p>最小同步副本在主题和 broker 级别均为 min.insync.replicas，如果设置为 2，则至少存在两个同步副本才能向分区写入数据。如果可用副本不足，生产者会受到 NotEnoughReplicasException。此配置配合生产者的 acks（需要接收到多少个同步副本的响应才算写入成功）配置能使消息的可靠性更好。</p>
<h2 id="配置生产者"><a href="#配置生产者" class="headerlink" title="配置生产者"></a>配置生产者</h2><p>即使我们尽可能地把 broker 配置的很可靠，但如果没有对生产者进行可靠性方面的配置，系统仍然可能出现突发的数据丢失。</p>
<p>比如 broker 配置为 3 个副本，禁用不完全选举，如果生产者 acks 为 1，首领副本接到消息后崩溃，虽然有两个同步副本，但还没有来得及同步消息，其中一个副本称为新首领，从生产者的角度就丢失了一个消息。</p>
<p>再比如 acks 设为 all，但发送消息时首领崩溃，生产者收到【首领不可用】的错误相应，如果没有处理错误，也会丢失消息。</p>
<p>所以，生产者首先需要将 acks 配置为合适的值，其次需要处理 broker 返回的错误。</p>
<p>broker 返回的错误如果是可以通过重试解决的，生产者会自动处理错误，比如 LEADER_NOT_AVAILABLE 错误，可以通过配置 retries 来指定最大重试次数。需要注意的是，重试会带来一些风险，比如生产者因为网络问题没有收到 broker 的确认。</p>
<p>如果需要【只保存一次】，可以在消息中假如唯一标识符，或者使消息【幂等】，即出现了重复消息也不会有负面影响。【这个账号里有 10 美元】是幂等的，【给这个账号加 10 美元】不是幂等的。</p>
<p>另一种不可通过重试解决的错误，比如消息过大、重试达上限等，需要开发者根据业务逻辑处理错误。</p>
<h2 id="配置消费者"><a href="#配置消费者" class="headerlink" title="配置消费者"></a>配置消费者</h2><p>只有被写入到所有同步副本的消息才会被消费者读取，消息已经具备一致性，所以消费者要做的就是记住哪些消息已经被读取过，哪些还没有读取。</p>
<p>从分区读取数据时，消费者会获取一批事件，检查事件中最大的偏移量，然后从最大偏移量开始读取下一批事件。而如果消费者退出，其他消费者需要知道之前的消费者读取的进度，这也就是提交偏移量的作用。</p>
<p>消费者需要注意以下配置：1. group.id，具有相同 group.id 的消费者会共同读取订阅的主题。2. auto.offset.reset 指定在没有记录偏移量时从何处开始读取，earliest 表示从分区开始位置读取，latest 表示从末尾开始读取。3. enable.auto.commit 配置是否开启自动提交偏移量。4. auto.commit.interval.ms 自动提交偏移量的时间间隔。</p>
<p>手动提交偏移量会更准确，关于手动提交偏移量需要注意以下几点：</p>
<ol>
<li>要在消息事件处理完后再提交偏移量</li>
<li>在提交频率和重复消息数量之前作权衡</li>
<li>注意再均衡，在失去控制前提交偏移量</li>
<li>注意消息事件处理失败的逻辑</li>
<li>数据处理要花费很长时间时注意保持心跳</li>
<li>需要【仅一次】传递时可以借助支持唯一键、事务的系统</li>
</ol>
<h2 id="验证系统可靠性"><a href="#验证系统可靠性" class="headerlink" title="验证系统可靠性"></a>验证系统可靠性</h2><p>在确认了可靠性需求，并且配置 broker 和客户端后，最好还是先对系统可靠性做些验证。建议在 3 个层面做验证：配置验证、应用程序验证及生产环境的应用程序监控。</p>
<h3 id="配置验证"><a href="#配置验证" class="headerlink" title="配置验证"></a>配置验证</h3><p>Kafka 提供了两个用于验证配置的重要工具：org.apache.kafka.tools 包内的 VerifiableProducer 和 VerifiableConsumer 两个类，可以从命令行运行两个类或嵌入自动化测试框架。</p>
<p>使用和生产者、消费者相同的方式来配置 VerifiableProducer 和 VerifiableComsumer，VerifiableProducer 生成一系列消息，通过 VerifiableComsumer 检查每个消息。可以在首领选举、控制器选举、依次重启、不完全首领选举测试等场景测试系统的可靠性。</p>
<h3 id="应用程序验证"><a href="#应用程序验证" class="headerlink" title="应用程序验证"></a>应用程序验证</h3><p>确保 broker 和客户端配置满足需求后，可以再从应用程序方面检查，包括错误处理、提交偏移量、再均衡监听等，建议基于如下故障条件测试应用程序：客户端从服务器断开连接、首领选举、依次重启 broker、依次重启生产者和依次重启消费者。</p>
<h3 id="生产环境监控"><a href="#生产环境监控" class="headerlink" title="生产环境监控"></a>生产环境监控</h3><p>测试无法替代生产环境的持续监控，监控的目的是确保数据按期望的方式流动，可以按照业务需求对重要的数据指标进行持续地监控。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kafka.apache.org/documentation/" target="_blank" rel="noopener">Kafka 官方文档</a></p>
<p><a href="http://shop.oreilly.com/product/0636920044123.do" target="_blank" rel="noopener">Kafka 权威指南</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发概述</title>
    <url>/2017/07/02/Java-%E5%B9%B6%E5%8F%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>操作系统拥有在同一刻运行多个程序的能力，并发执行的进程数不受 CPU 数目制约，系统将 CPU 的时间片分配给每个进程，给人并行处理的感觉。</p>
<p>而多线程扩展了多任务的概念，即一个程序同时执行多个任务（线程）。每个进程拥有自己的一套变量，而线程则共享数据。本篇文章将从线程、同步、执行器等多方面介绍 Java 并发。</p>
<a id="more"></a>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>通常人们会提防长时间的计算，如在 GUI 或 web 项目中，如果需要执行一个比较耗时的任务，应该使用线程并发的方式快速响应。</p>
<h3 id="线程的简单使用"><a href="#线程的简单使用" class="headerlink" title="线程的简单使用"></a>线程的简单使用</h3><p>创建单独的线程并执行任务很简单，需要将任务实现在 Runable 接口的 run 方法中，通过 Runable 创建 Thread 对象，然后通过 Thread 对象的 start 方法启动线程。</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>当线程的 run 方法执行完毕或出现了没有被捕获的异常时，线程会中止。没有可以强制终止线程方法，但 interrupt 方法可以用于请求终止线程。</p>
<blockquote>
<p> 早起 Java 版本中，其他线程可以通过调用 stop 方法终止线程，不过已经被弃用，因为无法确定什么时候调用 stop 方法是安全的，suspend 方法同样被弃用，经常导致死锁。</p>
</blockquote>
<p>每个线程都有一个 boolean 中断状态标志，调用 interrupt 方法会使中断状态被置位，可以不时地通过 Thread.currentThread 方法获取当前线程，然后通过 isInterrupted 方法判断线程的中断状态。</p>
<p>在一个被阻塞（sleep 或 wait）的线程上调用 interrupt 方法时会产生 InterruptedException，如果要对一个存在阻塞情况的线程发送终止请求，必须要处理 InterruptedException。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程存在以下 6 种状态：New、Runnable、Blocked、Waiting、Timed waiting 和 Terminated，调用 getState 可以获取当前状态。</p>
<p>使用 new 创建一个新线程时，线程还没有开始运行，状态是 New，一旦调用 start 方法，线程处于 Runnable 状态。</p>
<p>如果线程视图获取一个被其他线程持有的锁，线程会进入 Blocked 状态，直至其他线程释放锁且调度器允许该线程持有锁；而当线程等待另一个线程通知调度器一个条件时，会进入 Waiting 状态。有些方法包含超时参数，可以通过调用这些方法进入 Timed waiting 状态。</p>
<p>当线程执行完毕或出现没有被捕获的异常时线程被终止。</p>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>Java 中每个线程都有优先级，默认情况线程继承父进程的优先级，可以通过 setProiority 方法提高或降低优先级。Java 线程的优先级取决于宿主机平台的线程实现机制，所以不要使程序的正确性依赖于优先级。</p>
<p>通过调用 setDaemon 方法可以将线程转换为守护线程，守护线程的唯一用途是为其他线程提供服务，当只剩下守护线程时虚拟机就退出了。守护线程永远不应该访问文件、数据库等固有资源，它可能会在任何时候发生中断。</p>
<p>线程在因为异常而死亡之前，会将异常传递到一个处理器，该处理器实现 Thread.UncaughtExceptionHandler 接口。可以通过 setUncaughtExceptionHandler 方法为线程安装处理器，也可以使用静态方法 setDefaultUncaughtExceptionHandler  为所有线程安装处理器。线程的处理器默认为空。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在大部分多线程应用中，多个线程会共享数据，如果多个线程都对同一个对象进行修改，将会根据写入的顺序产生不同的结果。为了避免多线程引起的共享数据错误，需要使用同步存取，Java 提供了 synchronized 关键字和 ReentrantLock 类两种机制来确保任何时刻只有一个线程进入临界区。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>使用 ReentrantLock 时，需要在代码块前通过 lock 方法对代码块加锁，并在 finally 子句（确保抛出异常时能够释放）中通过 unlock 方法释放锁。一旦一个线程封锁了锁对象。其他线程无法通过 lock 语句而被阻塞，直到锁被释放。</p>
<p>ReentrantLock 是可重入的，即线程可以重复获得已经持有的锁，ReentrantLock 用一个计数器来跟踪 lock 的嵌套调用。</p>
<p>ReentrantLock 有公平策略，即锁倾向于等待时间最长的线程。公平策略会影响性能，默认不是公平的。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>有时进入临界区的线程需要在某些条件满足时才能执行，但这一线程刚刚获得了锁，其他线程无法在此时持有锁进而无法工作，所以需要条件对象 condition。</p>
<p>一个锁对象可以有多个条件对象，通过 newCondition 方法可以获得条件对象。当条件不满足时通过 await 方法阻塞线程并放弃锁，进入该条件的等待集。等待集中的线程在锁可用时不会解除阻塞，需要另一线程调用同一条件的 signalAll 方法才会变为可运行状态并开始竞争锁，重新获取锁后从 await 返回并从被阻塞的位置继续执行。</p>
<p>注意 signalAll 方法无法确保条件已经被满足，需要再次去检测条件。另外 signal 方法可以随机解除等待集中的一个线程，比 signalAll 更高效，但也存在危险（随机选择的线程有可能仍然不能运行）。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>锁和条件对象提供了高度的锁定控制，然而在多数情况下不需要那样的控制。Java 中每个对象都有一个内部锁，如果一个方法用 synchronized 关键字声明，则锁对象将保护整个方法，即调用方法必须获得内部锁。</p>
<p>内部对象锁只有一个条件，通过 wait 方法可以将线程添加到等待集，notifyAll 或 notify 方法解除等待线程的阻塞状态。</p>
<p>synchronized 可用于静态方法，方法将获得类对象的内部锁。</p>
<p>通过对一个对象使用 synchronized 也可以获得锁，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Java 提供了一种稍弱的同步机制，即 volatile 变量。变量声明为 volatile 之后，对该变量的操作不会与其他内存操作一起重排序，也不会被缓存在寄存器等地方，读取 volatile 变量时总会返回最新写入的值。</p>
<p>访问 volatile 变量不会加锁，线程不会阻塞，比 synchronized 更轻量级。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>java.util.concurrent.atomic 包中有很多类使用了高效的机器级指令保证操作的原子性，如 AtomicInteger 提供了 incrementAndGet 和 decrementAndGet 方法以原子方式将整数自增、自减。</p>
<p>如果大量线程访问相同的原子值，性能会大幅下降，Java8 提供了 LongAdder 和 LongAccumulator 来解决这个问题。</p>
<p>LongAdder 包含多个变量，其总和为当前值。不同线程更新不同的加数，如果全部工作完成后才需要总和的值这种方法非常高效。</p>
<p>LongAccumulator 在构造器中可以提供这个操作及它的零元素，通过 accumulate 方法加入新的值，通过 get 方法获取当前值，最终得到 a1 op a2 op a3 … 。</p>
<h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>有些类不是线程安全的，如 SimpleDateFormat，使用同步开销太大，在需要时创建新的 SimpleDateFormat 对象也有些浪费，可以为每个线程构造一个实例，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; format =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">String dateString = format.get().format(<span class="keyword">new</span> Date()) ;</span><br></pre></td></tr></table></figure>
<h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3><p>线程在调用 lock 方法获取锁时可能会发生阻塞，如果希望获取锁失败后立即返回，可以使用 tryLock 方法，成功获取锁后返回 true，否则返回 false。tryLock 可以使用超时参数，使阻塞时间不超过给定的值。</p>
<h3 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读/写锁"></a>读/写锁</h3><p>ReentrantLock 可以通过 readLock 和 writeLock 方法抽取出读锁和写锁，在多读取少写入的情况下可以仅使用写锁，允许读者线程共享访问。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>很多线程问题可以通过使用阻塞队列来方便、安全地解决，生产者线程向队列插入元素，消费者线程读取它们。当试图向已满队列添加元素或从空队列读取元素时，阻塞队列导致线程阻塞。</p>
<p>阻塞队列提供了 3 组对列满或空有不同响应方式的方法，其中 put、take 会阻塞，add、remove、element 会抛出异常，offer、poll、peek 返回 false 或 null。</p>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>多线程并发地修改一个数据结构，可能会破坏数据，如 HashMap。可以通过锁来加以保护，更好的方式是使用线程安全的集合。</p>
<p>java.util.concurrent 包提供了映射、有序集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet 和 ConcurrentLinkedQueue。集合返回弱一致性的迭代器，即不一定能反映出所有的修改，但能保证同一个值不会返回两次。</p>
<h2 id="Callable-和-Future"><a href="#Callable-和-Future" class="headerlink" title="Callable 和 Future"></a>Callable 和 Future</h2><p>Callable 和 Runnable 类似，只是任务执行的方法有一个参数化类型的返回值。</p>
<p>Future 保存异步计算的结果，将 Future 对象交给某个线程，在结果计算成功后可以通过 Future 对象获取结果。Future 对象的 get 方法会阻塞，直到计算完成。get 方法可以设置超时时间，超时会抛出 TimeoutException。</p>
<p>FutureTask 可以将 Callable 转为 Future 和 Runnable，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; callable = ...;</span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br><span class="line">Integer result = task.get();</span><br></pre></td></tr></table></figure>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>如果程序中需要使用大量的生命期很短的线程，就应该使用线程池。线程池中包含空闲线程，可用于执行任务，任务完成后线程不会死亡，而是准备完成下一个任务。线程池还可以配置固定的线程数来限制并发线程总数。</p>
<p>Java 中 Executors 类提供了构建线程池的方法，其中 newCachedThreadPool 会在必要时创建新线程，空闲线程保留 60 秒；newFixedThreadPool 创建固定线程数的线程池，空线程会一直保留；newSingleThreadExecutor 创建只有一个线程的线程池，顺序执行提交的任务；newScheduledThreadPool 和 newSingleThreadScheduledExecutor 用于创建预定执行的线程池。</p>
<p>通过 submit 方法可以将 Runnable 或 Callable 对象提交给 ExecutorService，返回 Future 对象（对提交 Runnable 返回的 Future 调用 get 方法返回 null）。提交完全部任务应该调用 shutdown 方法，该方法会使执行器不再接收新任务，并在完成全部任务后终止线程。调用 showdownNow 方法会取消尚未开始的任务并试图中止正在运行的线程。</p>
<p>awaitTermination 方法需要传入一个超时时间，该方法会阻塞至全部任务执行完毕或到达超时时间。</p>
<p>ScheduledExecutorService 为预定执行或重复执行任务而设计，可以预定任务在初始延迟后只运行一次，也可以预定一个任务周期性执行。</p>
<p>执行器还可以控制一组任务，如 invokeAny 方法提交一个任务集合，并返回最先完成的任务结果；invokeAll 返回 Future 对象列表。构建 ExecutorCompletionService 能够按完成顺序获取结果，没有已完成结果时阻塞。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 安装与基本配置</title>
    <url>/2018/06/06/Kafka-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Kafka 是使用 Java 开发的应用程序，可以在安装了 Java 环境的多种操作系统上运行。另外 Kafka 使用 ZooKeeper 保存 broker 的元数据。</p>
<p>在配置好 Java 环境和 ZooKeeper 之后，就可以开始下载并安装 Kafka 了。</p>
<a id="more"></a>
<h2 id="安装-Kafka-Broker"><a href="#安装-Kafka-Broker" class="headerlink" title="安装 Kafka Broker"></a>安装 Kafka Broker</h2><p>在 <a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka 官网</a> 可以下载到最新版本的 Kafka，如 <code>kafka_2.11-1.1.0.tgz</code> 。使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> tar -zxf kafka_2.11-1.1.0.tgz</span><br></pre></td></tr></table></figure>
<p>解压文件，在启动 ZooKeeper 后进入 Kafka 主目录，通过命令启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
<p>启动 Kafka。</p>
<h2 id="broker-的基本配置"><a href="#broker-的基本配置" class="headerlink" title="broker 的基本配置"></a>broker 的基本配置</h2><p>在单机调试时可以使用默认配置，如果要在正式环境下部署 broker 集群，需要对配置进行调整。</p>
<h3 id="broker-id"><a href="#broker-id" class="headerlink" title="broker.id"></a>broker.id</h3><p>broker 的标识符，默认为 0，可以设置为任意整数，在整个 Kafka 集群内唯一。</p>
<p>建议设置成与机器名相关的整数。</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>Kafka 监听的端口号，默认为 9092，可以设置成任意可用端口号。</p>
<h3 id="zookeeper-connect"><a href="#zookeeper-connect" class="headerlink" title="zookeeper.connect"></a>zookeeper.connect</h3><p>用于存储 broker 元数据的 ZooKeeper 地址，默认为 localhost:2181，可以按照 <code>hostname:port/path</code> 格式进行配置，多个地址用冒号 <code>:</code> 分隔。</p>
<p>推荐配置 path 作为 Kafka 集群的 chroot 环境，如不配置则默认使用 ZooKeeper 根目录。</p>
<h3 id="log-dirs"><a href="#log-dirs" class="headerlink" title="log.dirs"></a>log.dirs</h3><p>Kafka 使用磁盘保存消息，log.dirs 指定存放消息的路径，默认为 /tmp/kafka-logs，多个地址使用逗号 <code>,</code> 分隔。</p>
<p>同一个分区的数据会保存到同一个路径下。broker 根据 <code>最少使用</code> 原则，向拥有最少分区的路径下添加分区数据，而不是向拥有最小磁盘空间的路径添加分区数据。</p>
<h3 id="num-recovery-threads-per-data-dir"><a href="#num-recovery-threads-per-data-dir" class="headerlink" title="num.recovery.threads.per.data.dir"></a>num.recovery.threads.per.data.dir</h3><p>broker 使用可配置的线程池来完成启动、关闭或崩溃时重启时的操作，对于包含大量分区的服务器，并行操作可能会节省大量时间。需要注意的是，该配置针对单个目录，最终使用的线程数是该配置与目录数的乘积。</p>
<h3 id="auto-create-topics-enable"><a href="#auto-create-topics-enable" class="headerlink" title="auto.create.topics.enable"></a>auto.create.topics.enable</h3><p>默认情况下，broker 对不存在的主题进行操作时会自动创建主题，即向不存在的主题写入消息、读取消息或请求主题元数据。如果需要控制主题的创建可以将该配置改为 false。</p>
<h2 id="topic-的基本配置"><a href="#topic-的基本配置" class="headerlink" title="topic 的基本配置"></a>topic 的基本配置</h2><p>Kafka 可以通过管理工具对每个主题进行单独的配置，如分区个数、数据保留策略等，broker 提供的默认的配置适用于常规场景，可以作为基准。</p>
<h3 id="num-partitions"><a href="#num-partitions" class="headerlink" title="num.partitions"></a>num.partitions</h3><p>该参数指定新创建的主题包含的分区个数，默认为 1。Kafka 通过分区对主题进行横向扩展，当有新的 broker 加入时，可以通过分区来实现集群的负载均衡。</p>
<p>为了使分区能够分布到所有 broker 上，分区个数必须大于 broker 个数。如需要对包含大量消息的主题进行负载均衡，就需要大量的分区。</p>
<p>通常可以用主题吞吐量除以消费者吞吐量估算出需要分区的个数，即如果每秒对主题写入和读取 1 GB 的数据，每个消费者每秒可以处理 50 MB，则至少需要 20 个分区。如果无法确定吞吐量，根据经验，单个分区的数据量应该控制在 25 GB 以内。</p>
<h3 id="log-retention-ms"><a href="#log-retention-ms" class="headerlink" title="log.retention.ms"></a>log.retention.ms</h3><p>数据保留的毫秒数。Kafka 默认使用 log.retention.hours 来配置数据保留时间，默认值为 168 小时，即 1 周。推荐使用 log.retention.ms 来配置数据保留时间。</p>
<p>当同时配置多个数据保留时间，会优先使用具有最小值的那个参数。</p>
<h3 id="log-retention-bytes"><a href="#log-retention-bytes" class="headerlink" title="log.retention.bytes"></a>log.retention.bytes</h3><p>该配置作用于每一个分区，表示保留的最大数据量。比如该配置为 1 GB 时，一个包含 8 个分区的主题最多可以保留 8 GB 的数据量。</p>
<p>此配置和 log.retention.ms 等数据保留时间的配置，在任意一个条件到达边界时删除旧数据。</p>
<h3 id="log-segment-bytes"><a href="#log-segment-bytes" class="headerlink" title="log.segment.bytes"></a>log.segment.bytes</h3><p>Kafka 以日志片段的形式存储数据，前面提到的 log.retention.ms 和 log.retention.bytes 都作用于日志片段而不是单条消息。log.segment.bytes 指定单个日志片段的大小，默认为 1 GB。消息写入到日志片段，到达日志片段上限时关闭该片段，并开启新片段。</p>
<p>日志片段关闭前，片段内的消息是不会过期的。如果片段上限为 1 GB，每天接收 100 MB 消息，数据保留时间为 1 周，则日志片段最多需要 17 天才会被删除。</p>
<h3 id="log-segment-ms"><a href="#log-segment-ms" class="headerlink" title="log.segment.ms"></a>log.segment.ms</h3><p>该配置指定日志片段开启后多长时间关闭片段，没有默认值。此配置和 log.segment.bytes 一起使用时，任意一个发生作用时关闭片段并启用新的日志片段。</p>
<h3 id="message-max-bytes"><a href="#message-max-bytes" class="headerlink" title="message.max.bytes"></a>message.max.bytes</h3><p>限制单个消息大小，默认为 1000000，即 1 MB。当生产者尝试发送大于此配置的消息时，消息不会被接受，返回错误信息。此配置只压缩后的消息大小，实际大小可以大于配置的值。</p>
<h2 id="broker-集群"><a href="#broker-集群" class="headerlink" title="broker 集群"></a>broker 集群</h2><p>使用集群可以跨服务器进行负载均衡，还可以通过复制功能避免单点故障造成的数据丢失，提供高可用性。</p>
<h3 id="broker-个数"><a href="#broker-个数" class="headerlink" title="broker 个数"></a>broker 个数</h3><p>判断所需要的 broker 个数首先需要考虑数据量，如果整个集群要保留 10 TB 的数据，单个 broker 可以存储 2 TB，则至少需要 5 个 broker。如果启用数据复制，则至少还需要一倍的空间，即至少需要 10 个 broker。</p>
<p>另外需要考虑考虑集群处理请求的能力，通过增加 broker 可以提高每秒处理请求的上限，也可以解决因磁盘吞吐量低或内存不足等造成的性能问题。</p>
<h3 id="broker-集群配置"><a href="#broker-集群配置" class="headerlink" title="broker 集群配置"></a>broker 集群配置</h3><p>要把 broker 加到集群中，只需修改两个配置参数。</p>
<p>一是修改 zookeeper.connect ，所有 broker 需使用相同的 ZooKeeper 地址来保存元数据。</p>
<p>二是修改 broker.id 的值，broker.id 需在集群内唯一，否则将无法启动。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kafka.apache.org/documentation/" target="_blank" rel="noopener">Kafka 官方文档</a></p>
<p><a href="http://shop.oreilly.com/product/0636920044123.do" target="_blank" rel="noopener">Kafka 权威指南</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 内部工作原理</title>
    <url>/2018/07/23/Kafka-%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>了解 Kafka 的内部工作原理有助于理解 Kafka 的行为和诊断问题，本篇文章主要从集群成员关系、控制器、复制、处理请求和存储等方面介绍 Kafka 的内部机制。</p>
<a id="more"></a>
<h2 id="集群成员关系"><a href="#集群成员关系" class="headerlink" title="集群成员关系"></a>集群成员关系</h2><p>Kafka 使用 ZooKeeper 来维护集群内成员的信息，每个 broker 在启动时都通过在 /brokers/ids 路径创建临时节点将自己的唯一标示 broker.id 注册到 ZooKeeper。</p>
<p>Kafka 会订阅 ZooKeeper 的 /brokers/ids 路径，在有 broker 加入或退出集群时收到通知。</p>
<p>关闭 broker 时对应的临时节点会消失，不过它的 id 会继续存储在其他数据中，如主题的副本列表。完全关闭一个 broker 后，如果使用相同 id 启动一个全新 broker，它会立即加入集群，并拥有和旧 broker 相同的分区和主题。</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>控制器其实是一个 broker，除一般 broker 的功能外，还负责选举分区首领。</p>
<p>集群内的 broker 通过创建临时节点 /controller 使自己成为控制器，如果收到【节点已存在】异常，即控制器已存在，会创建 ZooKeeper 的 watch 对象，在节点变更时收到通知、再次尝试成为控制器，以确保集群内始终存在一个控制器。</p>
<p>新选出来的控制器会用一个递增的值更新 /controller_epoch 节点，在其他 broker 收到 controller epoch 的值后，如果收到包含旧的 epoch 的来自控制器的消息就会选择忽略，以此来避免脑裂（多个控制器）。</p>
<p>当控制器通过 ZooKeeper 路径发现集群内的 broker 离开时，会遍历那些失去首领的分区，在分区副本列表中选择 broker 成为新的首领，然后向所有包含新首领和现有跟随者的 broker 发送请求，传递新首领及跟随者的信息。随后，新首领开始处理来自生产者和消费者的请求，跟随者开始从新首领那里复制消息。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>复制是 Kafka 的核心功能之一，可以在个别节点失效时仍然保证 Kafka 的可用性和持久性。</p>
<p>Kafka 使用主题来组织数据，每个主题被分成若干个分区，而每个分区可以有多个副本。</p>
<p>副本分为首领副本和跟随者副本两种。每个分区有一个首领副本，所有生产者、消费者的请求都会经过首领副本。首领以外的副本都是跟随者副本，这些副本不处理来自生产者和消费者的请求，唯一的任务时从首领复制消息，在首领崩溃时成为新首领。</p>
<p>跟随者副本像消费者一样往首领副本发送请求，请求中包含了跟随者想要获取消息的偏移量，这些偏移量总是有序的。首领通过查看每个跟随者的最新偏移量知道每个跟随者复制的进度。如果跟随者在 10 s 内没有请求最新的数据，就会被认为是不同步的。只有持续请求最新消息的副本才是同步的副本，首领失效时只有同步副本才可能成为新首领。</p>
<p>除了当前首领外，每个分区都有一个首选首领，即创建主题时选定的首领。创建主题时会在 broker 之间均衡首领，所以当首选首领成为当前首领时，broker 间的负载会得到均衡。默认情况下，auto.leader.rebalance.enable 的值为 true，即如果检查到当前首领不是首选首领且首选首领是同步的，就会出发首领选举，让首选首领成为当前首领。</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>broker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求，Kafka 提供一个基于 TCP 的二进制协议来指定请求和相应的格式，并按请求到达的顺序来处理。</p>
<p>broker 在监听的端口上运行 Acceptor 线程，线程创建连接后交给 Processor 线程去处理。Processor 线程将请求放入请求队列，IO 线程处理后将响应放入响应队列，再由 Processor 线程返回响应。</p>
<p>生产者和消费者的请求必须发送给分区的首领副本，对特定分区的获取请求也不能发送给不含该分区首领的 broker 上。客户端通过请求元数据来确定请求该发往何处，请求包含订阅的主题列表，响应包含主题的分区、副本信息。客户端会缓存元数据信息，通过 metadata.max.age.ms 可以配置刷新时间。如果 broker 收到不该发向自己的请求，会返回相应的错误，客户端收到错误后会刷新元数据并重发请求。</p>
<h3 id="生产请求"><a href="#生产请求" class="headerlink" title="生产请求"></a>生产请求</h3><p>生产者使用 acks 配置项来定义需要多少个 broker 确认才能认为消息写入成功。acks 为 0 时只需发送消息，不会等待 broker 确认；acks 为 1 时只要首领确认就算写入成功；acks 为 all 时需要所有 broker 确认才算成功。</p>
<p>broker 收到生产请求后，会判断用户是否有写入权限、检查 acks 的值是否有效，如果 acks 为 all 时还会检查是否有足够的 broker 保证消息能被安全写入。</p>
<p>在通过一些列的检查后，broker 会将消息写入到文件系统缓存中，不保证何时被刷新到磁盘上。Kafka 不会等待数据写入磁盘，而是依赖复制保证持久性。消息写入分区首领后，如果 acks 大于 1，则放入一个缓冲区，等待其他 broker 响应，否则直接返回给客户端。</p>
<h3 id="获取请求"><a href="#获取请求" class="headerlink" title="获取请求"></a>获取请求</h3><p>客户端向 broker 发送获取请求时，会将主题、偏移量等信息传给 broker，而 broker 则先检查请求是否有效，如偏移量是否存在，检查通过后使用零复制技术（直接从文件里发送到网络，不经过缓冲区，性能更好）返回给客户端。</p>
<p>如果客户端配置了请求数据下限，broker 在消息不够时会先等待，直到消息足够或到达等待时间上限时再返回。</p>
<p>需要注意的是，大部分客户端只能读取到已经被写入到全部同步副本的消息，没有被写入到全部同步副本的消息被认为是不安全的，如果首领崩溃，可能会破坏一致性。这也意味着如果 broker 间复制消息的速度变慢，消息到达消费者的时间也会变长，可以通过 replica.lag.time.max.ms 来配置复制消息时被允许的最大延迟时间。</p>
<h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><p>Kafka 的基本存储单元是分区，分区无法在多个 broker 间再细分，也无法在多个磁盘上再细分，所以分区大小受到单个挂载点可用空间的限制。Kafka 通过 log.dirs 来配置存储分区的目录。</p>
<h3 id="分配分区"><a href="#分配分区" class="headerlink" title="分配分区"></a>分配分区</h3><p>创建主题时，Kafka 会首先决定如何在 broker 间分配分区。在分配分区时，Kafka 会尽可能地将各分区副本在 broker 间均匀分配，首领分区也会尽可能地均匀分配，如果 broker 指定了机架信息，会尽可能地将各分区副本均匀地分配到不同机架。</p>
<p>分配完分区之后，Kafka 会根据各目录中的分区数量来决定分区使用哪个目录，新的分区总被添加到分区数最小的目录中。</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>在一个大文件中查找和删除消息效率不高，所以 Kafka 把每个分区分成若干个片段。默认情况下每个片段包含 1 GB 或一周的数据，以较小的为准。写入数据时，如果达到上限，就关闭当前文件，打开一个新片段。</p>
<p>正在写入的数据片段称为活跃片段，活跃片段永远不会被删除。已经关闭的不活跃片段，会根据配置的最长保留时间或最大保存消息量来删除旧的消息片段。</p>
<h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>Kafka 的消息和偏移量都保存在文件中，磁盘内的消息、生产者发送过来的消息及发送给消费的消息是一样的，所以可以使用零复制技术发送给消费者。</p>
<p>另外消息中还包含了消息大小、校验和、消息格式版本号、压缩算法和时间戳，如果生产者发送的是压缩过的消息，同一个批次的消息会被压缩在一起，消费者在解压这个消息后，会看到整个批次的消息。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>消费者可以从任何偏移量位置读取消息，为了能更快地定位到指定偏移量，Kafka 为每个分区维护了一个索引，将偏移量映射到片段文件及在文件中的位置。</p>
<p>索引也被分成片段，删除消息时也会删除相应的索引。Kafka 不维护索引的校验和，如果索引出现损坏，Kafka 会重新读取消息来生成索引。有必要的话，删除索引的绝对安全的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kafka.apache.org/documentation/" target="_blank" rel="noopener">Kafka 官方文档</a></p>
<p><a href="http://shop.oreilly.com/product/0636920044123.do" target="_blank" rel="noopener">Kafka 权威指南</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 生产者</title>
    <url>/2018/06/07/Kafka-%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    <content><![CDATA[<p>不管把 Kafka 用作消息队列还是数据存储平台，总需要向 Kafka 写入消息的生产者和从 Kafka 读取消息的消费者。</p>
<p>本篇文章介绍如何创建生产者和消息对象、如何发送消息到 Kafka、生产者的相关配置，以及如何使用分区。</p>
<a id="more"></a>
<h2 id="创建生产者和消息对象"><a href="#创建生产者和消息对象" class="headerlink" title="创建生产者和消息对象"></a>创建生产者和消息对象</h2><p>要往 Kafka 写入消息，首先要创建一个生产者对象，并设置一些必要的属性。Kafka 生产者有 3 个必选属性。</p>
<ul>
<li>bootstrap.servers</li>
</ul>
<p>指定 broker 的地址，格式为 <code>host:port</code> ，多个地址用逗号 <code>,</code> 分隔。建议至少提供两个 broker 地址，其中一台宕机仍然可以连接到集群上。</p>
<ul>
<li>key.serializer</li>
</ul>
<p>broker 接收到的消息的键为字节数组，而生产者接口允许使用参数化类型，可以把 Java 对象作为键，所以需要知道如何将 Java 对象转为字节数组。</p>
<p>key.serializer 要求设置为一个实现了 <code>org.apache.kafka.common.serialization.Serializer</code> 接口的类。客户端默认提供了 <code>ByteArraySerializer</code> , <code>StringSerializer</code> 和 <code>IntegerSerializer</code> 。</p>
<ul>
<li>value.serializer</li>
</ul>
<p>和 key.serializer 一样，value.serializer 指定的类用于序列化消息的值。</p>
<p>创建消息对象需要指明主题 topic 和值 value，分区 partition 和键 key 可选。指定分区时消息在发送后会直接到达所选分区，不指定分区时会根据键选择一个分区，都不指定时均匀分布到各个分区。</p>
<p>创建生产者和消息对象的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"topic"</span>, <span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>发送消息主要有 3 中方式，即发送并忘记（fire-and-forget）、同步发送和异步发送。</p>
<h3 id="发送并忘记"><a href="#发送并忘记" class="headerlink" title="发送并忘记"></a>发送并忘记</h3><p>将消息发送给服务器，但不关心消息是否正常到达。大多数时候消息会正常到达，因为集群高可用，并且生产者会在发送失败时自动尝试重发。不过仍然有消息丢失的可能。记录不太重要的日志可以使用这种发送方式。</p>
<h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>发送消息时，生产者的 send 方法会先返回一个 Future 对象，调用 Future 的 get 方法等待 Kafka 响应。如果服务器返回错误，get 方法会抛出异常，否则会得到一个 RecordMetadata 对象。</p>
<p>生产者可能发生两种错误，一种是连接异常等可以通过重发消息来解决的错误，Kafka 可以配置成自动重试，如果重试多次仍存在问题，会收到重试异常。另一种是消息过大等无法通过重试解决的错误，生产者不会进行重试直接抛出异常。</p>
<h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>大多数时候我们不需要等待响应，不过在遇到消息发送失败的情况时，需要进行抛出异常、记录错误日志等操作。生产者支持异步发送消息的回调，需要在发送消息时传入实现了 <code>org.apache.kafka.clients.producer.Callback</code> 接口的回调对象。</p>
<p>使用 3 中方式发送消息的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Callback;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// ... properties 添加 producer 配置</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"topic"</span>, <span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送并忘记</span></span><br><span class="line">        producer.send(record);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步发送</span></span><br><span class="line">        RecordMetadata result = producer.send(record).get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步发送</span></span><br><span class="line">        producer.send(record, <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生产者的配置"><a href="#生产者的配置" class="headerlink" title="生产者的配置"></a>生产者的配置</h2><p>前面在创建生产者时只配置了 3 个必要参数，生产者还有很多可配置的参数，都有合理的默认值。下面介绍一些常用的配置，在内存使用、性能和可靠性方面对生产者影响较大。</p>
<h3 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h3><p>指定需要有多少个分区副本收到消息，生产者才认为消息写入成功。</p>
<p>acks=0 时生产者不会等待来自任何服务器的响应，如果当中出了任何问题消息都会丢失，不过能够以最大速度发送消息。acks=1 时只要集群首领节点收到消息生产者就会收到服务器的成功响应。acks=all 时需要等全部参与复制的节点都收到消息时才有成功响应。</p>
<h3 id="buffer-memory"><a href="#buffer-memory" class="headerlink" title="buffer.memory"></a>buffer.memory</h3><p>生产者内存缓冲区大小，用于缓冲要发送到服务器的消息。当发送消息的速度超过发送到服务器的速度，会在内存中形成消息堆积，当堆积的消息大小超过缓冲区大小时，根据 max.block.ms 所配置的阻塞时间决定被阻塞还是抛出异常。</p>
<h3 id="compression-type"><a href="#compression-type" class="headerlink" title="compression.type"></a>compression.type</h3><p>默认情况下消息发送时不会被压缩，改配置可以设置为 snappy、gzip 或 lz4，指定发送给 broker 前采用的压缩算法。snappy 占用较少传递 CPU，能够提供较好的性能好压缩比。gzip 占用较多 CPU，提供更高的压缩比。</p>
<h3 id="retries"><a href="#retries" class="headerlink" title="retries"></a>retries</h3><p>生产者收到服务器返回的错误时，如果为临时性错误，会依据该配置决定可以重试的次数。如果达到所配置的重试次数依然没有成功，则放弃并返回错误。默认的重试间隔为 100 ms，可通过 retry.backoff.ms 来调整。</p>
<p>因为生产者会自动进行重试，所以只需要处理不可重试的错误和重试次数到达上线的情况。</p>
<h3 id="batch-size"><a href="#batch-size" class="headerlink" title="batch.size"></a>batch.size</h3><p>多个消息要被发送到同一分区时，生产者会将消息放到同一个批次中统一发送。该参数指定批次可以使用的内存字节数，批次被填满时发送所有消息。不过并非要等到批次填满才会发送，只包含一条消息的批次也可能被发送。就算批次大小设置的很大，也不会造成延迟，只会占用更多的内存。</p>
<h3 id="linger-ms"><a href="#linger-ms" class="headerlink" title="linger.ms"></a>linger.ms</h3><p>指定等待更多消息加入批次的时间。生产者在批次填满或等待 linger.ms 所配置的时间后发送批次。默认情况下只要有可用的线程就会立即发送消息。设置为大于 0 的数虽然会增加延迟，但能明显提升吞吐量。</p>
<h3 id="client-id"><a href="#client-id" class="headerlink" title="client.id"></a>client.id</h3><p>任意字符串，用于标记消息来源。</p>
<h3 id="max-in-flight-requests-per-connection"><a href="#max-in-flight-requests-per-connection" class="headerlink" title="max.in.flight.requests.per.connection"></a>max.in.flight.requests.per.connection</h3><p>指定生产者在收到服务器响应之前可以发送多少次消息，为 1 可以保证按照发送顺序写入到服务器，即使发生了重试。该参数的值越高，占用内存越大，吞吐量也越大。</p>
<h3 id="timeout-ms、request-timeout-ms-和-metadata-fetch-timeout-ms"><a href="#timeout-ms、request-timeout-ms-和-metadata-fetch-timeout-ms" class="headerlink" title="timeout.ms、request.timeout.ms 和 metadata.fetch.timeout.ms"></a>timeout.ms、request.timeout.ms 和 metadata.fetch.timeout.ms</h3><p>分别指定 broker 间同步副本等待响应的超时时间，生产者发送数据等待响应的超时时间和生产者获取元数据（如目标分区的首领是哪个 broker）等待服务器响应的超时时间。</p>
<h3 id="max-block-ms"><a href="#max-block-ms" class="headerlink" title="max.block.ms"></a>max.block.ms</h3><p>该参数指定在调用 send 方法或使用 partitionsFor 方法获取元数据时的最大阻塞时，阻塞时间达到 max.block.ms 时生产者会抛出异常。</p>
<h3 id="max-request-size"><a href="#max-request-size" class="headerlink" title="max.request.size"></a>max.request.size</h3><p>用于控制生产者发送请求的大小，即可以指单个消息，也可以指批次内所有消息的总大小。broker 也有对消息大小的限制，最好配置可以匹配，避免请求被 broker 拒绝。</p>
<h3 id="receive-buffer-bytes-和-send-buffer-bytes"><a href="#receive-buffer-bytes-和-send-buffer-bytes" class="headerlink" title="receive.buffer.bytes 和 send.buffer.bytes"></a>receive.buffer.bytes 和 send.buffer.bytes</h3><p>指定 TCP socket 接收和发送数据包的缓冲区大小，为 -1 时使用操作系统的默认值。如果生产者与 broker 处于不同的数据中心，可以适当增大配置。</p>
<h2 id="如何使用分区"><a href="#如何使用分区" class="headerlink" title="如何使用分区"></a>如何使用分区</h2><p>ProducerRecord 对象可以只包含主题和值，键默认为 null。键既可以作为消息的附加信息，也可以用于决定消息被写入哪个分区。</p>
<p>键为 null 时，如使用默认分区器，则通过轮训将消息随机写入到各个可用分区。键不为空时，默认分区器会使用散列算法将消息映射到所有分区上。</p>
<p>如果需要自定义分区器，可以实现 Partitioner 接口，并重载 partition 方法，实例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.kafka;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分区逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现自定义分区器后，需要在生产者的配置中指明所用的分区器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">properties.put(<span class="string">"partitioner.class"</span>, <span class="string">"com.ulyssesss.kafka.MyPartitioner"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kafka.apache.org/documentation/" target="_blank" rel="noopener">Kafka 官方文档</a></p>
<p><a href="http://shop.oreilly.com/product/0636920044123.do" target="_blank" rel="noopener">Kafka 权威指南</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 消费者</title>
    <url>/2018/07/20/Kafka-%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<p>应用程序使用 KafkaConsumer 向 Kafka 订阅主题，并从订阅的主题上接收消息。Kafka 的消费者涉及一些独特的概念，本篇文章首先解析一些重要概念，然后介绍如何读取消息及相关配置。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="消费者和消费者群组"><a href="#消费者和消费者群组" class="headerlink" title="消费者和消费者群组"></a>消费者和消费者群组</h3><p>Kafka 消费者从属于消费者群组，群组内的消费者订阅同一个主题，每个消费者接收主题一部分分区的消息。</p>
<p>如果主题 T1 有 4 个分区，消费者 C1 是订阅了 T1 的群组 G1 内的唯一消费者，则 C1 将接收到全部 4 个分区的消息。而如果 G1 内包含 2 个消费者，则每个消费者接收 2 个分区的消息；如果 G1 包含 4 个消费者，则每个消费者接收 1 个分区的消息。但如果 G1 内包含 5 个消费者，则只有 4 个消费者会分配到分区并接收消息。</p>
<p>在群组中增加消费者是横向伸缩消费能力的主要方式。由于当消费者数量超过分区数时，多余的消费者会被闲置，所以有必要为主题创建较多的分区，以便在负载增长时加入更多消费者。横向伸缩 Kafka 消费者和消费者群组并不会对性能造成负面影响。</p>
<h3 id="分区再均衡"><a href="#分区再均衡" class="headerlink" title="分区再均衡"></a>分区再均衡</h3><p>群组内的消费者共同读取主题的分区，当新的消费者加入或某个消费者被关闭时，分区会重新分配。分区所有权从一个消费者转移到另一个消费者的行为称为再均衡。</p>
<p>消费者通过向被指派为群组协调器的 broker 发送心跳来维持和群组的从属关系及分区所有权。消费者在轮询消息或提交偏移量时发送心跳，当停止发送心跳的时间足够长时被认为死亡，触发再均衡。</p>
<p>0.10.1 版本中 Kafka 引用了一个独立的心跳线程，在轮询消息的空档发送心跳。</p>
<h2 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h2><p>要读取 Kafka 中消息，首要需要创建 KafkaConsumer 消费者对象，然后订阅主题、轮训消息及提交偏移量。</p>
<h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h3><p>创建 KafkaConsumer 对象和创建 KafkaProducer 对象非常类似，需要将一些必要的属性在 Properties 对象中指明。</p>
<p>KafkaConsumer 的必要属性包括 bootstrap.servers，key.deserializer 和 value.deserializer，分别为 Kafka 集群的地址，键和值的反序列化器。</p>
<p>另外 group.id 指定所属的消费者群组，不指定时消费者不输入任何一个群组。</p>
<h3 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h3><p>KafkaConsumer 对象通过 subscribe 方法订阅主题，既可以订阅单个主题，也可以订阅多个主题，还可以通过正则表达式订阅相关的主题。</p>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>轮询是消费者 API 的核心，消费者通过轮询想发服务发送请求，开发者只需使用一组简单的 API 处理分区返回的数据，轮询会透明地处理群组协调、分区再均衡、发送心跳等细节。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>创建消费者对象、订阅主题并轮询消息的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"group.id"</span>, <span class="string">"Group1"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">"Topic1"</span>, <span class="string">"Topic2"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                    System.out.println(record.topic() + <span class="string">"\n"</span> + record.partition() + <span class="string">"\n"</span></span><br><span class="line">                            + record.offset() + <span class="string">"\n"</span> + record.key() + <span class="string">"\n"</span> + record.value() + <span class="string">"\n\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 poll 方法返回一个消息列表，没条记录都包含了所属主题、分区、偏移量及键值等信息。</p>
<p>poll 方法在消费者缓存区没有可用数据时发生阻塞，poll 方法的参数控制最大阻塞时间，达到阻塞时间上限时不论是否有可用数据都必须返回。超时时间取决于应用对响应速度的要求，即要在多长时间内把控制权归还给轮询消息的线程。</p>
<p>close 方法用于在退出应用前关闭消费者，网络连接和 socket 随之关闭，触发再均衡。</p>
<p>一个消费者应该使用一个线程，如果要在群组中运行多个消费者，需要让消费者运行在自己的线程中。最好将逻辑封装在对象中，然后使用 ExecutorService 启动多个线程并执行相应逻辑。</p>
<h2 id="消费者的配置"><a href="#消费者的配置" class="headerlink" title="消费者的配置"></a>消费者的配置</h2><p>Kafka 消费者大部分的配置都有合理的默认值，一般情况下不需要改动。一下为一些重要的属性，跟性能和可用性有很大关系。</p>
<h3 id="fetch-min-bytes"><a href="#fetch-min-bytes" class="headerlink" title="fetch.min.bytes"></a>fetch.min.bytes</h3><p>指定消费者从服务器获取消息的最小字节数，如果数据量小于指定的大小，会等到有足够的可用数据再返回。该配置可以在一定程度上杜绝在主题不活跃期间来来回回地处理消息，降低 broker 工作负载。</p>
<h3 id="fetch-max-wait-ms"><a href="#fetch-max-wait-ms" class="headerlink" title="fetch.max.wait.ms"></a>fetch.max.wait.ms</h3><p>指定最长等待时间，与 fetch.min.bytes 联合使用，如 fetch.min.bytes 指定为 1 MB，fetch.max.wait.ms 指定为 100 ms，则 broker 在收到请求后，要么返回 1 MB 的数据，要么在 100 ms 内返回所有可用数据，任一条件满足就会返回。</p>
<h3 id="max-partition-fetch-bytes"><a href="#max-partition-fetch-bytes" class="headerlink" title="max.partition.fetch.bytes"></a>max.partition.fetch.bytes</h3><p>指定每个分区返回给消费者的最大字节数，默认 1 MB，即如果有 20 个分区，4 个消费者，每个消费者至少需要 5 MB 的内存来接收消息。分配内存时可以多分配一些，以便在某个消费者崩溃时其他消费者处理更多的分区。</p>
<p>需要注意的是该配置需要比 broker 的 max.message.size 大，否则可能消费者无法接收消息而一直挂起重试。另外需要注意处理时间，单次返回数据越多处理时间也越多，可以将此配置的值改小或延长会话过期时间。</p>
<h3 id="session-timeout-ms"><a href="#session-timeout-ms" class="headerlink" title="session.timeout.ms"></a>session.timeout.ms</h3><p>指定消费者在被认为死亡之前可以与服务器断开的时间，默认 3 秒。如果在该配置指定的时间内发送心跳，就会被认为死亡并触发再均衡。heartbeat.interval.ms 指定 poll 方法发送心跳的频率，一般为 session.timeout.ms 的三分之一，要同时注意这两个配置。</p>
<h3 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto.offset.reset"></a>auto.offset.reset</h3><p>指定消费者在读取一个没有偏移量或偏移量无效的分区时该从哪个位置开始读取，默认为 latest，即从最近记录开始读取。另一个值为 earliest，即从起始位置开始读取。</p>
<h3 id="enable-auto-commit"><a href="#enable-auto-commit" class="headerlink" title="enable.auto.commit"></a>enable.auto.commit</h3><p>指定是否自动提交偏移量，默认为 true，通过 auto.commit.interval.ms 可以控制自动提交的频率。稍后会介绍几种不同的提交偏移量的方式。</p>
<h3 id="partition-assignment-strategy"><a href="#partition-assignment-strategy" class="headerlink" title="partition.assignment.strategy"></a>partition.assignment.strategy</h3><p>指定分区分配给消费者的策略，Kafka 默认提供两种策略，参数值分别为 org.apache.kafka.clients.consumer.RangeAssignor 和 org.apache.kafka.clients.consumer.RoundRobinAssignor。</p>
<p>Range 策略将主题的若干个连续分区分配给消费者，如果主题 T1 和 T2 都有 3 个分区，消费者 C1 和 C2 同时订阅 T1 和 T2，由于分区在主题内独立分配，C1 可能分配到两个主题的分区 0 和分区 1，而 C2 分配到两个主题的分区 2。使用 Range 策略在分区数无法被整除时就会出现上述情况。</p>
<p>RoundRobin 策略会把所有分区逐个分配给消费者。一般来说，如果所有消费者订阅相同的主题，RoundRobin 策略会尽量给所有消费者分配相同数量的分区。</p>
<h3 id="client-id"><a href="#client-id" class="headerlink" title="client.id"></a>client.id</h3><p>用于标示客户端，可以为任意字符串。</p>
<h3 id="max-poll-records"><a href="#max-poll-records" class="headerlink" title="max.poll.records"></a>max.poll.records</h3><p>用于控制单次返回的消息数量。</p>
<h3 id="receive-buffer-bytes-和-send-buffer-bytes"><a href="#receive-buffer-bytes-和-send-buffer-bytes" class="headerlink" title="receive.buffer.bytes 和 send.buffer.bytes"></a>receive.buffer.bytes 和 send.buffer.bytes</h3><p>用于设置 TCP 缓冲区大小，-1 时使用操作系统默认值。</p>
<h2 id="提交偏移量"><a href="#提交偏移量" class="headerlink" title="提交偏移量"></a>提交偏移量</h2><p>Kafka 通过偏移量判断消息是否被读取过。消费者向一个特殊的主题 _consumer_offset 发送消息，消息中包括分区的偏移量。提交偏移量在消费者一直处于运行状态时没什么用，不过在消费者崩溃或有新的消费者加入群组并触发再均衡时，消费者通过最后提交的偏移量来从指定位置继续处理。</p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>默认情况下 enable.auto.commit 配置的值为 true，效果为每 5 秒消费自动把 poll 方法接收到的最大偏移量提交上去。提交时间间隔可以通过 auto.commit.interval.ms 控制。自动提交发生在轮询时，轮询时检查是否该提交偏移量。</p>
<p>由于自动提交为每隔一段时间提交一次，假如在上一次提交几秒后发生再均衡，均衡后从最后一次提交的偏移量位置处理消息，则会出现重复处理消息的现象。自动提交虽然方便，可是无法解决重复处理消息的问题。</p>
<h3 id="提交当前偏移量"><a href="#提交当前偏移量" class="headerlink" title="提交当前偏移量"></a>提交当前偏移量</h3><p>消费者 API 提供了主动提交当前偏移量的方法，通过控制提交时间来减少重复消息。</p>
<p>首先将 auto.commit.offset 设为 false，然后通过 commitSync 方法提交由 poll 方法返回的最新偏移量，提交成功后立即返回，提交失败则抛出异常。由于 commitSync 方法提交的为 poll 方法返回的最新偏移量，所以要在处理完所有消息后调用方法。</p>
<h3 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h3><p>通过 commitSync 方法提交偏移量在 broker 回应之前会阻塞程序，限制吞吐量。通过异步方式 commitAsync 提交，可以只管发送提交请求无需等待。由于 commitAsync 方法会异步提交偏移量，所以不会像 commitSync 方法一样在失败后重试。</p>
<h3 id="同步与异步组合提交"><a href="#同步与异步组合提交" class="headerlink" title="同步与异步组合提交"></a>同步与异步组合提交</h3><p>通常情况下，偶尔出现提交失败不重试也不会造成影响，但如果发生在关闭消费者或再均衡之前的最后一次提交，就要确保能够提交成功。可以组合使用 commitSync 和 commitAsync 方法，在处理完一批消息后异步提交，在跳出循环后同步提交，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提交特定偏移量"><a href="#提交特定偏移量" class="headerlink" title="提交特定偏移量"></a>提交特定偏移量</h3><p>前面提到的提交方式无法提交批次中间的偏移量，而在调用 commitAsync 和 commitSync 方法时，通过传入包含分区和偏移量的 map 来提交特定的偏移量，所提交的偏移量为期望在下一次进行处理的偏移量。</p>
<h2 id="再均衡监听器"><a href="#再均衡监听器" class="headerlink" title="再均衡监听器"></a>再均衡监听器</h2><p>消费者在退出或进行分区再均衡之前，可能会做一些如关闭数据库连接的清理操作，在调用 subscribe 方法时传入 ConsumerRebalanceListener 实例可以实现再均衡的监听。</p>
<p>ConsumerRebalanceListener 有两个方法，onPartitionsRevoked 在停止读取消息之后、再均衡开始之前被调用；onPartitionsAssigned 会在重新分配分区后、消费者开始读取消息之前被调用。可以在 onPartitionsRevoked 方法中提交偏移量的 map 来记录已经处理过的消息。</p>
<h2 id="从特定偏移量处理消息"><a href="#从特定偏移量处理消息" class="headerlink" title="从特定偏移量处理消息"></a>从特定偏移量处理消息</h2><p>消费者提供了从特定偏移量处理消息的 API。如果想从分区的起始位置或末尾开始处理消息，可以直接调用 seekToBeginning 或 seekToEnd 方法。如果想从其他偏移量处理消息，可以使用 seek 方法并传入分区信息、偏移量作为参数。</p>
<p>Kafka 不支持处理消息和提交偏移量在一个原子操作中完成，而如果将偏移量记录在数据库中，再均衡时从数据库中记录的位置开始处理数据，就能使处理消息和提交偏移量要么都成功、要么都失败。</p>
<h2 id="退出轮询"><a href="#退出轮询" class="headerlink" title="退出轮询"></a>退出轮询</h2><p>消费者如果要退出轮询，需要通过另一个线程调用 consumer.wakeup() 方法，退出 poll 并抛出 WakeupException。如果调用时线程没有等待轮询，则在下一轮调用 poll 时抛出。无需处理 WakeupException，只是通过它来跳出循环。</p>
<h2 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h2><p>如果消费者只需从一个主题的所有分区或特定几个分区读取数据，就不需要加入消费者群组，而是直接通过 assign 方法为自己分配分区。注意不能同时为自己分配分区和加入消费者群组订阅主题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kafka.apache.org/documentation/" target="_blank" rel="noopener">Kafka 官方文档</a></p>
<p><a href="http://shop.oreilly.com/product/0636920044123.do" target="_blank" rel="noopener">Kafka 权威指南</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 简明教程</title>
    <url>/2017/04/17/Markdown-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote>
<p>（一）Markdown 是什么</p>
<p>（二）为什么要使用 Markdown</p>
<p>（三）如何使用 Markdown</p>
<p>（四）Markdown 编辑器</p>
</blockquote>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="（一）Markdown是什么"><a href="#（一）Markdown是什么" class="headerlink" title="（一）Markdown是什么"></a>（一）Markdown是什么</h3><p>Markdown 是一种轻量级的 <strong>标记语言</strong>，以 <strong>纯文本</strong> 的形式编写文档，通过简洁的语法代替排版，并且可以导出 <strong>HTML</strong>、<strong>PDF</strong> 等格式。</p>
<h3 id="（二）为什么要使用-Markdown"><a href="#（二）为什么要使用-Markdown" class="headerlink" title="（二）为什么要使用 Markdown"></a>（二）为什么要使用 Markdown</h3><ul>
<li>格式清晰，读起来很舒服</li>
<li>语法简洁，编写时可以更<strong>专注于内容</strong>而非排版格式  </li>
<li><strong>纯文本</strong>形式，兼容所有的文本编辑器</li>
<li>可导出 HTML、PDF 等常见格式  </li>
</ul>
<h3 id="（三）如何使用-Markdown"><a href="#（三）如何使用-Markdown" class="headerlink" title="（三）如何使用 Markdown"></a>（三）如何使用 Markdown</h3><p>Markdown 的语法非常简单，主要包含以下几个部分：<strong>标题</strong>，<strong>段落</strong>，<strong>列表</strong>，<strong>强调</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>行内代码</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>自动链接</strong>，<strong>图片</strong>，<strong>反斜杠</strong>，<strong>表格（扩展）</strong>。</p>
<h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h4><p>标题有两种形式，一种形式为在文字下方添加 <code>=====</code> 或 <code>-----</code>，分别表示一级标题和二级标题，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=====</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">-----</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p>另一种形式在标题前添加 <code>#</code>，添加一个 <code>#</code> 为一级标题，两个为二级标题，最多可至六级标题，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<p>效果为</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h4 id="2-段落"><a href="#2-段落" class="headerlink" title="2. 段落"></a>2. 段落</h4><p>一个 Markdown 段落是由一个或多个连续的文本行组成，<strong>段落前后要有一个以上没有文字的空行</strong>。使用 <strong>两个以上的空格加回车</strong> 可强制在 <strong>段落内换行</strong>。</p>
<p>段落的开头 <strong>不应该使用空格或者制表符（Tab）缩进</strong>。</p>
<h4 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h4><p>Markdown 支持无序列表和有序列表。无序列表使用<strong>星号<code>*</code>、加号<code>+</code>或减号<code>-</code>加至少一个空格或制表符（Tab）</strong>作为列表标记，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>有序列表使用 <strong>数字加点 <code>.</code> 再加至少一个空格或制表符</strong> 作为列表标记，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项</span><br><span class="line"><span class="bullet">2. </span>第二项</span><br><span class="line"><span class="bullet">3. </span>第三项</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h4 id="4-强调"><a href="#4-强调" class="headerlink" title="4. 强调"></a>4. 强调</h4><p>内容前后加上 <strong>星号 <code>*</code> 或 下划线<code>_</code></strong> 表示 <strong>强调</strong>。前后加一个星号或下划线为 <em>斜体</em>，两个为 <strong>粗体</strong>，三个为 <strong><em>粗斜体</em></strong>。如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*强调*</span></span><br><span class="line"><span class="strong">**强调**</span></span><br><span class="line"><span class="strong">***强调**</span>*</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<p><em>强调</em></p>
<p><strong>强调</strong></p>
<p><strong><em>强调</em></strong></p>
<h4 id="5-区块引用"><a href="#5-区块引用" class="headerlink" title="5. 区块引用"></a>5. 区块引用</h4><p>在段落的 <strong>第一行或每行开头</strong> 使用 <code>&gt;</code> 表示引用，多个 <code>&gt;</code> 表示嵌套，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用</span></span><br><span class="line">&gt;&gt; 嵌套引用</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<blockquote>
<p>区块引用</p>
<blockquote>
<p>嵌套引用</p>
</blockquote>
</blockquote>
<h4 id="6-代码区块"><a href="#6-代码区块" class="headerlink" title="6. 代码区块"></a>6. 代码区块</h4><p>代码区块可以按如下格式输入</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```java</span></span><br><span class="line"><span class="code">public static void main(string[] args) &#123;</span></span><br><span class="line"><span class="code">	System.out.println("Hello, world");</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">​</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">效果为</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(string[] args) &#123;</span><br><span class="line">	System.out.println(&quot;Hello, world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-行内代码"><a href="#7-行内代码" class="headerlink" title="7. 行内代码"></a>7. 行内代码</h4><p>前后含 <strong>反引号( ` )</strong> 的内容为行内代码，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`System.out.println("Hello, world")`</span> 表示输出"Hello, world"。</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<p><code>System.out.println(&quot;Hello, world&quot;)</code> 表示输出”Hello, world”。</p>
<h4 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h4><p>三个或三个以上的星号 <code>*</code>、减号 <code>-</code>及下划线 <code>_</code>表示 <strong>分割线</strong>，中间可插入空格，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="bullet">- </span>- -</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<hr>
<hr>
<h4 id="9-链接"><a href="#9-链接" class="headerlink" title="9. 链接"></a>9. 链接</h4><p>Markdown 支持两种形式的链接，<strong>行内式</strong> 和 <strong>参考式</strong>。<br><strong>行内式</strong> 的链接文字用中括号 <code>[]</code> 标记，方括号后紧接小括号 <code>()</code> 标记网址链接，可在网址链接后用引号标记链接的 title 文字，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">GitHub</span>](<span class="link">https://github.com/ "Github"</span>)</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<p><a href="https://github.com/" title="GitHub" target="_blank" rel="noopener">GitHub</a></p>
<p><strong>参考式</strong> 的链接文字同样使用中括号 <code>[]</code> 标记，后面再接一个中括号标记链接的标识，需要在文件的任意处通过 <code>[id]:url &quot;title&quot;</code> 标记链接，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">GitHub</span>][<span class="symbol">1</span>]  </span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">https://github.com/ "GitHub"</span></span><br></pre></td></tr></table></figure>
<p>效果为</p>
<p><a href="https://github.com/" title="GitHub" target="_blank" rel="noopener">GitHub</a>  </p>
<h4 id="10-自动链接"><a href="#10-自动链接" class="headerlink" title="10. 自动链接"></a>10. 自动链接</h4><p>Markdown 支持以 <strong>简短的自动链接</strong> 形式处理网址和电子邮箱，用尖括号 <code>&lt;&gt;</code> 标记，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;https://github.com&gt;</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<p><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p>
<h4 id="11-图片"><a href="#11-图片" class="headerlink" title="11. 图片"></a>11. 图片</h4><p>Markdown 中标记图片的方式与标记链接类似，同样允许 <strong>行内式</strong> 和 <strong>参考式</strong> 两种形式，只需在链接文字的标记前加一个感叹号 <code>!</code>，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">GitHub Icon</span>](<span class="link">https://github.com/fluidicon.png "GitHub Icon"</span>)</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<blockquote>
<p><img src="https://github.com/fluidicon.png" alt="GitHub Icon" title="GitHub Icon"></p>
</blockquote>
<p><strong><em>遗憾的是 Markdown 不支持指定图片的宽高</em></strong></p>
<h4 id="12-反斜杠"><a href="#12-反斜杠" class="headerlink" title="12. 反斜杠"></a>12. 反斜杠</h4><p>通过反斜杠 <code>\</code> 可插入一些在 Markdown 语法中有其他意义的符号，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="emphasis">*前后为星号\*</span></span><br></pre></td></tr></table></figure>
<p>效果为</p>
<p>*前后为星号*</p>
<p>Markdown 支持在以下符号前加反斜杠 <code>\</code> 来帮助插入普通的符号：</p>
<pre><code>\    反斜杠   
`    反引号
*    星号
_    下划线
{}    大括号
[]    中括号
()    小括号
#    井号
+    加好
-    减号
.    英文句号
!    感叹号
</code></pre><h4 id="13-表格-扩展"><a href="#13-表格-扩展" class="headerlink" title="13. 表格(扩展)"></a>13. 表格(扩展)</h4><p>表格为 <strong>扩展</strong> 的 Markdown 语法，<code>|</code> 表示纵向的边界，表头和内容之间用 <strong>三个或三个以上减号 <code>-</code> 隔开</strong>，可以使用冒号 <code>:</code> 设置 <strong>对齐方式</strong>。冒号 <code>:</code> 在左边表示左对齐，在右边表示右对齐，两边都有冒号 <code>:</code> 表示居中，不使用冒号 <code>:</code> 时默认 <strong>左对齐</strong>，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| name | gender | age |</span><br><span class="line">| :---: | :---: | :---: |</span><br><span class="line">| Jack | boy | 4 |</span><br><span class="line">| Amy | girl | 5 |</span><br></pre></td></tr></table></figure>
<p>效果为</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">gender</th>
<th style="text-align:center">age</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Jack</td>
<td style="text-align:center">boy</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">Amy</td>
<td style="text-align:center">girl</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<h3 id="（四）Markdown-编辑器"><a href="#（四）Markdown-编辑器" class="headerlink" title="（四）Markdown 编辑器"></a>（四）Markdown 编辑器</h3><p>Mac 下好用的 Markdown 编辑器有很多，如 <a href="http://macdown.uranusjr.com/" target="_blank" rel="noopener">MacDown</a>，<a href="http://25.io/mou/" target="_blank" rel="noopener">Mou</a>，<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> 等。</p>
<p>Windows 下可以使用 <a href="http://www.markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a>，<a href="https://maxiang.io/" target="_blank" rel="noopener">马克飞象</a>，<a href="https://note.youdao.com/" target="_blank" rel="noopener">有道云笔记</a> 等。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 5.7 二进制软件包安装方法</title>
    <url>/2018/10/17/MySQL-5-7-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>MySQL 5.7 是目前最成熟的版本，性能较 5.6 有非常大的提升，又因为在官方软件包中所有的功能已经配置完毕，使用起来非常方便，所以本篇文章介绍 MySQL 5.7 版本的二进制软件包安装方法，步骤如下。</p>
<a id="more"></a>
<h3 id="1-下载并解压软件包"><a href="#1-下载并解压软件包" class="headerlink" title="1. 下载并解压软件包"></a>1. 下载并解压软件包</h3><p>进入 <a href="https://www.mysql.com" target="_blank" rel="noopener">MySQL官网</a> ，选择 MySQL Community Server 进入软件包下载页面，下载文件如 mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz，放入 <code>/usr/local/</code> 。</p>
<p>对下载的软件包进行 MD5 校验，<code>md5sum mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz</code> ，确保下载过程没有问题。</p>
<p>使用 tar 命令解压软件包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> tar -zxvf mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<p>可以创建软链接方便使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ln -s mysql-5.7.23-linux-glibc2.12-x86_64 mysql</span><br></pre></td></tr></table></figure>
<h3 id="2-创建-mysql-用户"><a href="#2-创建-mysql-用户" class="headerlink" title="2. 创建 mysql 用户"></a>2. 创建 mysql 用户</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> groupadd mysql</span><br><span class="line"><span class="meta">$</span> useradd -g mysql mysql -s /sbin/nologin</span><br></pre></td></tr></table></figure>
<h3 id="3-初始化数据库"><a href="#3-初始化数据库" class="headerlink" title="3. 初始化数据库"></a>3. 初始化数据库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqld --user=mysql --initialize</span><br></pre></td></tr></table></figure>
<p>使用以上命令初始化数据库，注意命令行打印出的包含临时密码的日志，如 <code>[Note] A temporary password is generated for root@localhost: M4s+iJ/lLUdS</code> 。</p>
<blockquote>
<p>MySQL 从 5.7.18 开始不在二进制包中提供 my-default.cnf 文件，不需要 /etc/my.cnf 配置文件也能正常运行。</p>
</blockquote>
<h3 id="4-启动-MySQL"><a href="#4-启动-MySQL" class="headerlink" title="4. 启动 MySQL"></a>4. 启动 MySQL</h3><p>通过 mysqld_safe 命令启动 MySQL，可以通过 ps 命令查看是否启动成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqld_safe &amp;</span><br><span class="line"><span class="meta">$</span> ps -ef | grep mysql</span><br></pre></td></tr></table></figure>
<h3 id="5-修改-root-密码，创建非-root-账号"><a href="#5-修改-root-密码，创建非-root-账号" class="headerlink" title="5. 修改 root 密码，创建非 root 账号"></a>5. 修改 root 密码，创建非 root 账号</h3><p>使用 mysql 命令通过初始密码登录数据库，修改 root 账号密码，创建新的非 root 账号，并通过 flush privileges 更新权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysql -pM4s+iJ/lLUdS</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD = &apos;xxx&apos;;</span><br><span class="line">mysql&gt; ALTER USER root@localhost PASSWORD EXPIRE NEVER;</span><br><span class="line">mysql&gt; CREATE USER jiangyue@&apos;%&apos; IDENTIFIED BY &apos;xxx&apos;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO jiangyue@&apos;%&apos; identified by &apos;xxx&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="6-关闭-MySQL"><a href="#6-关闭-MySQL" class="headerlink" title="6. 关闭 MySQL"></a>6. 关闭 MySQL</h3><p>正常关闭 MySQL 使用如下命令，非正常关闭需要 kill 掉 MySQL 进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqladmin -uroot -pxxx shutdown</span><br></pre></td></tr></table></figure>
<h3 id="root-密码遗失解决方法"><a href="#root-密码遗失解决方法" class="headerlink" title="* root 密码遗失解决方法"></a>* root 密码遗失解决方法</h3><p>强制关闭数据库，通过加 <strong>跳过权限表</strong> 参数重启数据库并进入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ps -ef | grep mysql</span><br><span class="line"><span class="meta">$</span> kill -9 22975 22917</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqld_safe --skip-grant-tables &amp;</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysql</span><br></pre></td></tr></table></figure>
<p>选择 mysql 数据库，给 root 用户设置新的密码并刷新权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; UPDATE user SET authentiation_string = password(&apos;xxx&apos;) where user = &apos;root&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<p>修改密码后去掉 –skip-grant-tables 参数重启数据库。</p>
<h3 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="* 用户权限管理"></a>* 用户权限管理</h3><p>通常超级权限的用户（root 和 all privileges 权限用户）只能归 DBA 管理，创建用户时最好保证专库专账号。创建用户、分配权限、刷新权限的语法如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER username@host IDENTIFIED BY 'password';</span><br><span class="line">mysql&gt; GRANT CREATE, ALTER, SELECT, INSERT, UPDATE, DELETE ON DB.table TO username@host IDENTIFIED BY 'password';</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<p>其中 host 可以指定具体 IP，也可以指定 IP 网段，如 <code>192.168.1.%</code> 。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 事务</title>
    <url>/2018/12/19/MySQL-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务是一组 DML（insert、delete、update）语句的集合，一个事务中的语句要么全部执行要么全部不执行。</p>
<blockquote>
<p>SQL 语句分为四类：数据查询语言 DQL（select），数据操纵语言 DML（insert、delete、update），数据定义语言DDL（create）和数据控制语言 DCL（grant、rollback、commit）。</p>
</blockquote>
<p>MySQL 中 InnoDB 支持事务而 MyISAM 不支持，事务默认自动提交，即除非显式地开始一个事务，否则每个 DML 语句都被当做一个单独的事务自动执行。</p>
<p>显示开启事务以 begin 命令开始，以 commit 或 rollback 命令结束。</p>
<a id="more"></a>
<h2 id="事务特性-ACID"><a href="#事务特性-ACID" class="headerlink" title="事务特性 ACID"></a>事务特性 ACID</h2><ul>
<li>原子性（Atomicity）</li>
</ul>
<p>原则性指事务中包含的所有操作，要么都做，要不都不做，不会出现一部分生效而另一部分未生效的情况。</p>
<ul>
<li>一致性（Consistency）</li>
</ul>
<p>一致性指数据在事务处理前后都满足业务规则的约束，数据状态均合法，不会违背任何的数据完整性。</p>
<blockquote>
<p>ACID 中的一致性和分布式系统 CAP（一致性、可用性和分区容忍性） 中的一致性意义不同，CAP 中的一致性指同一数据在每一个节点上有相同的拷贝。</p>
</blockquote>
<ul>
<li>隔离性（Isolation）</li>
</ul>
<p>隔离性指允许多个并发事务同时对数据进行修改，保证并行事务处理能够互不干扰。</p>
<ul>
<li>持久性（Durability）</li>
</ul>
<p>持久性指事务处理结束后对数据的修改是永久的，即使系统故障也不会丢失。</p>
<h2 id="事务执行过程"><a href="#事务执行过程" class="headerlink" title="事务执行过程"></a>事务执行过程</h2><p>自动提交开启，即 autocommit = ON 时，如果通过 begin 或 start transaction 命令显式开启事务，结束时需要通过 commit 提交事务，或通过 rollback 回滚事务。如果不显式地开启事务，则每个 DML 语句都被当做一个单独的事务自动执行。</p>
<p>自动提交关闭，即 autocommit = OFF 时，事务在对数据进行操作时自动开启，结束事务同样需执行 commit 提交或执行 rollback 回滚。</p>
<p>『自动提交开启且显式开启事务』，或『自动提交关闭』，如果没有显式地结束事务，则事务会在提交 DDL 语句或再次输入 begin（start transaction）时隐式提交（session 级别），在退出会话、连接超时或关机等情况隐式回滚。</p>
<h2 id="truncate-和-delete"><a href="#truncate-和-delete" class="headerlink" title="truncate 和 delete"></a>truncate 和 delete</h2><p>truncate 和 delete 语句都可以清空表内数据，区别是 truncate 是 DDL 语句、在事务中不能回滚且会重置当前自增值，而 delete 是 DML 语句、可以回滚。</p>
<p>不再需要表时用 drop，仍要保留表但删除所有记录时用 truncate，要删除部分记录时用 delete。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL InnoDB 存储引擎实现了 SQL 标准的 4 中隔离级别，用于限定事务内外数据改变时的可见性。低隔离级别支持更高的并发，系统开销低，但可能出现脏读、幻读等现象。</p>
<ul>
<li>读未提交 （RU，read uncommitted），指在一个事务中可以读取到其他事务未提交的数据变化，容易出现脏读，不建议在生产环境中使用。</li>
<li>读已提交（RC，read committed），指在一个事务中可以读到其他事务已经提交的数据变化，也叫作不可重复读，允许幻读发生，是 Oracle 数据库的默认事务隔离级别。</li>
<li>可重复读（RR，repetable read），指事务从开始到结束的过程中允许反复读取数据，且读到的数据均为事务刚开始时看到的数据，避免了脏读、不可重复读和幻读，是 MySQL 默认的事务隔离级别。</li>
<li>串行（serializable），每次读操作都要加表级共享锁，每次写操作都要加表级排他锁。串行会降低 InnoDB 的并发能力，不建议在生产环境中使用。</li>
</ul>
<blockquote>
<p>脏读：事务 A 中读取到事务 B 中未提交修改的数据，事务 B 回滚，A 读到的就是脏数据。</p>
<p>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中修改或删除数据并提交，导致事务 A 多次读取同一数据结果不一致。</p>
<p>幻读：在一个事务中读取到了其他事务新增的数据。</p>
<p>不可重复读针对 update 和 delete，幻读针对 insert。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 主从复制</title>
    <url>/2019/01/03/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>主从复制也称为主从同步，将一台主机的数据复制到另一台或多台主机上，通过中继日志 relay log 来实现复制功能，是构建数据库高可用集群架构的基础。</p>
<p>复制过程中一台服务器充当主库 master，其余一个或多个服务器充当从库 slave。</p>
<a id="more"></a>
<h2 id="主从复制功能"><a href="#主从复制功能" class="headerlink" title="主从复制功能"></a>主从复制功能</h2><p>主从复制有如下功能：</p>
<ul>
<li>实时备灾，从库随时接管有故障的主库</li>
<li>从库分担主库的读压力，读写分离</li>
<li>利用从库做备份，减少对业务的影响</li>
<li>利用从库完成 MySQL 平滑的版本升级</li>
</ul>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>主库把 SQL 请求记录到 binlog 日志中，从库的 IO thread 向主库请求 binlog 日志，主库通过 IO dump thread 传送 binlog，从库将得到的 binlog 写入中继日志 relay log，然后 SQL thread 通过中继日志重做 SQL 语句。</p>
<h2 id="复制中的重要参数"><a href="#复制中的重要参数" class="headerlink" title="复制中的重要参数"></a>复制中的重要参数</h2><ul>
<li>log-bin 搭建主从复制必须开启 binlog</li>
<li>server-id 同一组主从架构中的唯一标识</li>
<li>server-uuid 由 MySQL 自动生成，每台机器不一样，在数据目录下的 auto.cnf 中</li>
<li>read-only 设置从库为只读状态（对 super 账号没有效果）</li>
<li>super-read-only 设置 super 账号是否开启只读状态</li>
<li>binlog-format 二进制日志格式，必须使用 row 模式（默认 row）</li>
<li>log_slave_updates 将源于主库的数据变更信息记录到从库 binlog 中</li>
<li>todo</li>
</ul>
<h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p>异步复制为 MySQL 默认的复制方式，主库写入 binlog 后即可成功返回给客户端，无须等待 binlog 传递给从库。</p>
<blockquote>
<p>异步复制的缺点是主库一旦发生宕机在高可用架构下做主备切换可能导致数据丢失。</p>
</blockquote>
<p>以下为基于 binlog 和 position 的方式（非 GTID）搭建一主一从架构的步骤：</p>
<ol>
<li>修改主库和从库的 server-id，确保两者不一致。</li>
<li>主库开启 binlog 功能（配置 log_bin）。</li>
<li>从库最好开启 log_slave_updates 参数，让从库写 binlog，方便扩展。</li>
<li>确保 binlog 格式为 row（默认为 row）。</li>
<li>在主库中创建主从复制账号。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create user &apos;bak&apos;@&apos;%&apos; identified by &apos;bak123&apos;;</span><br><span class="line">mysql&gt; grant replication slave on *.* to &apos;bak&apos;@&apos;%&apos;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>通过 mysqldump 导出主库数据。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqldump --single-transaction -uroot -pxxx --master-data=2 -A &gt; all.sql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–master-data=2 会在导出文件中记录当前使用的 binlog 文件及 position 号，并注释掉 change master 语句，change master 语句后续会手动执行。</p>
</blockquote>
<ol start="7">
<li>从库导入主库数据。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysql -uroot -pxxx &lt; all.sql</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>在从库执行配置主从的命令。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; change master to master_host=&apos;192.168.10.10&apos;,master_user=&apos;bak&apos;,master_password=&apos;bak123&apos;,master_port=3306,master_log_file=&apos;master-bin.000012&apos;,master_log_pos=1230;</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>执行开始主从复制的命令并查看复制状态，从库 IO thread 和 SQL thread 均为 Yes 表示已经开始复制工作。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br><span class="line">mysql&gt; show slave status;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另 stop slave 用于关闭主从复制，reset slave all 用于清空从库复制配置。</p>
</blockquote>
<h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>MySQL 5.5 之后引入半同步复制功能，开启后主库需确保从库接收完 binlog 并写入到 relay log 中才会通知等待线程操作完毕。如等待超时则关闭半同步复制，自动转为异步复制，直到至少有一台从库通知主库已经接收到 binlog 为止。</p>
<h3 id="半同步复制相关参数"><a href="#半同步复制相关参数" class="headerlink" title="半同步复制相关参数"></a>半同步复制相关参数</h3><ul>
<li>rpl_semi_sync_master_timeout</li>
</ul>
<p>关闭半同步复制的超时时间，单位毫秒，默认 10000，可以调整得很大来禁止切换异步复制，以提高复制安全性。</p>
<ul>
<li>rpl_semi_sync_master_wait_point</li>
</ul>
<p>用于控制半同步模式下事务的提交方式，包含 AFTER_COMMIT 和 AFTER_SYNC 两个值，AFTER_COMMIT 即将 binlog 传送给从库同时主库提交事务，AFTER_SYNC 即收到从库反馈后主库再提交事务。5.7 默认为 AFTER_SYNC，能够确保主库上提交的事务都已经同步给从库。</p>
<ul>
<li>rpl_semi_sync_master_wait_for_slave_count</li>
</ul>
<p>控制主库需等待接收写入成功反馈的从库个数，当从库故障时可以通过该参数剔除故障从库。</p>
<h3 id="半同步复制搭建过程"><a href="#半同步复制搭建过程" class="headerlink" title="半同步复制搭建过程"></a>半同步复制搭建过程</h3><p>半同步复制的搭建基于异步复制，搭建完异步复制后只需安装半同步复制插件即可，以下为详细步骤：</p>
<ol>
<li>主库安装半同步复制插件并开启半同步复制功能。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; install plugin rpl_semi_sync_master soname &apos;semisync_master.so&apos;;</span><br><span class="line">mysql&gt; set global rpl_semi_sync_master_enabled=on;</span><br><span class="line">mysql&gt; show variables like &apos;%semi%&apos;;</span><br><span class="line">mysql&gt; show plugins;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从库安装半同步复制插件并开启半同步复制功能。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; install plugin rpl_semi_sync_slave soname &apos;semisync_slave.so&apos;;</span><br><span class="line">mysql&gt; set global rpl_semi_sync_slave_enabled=on;</span><br><span class="line">mysql&gt; show variables like &apos;%semi%&apos;;</span><br><span class="line">mysql&gt; show plugins;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了开机启动半同步复制功能，可以在主库和从库的配置文件 my.cnf 中分别配置 rpl_semi_sync_master_enabled=on 和 rpl_semi_sync_slave_enabled=on。</p>
</blockquote>
<ol start="3">
<li>重启从库 IO 线程并检查主库和从库的。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 从库重启 IO 线程</span><br><span class="line">mysql&gt; stop slave io_thread;</span><br><span class="line">mysql&gt; start slave io_thread;</span><br><span class="line"></span><br><span class="line">## 检查主库半同步复制状态，注意 Rpl_semi_sync_master_status 和 Rpl_semi_sync_master_clients</span><br><span class="line">mysql&gt; show global status like &apos;%semi%&apos;;</span><br><span class="line"></span><br><span class="line">## 检查从库半同步复制状态，注意 Rpl_semi_sync_slave_status</span><br><span class="line">mysql&gt; show global status like &apos;%semi%&apos;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过 <code>show global status like &#39;%semi%&#39;</code> 来查看主库接收从库事务回复的成功失败次数，分别为 Rpl_semi_sync_master_yes_tx 和 Rpl_semi_sync_master_no_tx。</p>
</blockquote>
<p>至此 MySQL 半同步复制搭建成功。</p>
<h3 id="半同步复制和异步复制切换"><a href="#半同步复制和异步复制切换" class="headerlink" title="半同步复制和异步复制切换"></a>半同步复制和异步复制切换</h3><p>半同步复制状态下，如等待超时则关闭半同步复制，自动转为异步复制，当主库接收到来自从库的 binlog 反馈后会重新转为半同步复制。</p>
<p>比如在半同步复制状态下关闭从库，在主库中写入数据，写入数据的 SQL 会等待至半同步超时然后返回，此时通过 <code>show global status like &#39;%semi%&#39;</code> 可以看到主库已经关闭了半同步复制。</p>
<p>重新启动从库，如果从库配置了 <code>rpl_semi_sync_slave_enabled=on</code> ，则启动后主库从库自动转为半同步复制模式，否则会依然处于异步复制模式，需手动开启从库半同步复制然后重启从库 IO 线程才会转为半同步复制。</p>
<h2 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h2><p>MySQL 5.6 开始支持基于库级别的并行复制，及 slave_parallel_type=database。MySQL 5.7 中实现了基于组提交的并行复制，即从库可以通过多个 workers 线程并发执行 relay log 中的事务。</p>
<p>要开启基于组提交的并行复制，需要设置 slave_parallel_workers &gt; 0，一般设置为 8 或 16，并将 slave_parallel_type 设置为 LOGICAL_CLOCK。</p>
<p>并行复制可以有效降低主从延迟，其他可以降低主从延迟的方法有采用 Percona 的 percona-xtradb-cluster (PXC) 架构多节点写入，选择合适的分库分表策略，避免无效 IO，使用高速磁盘，适当调整 buffer pool 大小等。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 体系结构与存储引擎</title>
    <url>/2018/10/18/MySQL-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>了解 MySQL 的体系结构可以帮助我们更好的学习 MySQL，本篇文章对 MySQL 体系结构进行了简要介绍，同时对 InnoDB 存储引擎的工作方式进行了说明。</p>
<a id="more"></a>
<h2 id="MySQL-体系结构"><a href="#MySQL-体系结构" class="headerlink" title="MySQL 体系结构"></a>MySQL 体系结构</h2><p>MySQL 的体系结构可以分为两层：MySQL Server 层和存储引擎层。MySQL Server 层又包括连接层和 SQL 层。</p>
<p>应用程序通过接口连接 MySQL，最先到达连接层，经过通信协议处理、线程处理和用户名密码认证三个部分。</p>
<p>SQL 层包括权限判断、查询缓存、解析器、预处理、查询优化器、缓存和执行计划。</p>
<p>其中查询缓存通过 Query Cache 进行操作，解析器判断语法是否正确，预处理器对解析器无法解析的语义进行处理，优化器对 SQL 进行改写优化，生成最优的执行计划，然后调用 API，通过存储引擎层访问数据。</p>
<h2 id="Query-Cache"><a href="#Query-Cache" class="headerlink" title="Query Cache"></a>Query Cache</h2><p>一个 SQL 如果以 select 开头，那么 MySQL 将尝试对其使用 Query Cache 。每个 Cache 都以 SQL 文本作为 key 来存储。</p>
<p>Query Cache 只能缓存静态数据，如果一个表被更新，和这个表相关 SQL 的所有 Query Cache 都会失效。</p>
<p>Query Cache 在 5.6 之前的版本中默认是开启的，5.6 之后默认是关闭的。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL 及其分支版本主要的存储引擎包括：InnoDB、MyISAM、Memory、Blackhole、TokuDB 和 MariaDB columnstore。</p>
<p>InnoDB 支持事务、行锁，支持 MVCC（Multi-Version Concurrency Control）多版本并发控制，并发性高。</p>
<p>MyISAM 不支持事务，支持表锁，低并发，资源利用率也很低，在 MySQL 8.0 被废弃。</p>
<p>Memory 将表中数据都存在内存中，支持 Hash 和 Btree 索引，安全性不高，读取速度快。</p>
<p>TokuDB 支持事务、压缩功能、高速写入功能、Online DDL，不产生索引碎片。</p>
<p>MariaDB columnstore 列式存储引擎，支持高压缩功能。</p>
<p>Blackhole 并不存储数据，数据写入时只写 binlog，仓用来做 binlog 转储或测试。</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>InnoDB 逻辑存储单元分为表空间 tablespace、段 segment、区 extent 和页 page。</p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>InnoDB 引擎下表中的所有数据都存储在表空间中，表空间分为系统表空间和独立表空间。</p>
<p>系统表空间以 ibdata1 命名，存储所有的数据及回滚（undo）信息，数据库初始化时系统就创建了一个系统表空间文件。MySQL 5.6 后 undo 表空间可以通过参数设置将存储位置独立出来。</p>
<p>独立表空间即每个表有自己的表空间文件，存储对应表的 B+树数据、索引和插入缓冲等信息，其余信息仍然存储在系统表空间中。</p>
<p>独立表空间在效率、性能方面会由于系统表空间，MySQL 默认使用的就是独立表空间。</p>
<blockquote>
<p>MySQL 5.7 新增了临时表空间和通用表空间。</p>
<p>临时表空间从系统表空间中抽离，形成独立表空间；通用表空间将多个表放在同一个表空间，根据活跃度来划分表，存在不同的磁盘上，目的是减少 metadata 存储开销，生产环境很少使用。</p>
</blockquote>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间由段组成，通常包括数据段、回滚段、索引段等，每个段由 N 个区和 32 个零散的页组成，以区为单位进行扩展。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区由连续的 64 个页组成，是物理上连续的空间，每个区固定 1 MB（64 * 16 KB）。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>InnoDB 最小的物理存储分配单位，有数据页和回滚页等，默认为 16 KB。</p>
<p>MySQL 5.6 开始允许自定义调低 page 大小，可以调整为 8 KB 或 4 KB；MySQL 5.7 开始允许调高 page 大小，可以调整到 32 KB 或 64 KB。</p>
<p>一般情况下一个 page 页会预留 1/16 的空间用于更新数据，真正使用 15/16 的空间。</p>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB 引擎下数据按行存储，行按照一定的格式记录数据。</p>
<p>InnoDB 包含两种行存储文件格式，其中 Antelope 文件格式下有 compact 和 redundant 两种行记录格式，Barracuda 文件格式下有 compressed 和 dynamic 两种行记录格式。</p>
<p>目前使用最多的是 compact 行记录格式，MySQL 5.7 默认使用 dynamic 行记录格式，针对溢出列所在的新页利用率更高。</p>
<p>而 redundant 是最早的行记录格式，比 compact 消耗更多的存储空间；compressed 对数据和索引页进行压缩，但只在物理层面压缩，带来负面影响也很大。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>MySQL 内存组成分为 SGA 系统全局区和 PGA 程序全局区。</p>
<h4 id="SGA-系统全局区"><a href="#SGA-系统全局区" class="headerlink" title="SGA 系统全局区"></a>SGA 系统全局区</h4><p>系统全局区包含以下内存区域：</p>
<p>innodb_buffer_pool，缓存 InnoDB 表的数据、索引、插入缓存、数据字典等信息。</p>
<p>innodb_log_buffer，事务在内存中的缓冲。</p>
<blockquote>
<p>Query Cache，查询缓存，建议关闭。</p>
<p>key_buffer，只用于 MyISAM 表的索引。</p>
<p>innodb_additional_mem_pool，保存数据字典和其他内部数据结构的内存池，MySQL 5.7.4 中被移除。</p>
</blockquote>
<h4 id="PGA-程序全局区"><a href="#PGA-程序全局区" class="headerlink" title="PGA 程序全局区"></a>PGA 程序全局区</h4><p>程序全局区包含以下内存区域：</p>
<p>sort_buffer，用于 SQL 语句在内存中临时排序。</p>
<p>join_buffer，表连接使用，用于 BKA （Batched Key Access  提高表 join 性能的算法）。</p>
<p>read_rnd_buffer，MySQL 随机读缓冲，用于做 mmr（Multi-Range Read，MySQL 5.6 优化器的新特性）。</p>
<blockquote>
<p>read_buffer，表顺序扫描的缓存，只用于 MyISAM。</p>
<p>tmp_table SQL语句在排序或分组时没有用到索引时使用的临时表空间。</p>
<p>max_heap_table，管理 heap、memory 存储引擎表。</p>
</blockquote>
<h3 id="Buffer-状态"><a href="#Buffer-状态" class="headerlink" title="Buffer 状态"></a>Buffer 状态</h3><p>InnoDB 最小的磁盘 IO 单位是 page，对应到内存的 buffer。</p>
<p>buffer 分为 free、clean、dirty 三种状态，free 为从未被使用，clean 为数据和磁盘 page 一致，dirty 为数据和磁盘 page 不一致（待刷新到磁盘）。</p>
<p>buffer 在内存中通过 chain 链来管理，三种状态衍生出 3 条链表，free list、lru list 和 flush list。lru list 将 clean buffer 按最近最少使用串联起来，flush list 串联 dirty buffer，也隐藏 lru 规则。</p>
<p>数据库运行时，首先判断 free list 的使用情况，如果不够用，会从 lru 和 flush list 中释放 free buffer。</p>
<h3 id="刷新线程"><a href="#刷新线程" class="headerlink" title="刷新线程"></a>刷新线程</h3><p>InnoDB 为多线程模型，后台有多种线程负责不同的任务。</p>
<h4 id="master-thread"><a href="#master-thread" class="headerlink" title="master thread"></a>master thread</h4><p>主线程，优先级最高，内部包含 4 个循环：主循环 loop、后台循环 background loop、刷新循环 flush loop 和暂停循环 suspend loop。各循环根据数据状态进行切换。</p>
<h4 id="IO-thread"><a href="#IO-thread" class="headerlink" title="IO thread"></a>IO thread</h4><p>IO 线程，包括 redo log thread、change buffer thread 和 read / write thread。</p>
<p>redo log thread 负责将日志缓冲内容刷新到 redo log 文件，change buffer thread 负责将插入缓存内容刷新到磁盘，read / write thread 负责读写请求（默认 4 个，使用高转速磁盘可适当增大）。</p>
<h4 id="page-cleaner-thread"><a href="#page-cleaner-thread" class="headerlink" title="page cleaner thread"></a>page cleaner thread</h4><p>负责脏页刷新，MySQL 5.7 后可增加多个。</p>
<h4 id="purge-thread"><a href="#purge-thread" class="headerlink" title="purge thread"></a>purge thread</h4><p>负责删除无用的 undo 页。</p>
<h4 id="checkpoint-thread"><a href="#checkpoint-thread" class="headerlink" title="checkpoint thread"></a>checkpoint thread</h4><p>redo log 切换或文件快写满时，执行 checkpoint，触发脏页刷新到磁盘，并确保 redo log 刷新到磁盘，避免数据丢失。</p>
<blockquote>
<p>另外 error monitor thread 负责数据库报错监控，lock monitor thread 负责监控锁。</p>
</blockquote>
<h3 id="内存刷新机制"><a href="#内存刷新机制" class="headerlink" title="内存刷新机制"></a>内存刷新机制</h3><p>MySQL 和 Oracle 这种关系型数据库中，通常会先写日志再写数据文件。以下通过 redo log buffer 和 binlog cache 来介绍内存中的数据刷新到磁盘的机制。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log 又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，且不管事务是否提交都会记录。故障后通过 redo log 可以恢复到之前的状态，保证数据的完整性。</p>
<p>默认情况 redo log 至少有两个文件，在磁盘上以 ib_logfile{n} 命名（0 ~ n）。redo log 顺序写、循环写，在第一个文件写满后，执行 checkpoint，触发脏页刷新，然后写第二个文件，全部写满后从第一个文件开始重新写。MySQL 启动时会检查参数中 redo log 的大小，如果与当前 redo log 不一致，会删除 redo log，并按照配置重新生成文件。</p>
<p>redo log 数据先写在 redo log buffer 中，刷新到磁盘的策略通过 innodb_flush_log_at_trx_commit 来配置。</p>
<p>此配置值为 0 时，redo log thread 每隔 1 秒将 buffer 中的数据写入文件，同时刷盘保证写入成功。提交事务不会触发文件的写入。配置为 1 时，每次提交事务都会写入文件并刷盘，是最安全的模式，但性能最差。配置为 2 时，每次提交事务都会写入文件，但不会同时 flush 刷盘。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>binlog 即二进制日志文件，用于备份恢复和主从复制，通过 sync_binlog 参数来确定刷新策略。sync_binlog 的值为 0 时，有事务提交不会发出同步指令，而是让文件系统自行决定同步的时间，或 cache 满了之后才同步。sync_binlog 值为 n 时，每进行 n 次事务提交，MySQL 发出一次同步指令来将 cache 中的数据写入磁盘。</p>
<p>将 sync_binlog 和 innodb_flush_log_at_trx_commit 的值全配置为 1，即【双一模式】，可以最大限度保证数据库的安全性。</p>
<blockquote>
<p>redo log 和 binlog 的区别：</p>
<ul>
<li>记录内容不同，binlog 为逻辑日志，记录所有数据的改变信息，redo log 是物理日志，记录数据修改之后的值。</li>
<li>记录时间不同，binlog 在 commit 之后记录，redo log 在事务发起后记录。</li>
<li>文件使用方式不同，binlog 不循环使用，写满后生成新文件，redo log 循环使用。</li>
<li>作用不同，binlog 用于恢复数据、主从复制，redo log 用于异常宕机后的数据恢复。</li>
</ul>
</blockquote>
<h3 id="InnoDB-三大特性"><a href="#InnoDB-三大特性" class="headerlink" title="InnoDB 三大特性"></a>InnoDB 三大特性</h3><p>插入缓冲 change buffer、两次写 double write 和自适应哈希索引 adaptive hash index 构成 InnoDB 的三大特性，这些特性让 InnoDB 有了更好的性能和可靠性。</p>
<h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>IO 对数据库性能的影响最大，change buffer 将 DML 操作从随机 IO 变成了顺序 IO，提高 IO 效率。change buffer 先判断 DML 的普通索引页是否在缓冲池中，如果在就直接执行，否则就先放入 change buffer 中，进行索引合并，将多个 DML 合并到一个操作中。</p>
<h4 id="double-write"><a href="#double-write" class="headerlink" title="double write"></a>double write</h4><p>double write 保证写入的安全性。InnoDB 缓冲池中刷出的脏页在写入数据文件前，会先将脏页写入 double write buffer，然后分两次写入到共享表空间中，再将数据页写到数据文件中去。即使页损坏了，也可以通过副本还原出之前的页，再通过 redo log 进行恢复。</p>
<h4 id="adaptive-hash-index"><a href="#adaptive-hash-index" class="headerlink" title="adaptive hash index"></a>adaptive hash index</h4><p>InnoDB 可以监控索引的所有，如果发现查询可以通过建立索引得到优化，就会自动完成这件事，可以通过 innodb_adaptive_hash_index 参数来控制，默认为开启。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 数据库文件</title>
    <url>/2018/12/03/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>本篇文章介绍 MySQL 中各种类型的文件，包含配置文件 my.conf、错误日志 error.log、慢查询日志 slow log、全量日志 general log、二进制日志 binlog、审计日志 audit log、套接字文件 socket、进程文件 pid ，及存储引擎层面的 redo log 和 undo log。</p>
<a id="more"></a>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>通过命令 <code>mysql --help | grep my.cnf</code> 可以快速查找 MySQL 配置文件的路径。</p>
<p>MySQL 会按照 <code>/etc/my.cnf</code> -&gt; <code>/etc/mysql/my.cnf</code> -&gt;  <code>/usr/local/mysql/etc/my.cnf</code> -&gt;  <code>~/.my.cnf</code> 的顺序依次查找配置，如果多个配置文件中包含对某项的配置，以读取到最后一个配置文件中的参数值为准。如果想指定默认的配置文件，可以在启动时通过 –defaults-file 参数指定。</p>
<p>配置文件 my.cnf 中，针对客户端的配置写在 client section，针对服务端的配置写在 mysql section，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">wait_timeout = 300</span><br></pre></td></tr></table></figure>
<p>以下介绍一些核心参数，可以通过 <code>show variables like &#39;%param_name%&#39;</code> 来查看配置的参数。</p>
<ul>
<li>innodb_buffer_pool_size</li>
</ul>
<p>缓冲池大小，用于缓存被访问过的表和索引，提升处理速度，默认为 128M。如果服务器只跑数据库一个应用，可以设置为物理内存的 50 ~ 80%，从 MySQL 5.7 开始支持在线修改。</p>
<ul>
<li>innodb_buffer_pool_instance</li>
</ul>
<p>缓冲区划分的区域个数，默认为 1，MySQL 5.6.6 之后可以调整为多个，以提高并发性，仅在 innodb_buffer_pool_size 大于 1G 时生效。</p>
<ul>
<li>innodb_buffer_pool_load_at_startup 和 innodb_buffer_pool_dump_at_shutdown</li>
</ul>
<p>启动时加载缓冲池、关闭时 dump 缓冲池，默认为关闭，两个参数都开启可以在宕机后快速将热数据加载回来。</p>
<ul>
<li>innodb_data_file_path</li>
</ul>
<p>指定系统表空间文件的路径和 ibdata1 文件的大小，默认10M，遇到高并发事务时会有影响，可以调整为 1G。</p>
<ul>
<li>innodb_flush_log_at_trx_commit、sync_binlog 和 innodb_max_dirty_pages_pct</li>
</ul>
<p>innodb_flush_log_at_trx_commit 参数控制 redo log 写入策略：0 表示每个 1s 写入文件并刷盘，但每次事务提交不会触发写入；1 表示每次事务提交都写入并刷盘；2表示每次事务提交写入文件但不刷盘。</p>
<p>sync_binlog 参数控制 binlog 写入磁盘的策略：0 表示不出发任何同步磁盘指令，让文件系统自行决定，N 表示每 N 次事务发出一次同步指令。</p>
<p>innodb_max_dirty_pages_pct 控制脏页在 buffer pool 中的最大占比，到达上限后出发脏页刷新，默认为 75%，为了上产环境的 TPS 性能可以改为 25 ~ 50%。</p>
<ul>
<li>innodb_thread_concurrency</li>
</ul>
<p>InnoDB 内核最大并发线程数，默认为 0，表示不受限制。如果数据库压力过大，可以调整为服务器逻辑 CPU 核数的两倍，之后再慢慢增大。</p>
<ul>
<li>interactive_timeout、wait_timeout</li>
</ul>
<p>服务器关闭交互式和非交互式连接之前的最长等待时间，默认为 28800s（8h），建议调整为 300 ~ 600s。</p>
<ul>
<li>innodb_flush_method</li>
</ul>
<p>InnoDB 数据、redo log 的打开刷写模式，类 Unix 系统下默认为 fsync，如果使用高速 IO 设备，O_DIRECT 是更好的选择。</p>
<ul>
<li>innodb_old_blocks_time、innodb_old_blocks_pct</li>
</ul>
<p>InnoDB 缓冲池内部由 LRU 链表管理，分为 young pages list 和 old pages list，当未被访问时间超过 innodb_old_blocks_time 时被移入 old pages list，默认为 1000ms。</p>
<p>innodb_old_blocks_pct 指定 old pages list 占总体的百分比，默认为 37%，可以适当减小来保证更多的热数据不被冲掉。</p>
<ul>
<li>transaction_isolation</li>
</ul>
<p>事务隔离级别，可选值包括 READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ 和 SERIALIZABLE，默认为 REPEATABLE-READ（可重复读）。</p>
<ul>
<li>innodb_open_files</li>
</ul>
<p>InnoDB 可以同时打开的 .bd 文件个数，最小值为 10，默认 300，应该适量增大。</p>
<ul>
<li>innodb_log_buffer_size、innodb_log_file_size</li>
</ul>
<p>innodb_log_buffer_size 为日志缓冲大小，可以通过 <code>show global status like &#39;%Innodb_log_waits%&#39;</code> 查看等待日志刷新的次数，如果大于 0 且持续增长，就可以适当增大，默认为 16777216（16M），取值范围为 16 ~ 64M。</p>
<p>innodb_log_file_size 为 redo log 大小，过大会导致实例恢复时间长，过小会导致 redo log 频繁切换。</p>
<ul>
<li>innodb_log_files_in_group</li>
</ul>
<p>redo log 文件组中日志文件的数量，默认为 2。</p>
<ul>
<li>max_connections</li>
</ul>
<p>MySQL 最大连接数，默认为 151，对于并发连接很多的应用远远不够，应适当增大，同时注意数据库承受大量连接的压力。</p>
<ul>
<li>expire_logs_days</li>
</ul>
<p>binlog 过期时间，单位为天。</p>
<ul>
<li>slow_query_log</li>
</ul>
<p>慢查询日志开关，生产环境应该开启慢查询日志。</p>
<ul>
<li>long_query_time</li>
</ul>
<p>慢查询时间，如果 SQL 语句的执行时间超过该值就会记录到慢查询日志中，单位为秒。</p>
<ul>
<li>log_queries_not_using_indexex</li>
</ul>
<p>如果 SQL 没有用到索引，根据该配置决定是否记录到慢查询日志中。</p>
<ul>
<li>server-id</li>
</ul>
<p>搭建主从环境时同一主从结构中的唯一标识。</p>
<ul>
<li>binlog_format</li>
</ul>
<p>binlog 日志格式，有 statement、row 和 mixed 三种，生产环境使用 row 更安全，不会出现跨库复制丢数据的情况。</p>
<ul>
<li>lower_case_table_names</li>
</ul>
<p>表名是否区分大小写，默认为区分。</p>
<ul>
<li>innodb_fast_shutdown</li>
</ul>
<p>定义 InnoDB 引擎的表关闭时的行为，值可选 0、1 和 2，默认为 0。其中 0 表示需要执行 purge all、merge change buffer、flush dirty pages 操作，关闭最慢但重启最快；1 表示仅执行 flush dirty pages；2 表示上述操作都不会执行，仅将日志写入文件，重启时会执行 recovery 操作。</p>
<ul>
<li>innodb_status_output、innodb_status_output_locks</li>
</ul>
<p>将数据库监控信息写到 error log 的开关，默认关闭，如开启会导致错误日志增长过快。</p>
<ul>
<li>innodb_io_capacity</li>
</ul>
<p>影响刷新脏页和插入缓冲的数量，默认为 200，使用高速磁盘可以适当提高。</p>
<ul>
<li>auto_increment_increment、auto_increment_offset</li>
</ul>
<p>指定自增字段每次递增的量和开始的值。</p>
<h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><p>MySQL 中的参数分为动态参数和静态参数。动态参数可以通过 set global 或 set session 命令在线修改，效果分别为全局生效和只针对当前会话生效；静态参数在修改时会报 read only variable 错误，只能修改配置文件并重启数据库。</p>
<h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>错误日志一般在数据目录下，记录 MySQL 在启动、运行、关闭过程中出现的问题，另外还有一些警告信息。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog 和 redo log 同样记录对数据执行更改的操作，不会记录 select 和 show 这样的语句。</p>
<p>binlog 可以完成主从复制，主库将所有修改数据的操作记录到 binlog 中，通过网络发送给从库服务器，从而完成同步。</p>
<p>binlog 也可以进行数据恢复，使用 mysqlbinlog 命令可以实现基于时间点和位置的恢复操作。</p>
<p>在配置文件中使用 log_bin = [filename] 开启 binlog，默认存储在数据目录下，后缀为序列号。</p>
<blockquote>
<p>配置文件中开启 binlog 必须同时指定 server-id，否则会启动失败。</p>
</blockquote>
<h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><ul>
<li>max_binlog_size 单个 binlog 最大值，超过该值或重启会生成新的 binlog，默认为 1 GB。</li>
</ul>
<blockquote>
<p>生产环境一般控制 binlog 生成的最小间隔时间在 2 ~ 5 分钟，可以调整为 256 MB。</p>
</blockquote>
<ul>
<li>binlog_cache_size 未提交事务缓存大小，基于会话，默认为 32 KB。</li>
</ul>
<blockquote>
<p>设置过小会使用磁盘上的临时文件，可以通过 show global status 查看 binlog_cache_use 和 binlog_cache_disk_use 的使用情况判断参数是否合适。生产环境一般设置为 1 ~ 4 MB。</p>
</blockquote>
<ul>
<li>binlog_format 日志格式，可选值有 statement、row 和 mixed 三种，默认为 row。row 的优点是安全可靠，缺点是产生的日志量大。</li>
</ul>
<blockquote>
<p>使用 mysqlbinlog 工具可以导出转换格式后的二进制日志，<code>mysqlbinlog --no-defaults -v -v --base64-output=decode-rows binlog-file &gt; target-file</code> ，其中 –no-default 表示不从任何配置文件中读取配置，-v 表示显示具体的执行信息，两个 -v 可以显示列的数据类型及注释，–base64-output 指定转换格式。</p>
</blockquote>
<ul>
<li>sync_binlog，影响 binlog 磁盘刷新，前面提到过。</li>
<li>expire_logs_days，binlog 过期时间，单位天，可以设置长一点的时间。</li>
<li>binlog-do-db、binlog-ignore-db，指定需要写入和忽略日志的库，默认为空，写入所有库的日志。</li>
<li>log_slave_updates，在搭建 m -&gt; s1 -&gt; s2 这样的主从架构时，需要在 s1 配置为 1，才能实现 s1 到 s2 的同步。</li>
<li>binlog_checksum，指定 binlog 的校验算法，可选 none 和 crc32，默认 crc32。</li>
<li>binlog_row_image，binlog 记录策略，可选 full、minimal 和 noblob，分别表示全记录、只记录要修改的列和记录除 blob 和 text 以外的列，默认为 full。</li>
</ul>
<h2 id="slow-log"><a href="#slow-log" class="headerlink" title="slow log"></a>slow log</h2><p>慢查询日志会把超过 long_query_time 参数配置时间的所有 SQL 语句记录进来，long_query_time 默认 10 s。</p>
<p>可以使用 percona-toolkit 工具来分析慢查询日志。</p>
<h2 id="general-log"><a href="#general-log" class="headerlink" title="general log"></a>general log</h2><p>全量日志，记录全部 SQL 语句，包含 select 和 show，一般不会开启，默认关闭。个别情况可以临时开启，用于故障检测。</p>
<p>log_output 参数指定全量日志的存储方式，可取 FILE、TABLE 和 NONE。FILE 可以方便地按条件检索，指定为 NONE 即使全量日志开启也不会记录日志，TABLE 会在 MySQL 创建一个 general_log 表。建议使用 FILE。</p>
<h2 id="audit-log"><a href="#audit-log" class="headerlink" title="audit log"></a>audit log</h2><p>审计日志，能够实时记录网络上的数据库活动，进行细粒度审计的合规性管理，通过对数据库行为的记录、分析和汇报来生成报告、事故追根溯源。</p>
<p>购买 MySQL 企业版才可以使用审计功能，也可以使用第三方开源插件 libaudit_plugin.so 完成审计工具。</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>MySQL 有网络连接和本地连接两种连接方式，mysql.sock 文件是服务器和本地客户端通信的 UNIX 套接字文件，默认位置为 /tmp/mysql.sock。</p>
<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><p>进程文件，记录应用的进程号，默认在 MySQL 数据目录下。</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>记录事务操作变化，即数据被修改之后的值，用于异常宕机后的数据恢复。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>对记录的更新操作不仅会产生 redo 记录，也会产生 undo 记录，undo log 记录变更前的旧数据。默认记录在系统表空间 ibdata1 中，从 MySQL 5.6 开始可以使用独立 undo 表空间，避免将 ibdata1 文件弄大，也给部署不同 IO 类型的文件位置带来便利。</p>
<h3 id="相关参数-1"><a href="#相关参数-1" class="headerlink" title="相关参数"></a>相关参数</h3><ul>
<li>innodb_undo_directory，undo log 存储目录</li>
<li>innodb_undo_logs 回滚段数量，默认为 128，每个回滚段最多存放 1024 个事务。</li>
<li>innodb_undo_tablespaces 表示 undo tablespace 个数，默认为 0，最少为 2，保证在线 truncate 时至少有一个可用空间。</li>
<li>innodb_max_undo_log_size，最大 undo tablespace 文件大小，默认 1 GB，超过时触发 truncate，truncate 后恢复为 10 MB，通过 innodb_undo_log_truncate 配置来开启或关闭该特性，默认关闭，并且仅支持独立 undo 表空间。</li>
<li>innodb_purge_rseg_truncate_frequency，控制回收 undo log 频率，默认为 128，即 purge undo 轮询 128 次后进行一次 undo 的 truncate 操作。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 备份恢复</title>
    <url>/2019/01/02/MySQL-%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>MySQL 的备份方式按备份后的内容可分为全量备份和增量备份，按服务的运行状态可以分为冷备（停库）和热备（非停库），其中热备又可分为逻辑备份和裸文件备份。</p>
<a id="more"></a>
<h2 id="冷备及恢复"><a href="#冷备及恢复" class="headerlink" title="冷备及恢复"></a>冷备及恢复</h2><p>冷备即数据库关闭状态下的备份，数据完整、过程简单且恢复速度快，但会影响业务进行，一般用于非核心业务。</p>
<p>备份时首先停止 MySQL 服务，然后复制整个数据目录到远程备份机或本地，恢复时用已备份的数据目录替换原有的目录并重启 MySQL 服务。相关命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span># 关闭 MySQL</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqladmin -uroot -p&#123;password&#125; shutdown</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 上传数据目录至目标机器</span><br><span class="line"><span class="meta">$</span> scp -r &#123;data directory&#125; &#123;user&#125;@&#123;ip&#125;:&#123;target directory&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 启动 MySQL</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqld_safe &amp;</span><br></pre></td></tr></table></figure>
<h2 id="热备及恢复"><a href="#热备及恢复" class="headerlink" title="热备及恢复"></a>热备及恢复</h2><p>热备即数据库运行状态下的备份，不影响现有业务正常进行。</p>
<p>热备分为逻辑备份和裸文件备份，逻辑备份即备份 SQL 语句，恢复时执行备份 SQL，裸文件备份即在底层复制数据文件。</p>
<h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><p>逻辑备份可以通过 mysqldump、select … into outfile 及 mydumper 三种方式实现。</p>
<h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>mysqldump 为 MySQL 自带的命令工具，是最基础的备份工具。备份时先从 buffer 中找到需要备份的数据进行备份，如 buffer 中没有则将磁盘中的数据调入 buffer，然后进行备份，最后形成一个可编辑的备份文件。恢复数据时通过 mysql 命令工具进行。</p>
<p>可以通过 <code>/usr/local/mysql/bin/mysqldump --help</code> 查看使用说明，以下为一些核心参数：</p>
<ul>
<li>–single-transaction</li>
</ul>
<p>用于保证 InnoDB 一致性，配合 RR 隔离级别使用，直到备份结束，不会读取到本事务开始之后提交的数据。</p>
<ul>
<li>–all-database（-A）</li>
</ul>
<p>备份所有数据库。</p>
<ul>
<li>–master-data</li>
</ul>
<p>在备份出的文件中添加 change master 语句（用于主从复制），该参数包含 1 和 2 两个值，1 时 change master 语句正常，2 时会将 change master 语句注释掉。</p>
<ul>
<li>–dump-slave</li>
</ul>
<p>用于在搭建新从库，在库备份数据，1 时 change master 语句正常，2 时将 change master 语句注释掉。</p>
<ul>
<li>–no-create-info（-t）</li>
</ul>
<p>只备份表数据，不备份表结构。</p>
<ul>
<li>–no-data（-d）</li>
</ul>
<p>只备份表结构，不备份表数据。</p>
<ul>
<li>–complete-insert（-c）</li>
</ul>
<p>使用完整的 insert 语句，包含表中的列信息，可以提高插入效率。</p>
<ul>
<li>–database（-B）</li>
</ul>
<p>指定备份的数据库，如 <code>mysqldump -uroot -pxxx --database db1 db2</code> 。</p>
<ul>
<li>–where={condition}（-w）</li>
</ul>
<p>按条件备份数据。</p>
<p>使用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span># 备份全库</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqldump -uroot -p&#123;password&#125; -A &gt; all_20190102.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 恢复全库</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysql -uroot -p&#123;password&#125; &lt; all_20190102.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 备份db1数据库</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqldump -uroot -p&#123;password&#125; db1 &gt; db1_20190102.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 恢复db1数据库</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin.mysql -uroot -p&#123;password&#125; db1 &lt; db1_20190102.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 备份db1数据库中表t1</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqldump -uroot -p&#123;password&#125; db1 t1 &gt; t1_20190102.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 恢复db1数据库中表t1 (导入写库名即可)</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin.mysql -uroot -p&#123;password&#125; db1 &lt; t1_20190102.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 备份db1数据库表t1中id大于10的记录</span><br><span class="line"><span class="meta">$</span> /usr/local/mysql/bin/mysqldump -uroot -p&#123;password&#125; db1 t1 --where="id&gt;10" &gt; t.sql</span><br></pre></td></tr></table></figure>
<h4 id="select-…-into-outfile"><a href="#select-…-into-outfile" class="headerlink" title="select … into outfile"></a>select … into outfile</h4><p>select … into outfile 的恢复速度比 insert 插入要快，但只能备份数据，不能备份表结构。</p>
<p>通过 select … into outfile 备份时，先把备份的数据导出到一个文本文件中，然后通过 load data  方式恢复数据，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from &#123;table name&#125; into outfile &apos;&#123;target file&#125;&apos;;</span><br><span class="line">mysql&gt; load data infile &apos;&#123;target file&#125;&apos; into table &#123;table name&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如导出时报 The MySQL server is running with the –secure-file-priv option so it cannot execute this statement 错误，可以通过 <code>show variables like &#39;%secure%&#39;</code> 语句查看相关配置。</p>
<p><code>secure_file_priv = NULL</code> 表示不允许导出到文件，可以在配置文件 my.cnf 中 mysqld 模块下添加 <code>secure_file_priv =</code> ，表示允许导出到任意路径下的文件。</p>
</blockquote>
<h4 id="mydumper"><a href="#mydumper" class="headerlink" title="mydumper"></a>mydumper</h4><p>mydumper 是一个高性能多线程备份工具，备份速度远高于单线程的 mysqldump，数据还原时使用 myloader 工具。</p>
<p>mydumper 需额外安装，本篇文章不做详细介绍。</p>
<h3 id="裸文件备份"><a href="#裸文件备份" class="headerlink" title="裸文件备份"></a>裸文件备份</h3><p>裸文件备份在底层复制数据文件，比逻辑备份速度更快。</p>
<p>Percona 公司的开源项目 XtraBackup 能够对 InnoDB 数据库进行裸文件热备，速度快且安全可靠，备份过程不会锁表，不影响业务。本篇文章不对 XtraBackup 做详细介绍。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引</title>
    <url>/2018/12/17/MySQL-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息。索引就像书的目录，通过目录可以快速搜索到想要查找的内容。</p>
<p>MySQL 中索引可以分为 B+tree 索引和哈希索引，B+tree 索引又可以分为聚集索引和普通索引。</p>
<a id="more"></a>
<h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>InnoDB 存储引擎表是索引组织表，聚集索引是一种索引组织形式，索引键值的逻辑顺序决定表中数据行的物理存储顺序。聚集索引叶子节点存放表中所有行的数据，索引即数据。</p>
<p>创建表时，要显式地创建主键（聚集索引），如果不显式创建，InnoDB 会选择第一个不包含 null 值的唯一索引作为主键。如果唯一索引也没有的话，会默认生成一个 6 字节的 rowid 作为主键。</p>
<p>使用自增列做主键，可以保证写入数据顺序自增，进而很大程度提高存取效率。</p>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>普通索引在叶子节点不包含行的数据，只存自己本身的键值和主键的值，检索数据时通过普通索引叶子节点上的主键来获取想要的行记录。</p>
<p>以下为两种创建普通索引的语法及查看表中索引的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name ( 索引字段 );</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name ( 索引字段 );</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> index_name <span class="keyword">from</span> table_name；</span><br></pre></td></tr></table></figure>
<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><p>通过 explain 命令可以查看 SQL 的执行计划，如 <code>explain select * from t where name = &#39;AAA&#39;</code> 。</p>
<p>返回结果中 type 如果为 all 则表示全表扫描，key 为索引使用情况，rows 表示 SQL 执行过程中扫描的行数（估算值）。extra 列中如果有 using filesort 或 using temporary 关键字则会影响数据库性能。另外 MySQL 5.7 后执行计划会默认添加 filtered 列，表示返回结果占需要扫描行数的百分比。</p>
<h3 id="SQL-优化思路"><a href="#SQL-优化思路" class="headerlink" title="SQL 优化思路"></a>SQL 优化思路</h3><ol>
<li>检查表中各列的数据类型是否合理，遵循最小、最合适的原则。</li>
<li>检查表中碎片是否整理。</li>
<li>查看执行计划，检查索引的使用情况，没有用到索引则考虑创建。</li>
<li>创建索引前需要依据选择性来判断字段是否适合创建索引。</li>
</ol>
<blockquote>
<p>选择性指不重复的索引值与数据表记录总数的比值，选择性越高查找时过滤掉的行就更多，查询效率也就越高。</p>
<p>一般经常被查询的列、经常用于表连接的列和经常用于排序分组的列可以考虑建索引。</p>
</blockquote>
<ol start="5">
<li>创建索引后再吃查看执行计划，对比两次结果查看效率是否提高。</li>
</ol>
<h2 id="ICP、MRR-和-BKA"><a href="#ICP、MRR-和-BKA" class="headerlink" title="ICP、MRR 和 BKA"></a>ICP、MRR 和 BKA</h2><p>ICP 即 Index Condition Pushdown，是 MySQL 使用索引从表中检索数据的一种优化方式，从 MySQL 5.6 开始支持，默认开启。使用 ICP 优化时，执行计划中 extra 会显示 Using index condition。</p>
<p>ICP 开启后，如果 Where 条件可以使用索引，MySQL 会把过滤操作放到存储引擎层，过滤后再把满足的行从表中读取出来，以减少访问基表的次数和 Server 层访问存储引擎的次数。（5.6 前遍历索引定位到行，返回给 Server 层后再过滤。）</p>
<p>MRR 即 Multi-Range Read Optimization，作用是把普通索引叶子节点上找到的主键值集合先存储到 read_rnd_buffer 中（生产环境可在 4 ~ 8 MB 间调整），进行排序后在利用排序完毕的主键值集合访问表，由随机 IO 转为顺序 IO 降低开销。使用 MRR 优化时，执行计划中 extra 显示 Using MRR。</p>
<p>MRR 特性也是从 5.6 之后才有的，通过 optimizer_switch 参数中的两个选项控制。一个是 mrr，控制是否开启；另一个是 mrr_cost_based，开启时表示根据优化代价选择是否使用，关闭时表示强制使用。</p>
<p>BKA 即 Batched Key Access，是提高 join 表连接性能的算法，作用是读取被连接表时使用顺序 IO。通过 join buffer 收集第一个操作对象生成的相关列值，排序后通过 MRR 传给引擎层做索引查找。</p>
<p>BKA 通过 optimizer_switch 参数中 batched_key_access 选项来控制，默认关闭，开启需要保证强制 MRR。</p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引是约束条件的一种，不允许重复的值，但对 null 没有限制。主键只能有一个，但唯一索引可以有多个。</p>
<p>创建唯一索引的语法为 <code>alter table table_name add unique ( 索引字段 )</code> 。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引，即只需要通过索引就可以返回查询需要的数据，而不必查到索引后再到表中查询，大幅减少 IO 操作，效率极高。执行计划中 extra 会显示 Using index。</p>
<p>比如要通过 name 字段查询满足条件的主键 id，而 name 为普通索引字段，由于普通索引中包含主键值，所以就使用了覆盖索引。</p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>对于 BLOB、TEXT 或很长的 VARCHAR 类型，可以为它们的前几个字符建立索引，即前缀索引。前缀索引更小，查询也会更快。缺点是不能再 order by、group by 中使用，也不能用作覆盖索引。</p>
<p>创建前缀索引的语法为 <code>alter table table_name add key(column_name(prefix_length))</code> 。</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引即在表中两个或两个以上的列上创建的索引，通过索引中附加的列可以缩小检索的范围，更快地搜索数据。创建语法和创建普通索引一样，如 <code>create index idx_c1_c2 on t (c1, c2)</code> ，一般把选择性高的列放在前面。</p>
<p>使用联合索引，需要满足左前缀原则，查询语句可以只使用索引的一部分，但必须从最左侧开始。</p>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引采用哈希算法，将键值转换为哈希值，只能进行等值查询，不可用于排序、模糊查询和范围查询。InnoDB 中哈希索引是自适应的，会根据使用情况自动生成，不能人为干预。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>索引有如下优点：</p>
<ul>
<li>提高数据检索效率</li>
<li>提高聚合函数效率</li>
<li>提高排序效率</li>
<li>使用覆盖索引可以通过索引直接返回数据</li>
</ul>
<p>创建索引时要避免如下场景：</p>
<ul>
<li>字段选择性低，如性别、状态</li>
<li>对字段的查询很少</li>
<li>字段为 BLOB、TEXT 等大数据类型</li>
<li>字段允许为 NULL</li>
</ul>
<p>使用不到索引的情况：</p>
<ul>
<li>通过索引扫描的行数超过全表 30%，优化器会转为全表扫描</li>
<li>联合索引中第一个查询条件不是最左索引列</li>
<li>两个单列索引分别用于检索和排序，只能用到一个索引（查询最多使用一个索引，可以考虑联合索引）</li>
<li>查询字段上有索引，但使用了函数运算</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 表管理</title>
    <url>/2018/12/11/MySQL-%E8%A1%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>MySQL 其实就是一个包含很多表的集合，表中主要的数据类型可以分为整型、浮点型、字符类型和日期时间类型。MySQL 中数值类型可以指定是否区分正负和用零填补。选择数据类型时应符合最小、最合适的原则。</p>
<a id="more"></a>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>MySQL 中整型类型有 tinyint、smallint、mediumint、int 和 bigint，分别占 1、2、3、4 和 8 个字节，其中 int 和 tinyint 最常用。</p>
<p>数据表中经常使用 id 字段作为主键，一般选择 int 类型，int unsigned 数值范围可达 42 亿，一般情况下足够业务上的应用。</p>
<p>需要注意的是，int(4) 和 int(11) 都占 4 个字节的空间，括号中的数字表示显示宽度，而非所占的字节数。如果类型定义为 int(n) zerofill，不足 n 位时会用 0 补充。</p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>浮点型包含 float、double 和 decimal，其中 float 占 4 个字节；double 占 8 个字节；decimal(m,d) 中 m 指最大位数（精度），范围是 1 到 65，d 是小数点右边的位数（刻度），范围为 0 到 30，且不得大于 m，d 省略时默认值为0，m 省略时默认值为10。</p>
<h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p>时间类型包含 date、time、year、datetime 和 timestamp。</p>
<ul>
<li>date 占 3 个字节，范围为 1000-01-01 至 9999-12-31。</li>
<li>time 占 3 个字节，范围为 -838:59:59 至 838:59:59。</li>
<li>year 占 1 个字节，范围为 1901 至 2155。</li>
<li>datetime 在 5.6 之前占 8 个字节，5.6 之后占 5 个字节，范围为 1000-01-01 00:00:00 至 9999-12-31 23:59:59。</li>
<li>timestamp 占 4 个字节，范围为 1970-01-01 00:00:00 至 2038 年。</li>
</ul>
<p>datatime 可用范围比 timestamp 大，仅比 timestamp 多占 1 个字节的空间，生产环境可以优先使用 datetime。或者也可以使用 int 来存储时间，通过 unix_timestamp 和 from_timestamp 函数转换使用。</p>
<p>datetime 和 timestamp 在 5.6 之后均支持自动更新为当前时间 ON UPDATE CURRENT_TIMESTAMP。</p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型包含 char、varchar、tinyblob、tinytext、blob、text、mediumblob、mediumtext、longblob 和 longtext。</p>
<ul>
<li>char 用于定长字符串，最多可容纳 255 个字符，没达到定义位数时尾部用空格不全存入表中，超过时截断。</li>
<li>varchar 用于变长字符串，最多占 65535 个字节，没达到定义位数不会补空格，超过时截断。</li>
</ul>
<blockquote>
<p>text、blob（二进制形式长文本）这种存储大量文字或图片的大数据类型最好不要与业务表放在一起。</p>
<p>不确定字段需要存储多少字符时使用  varchar 可以节约磁盘空间，提高存储效率。</p>
<p>varchar(100) 中 100 表示最大字符数，UTF8 字符集下存储空间 为 100 * 3 + 2 个字节。字节数小于 255 时用 1 个字节记录长度，超过 255 时用 2 个字节记录长度。</p>
<p>存储 IPv4 时可以使用 int 类型，通过 inet_aton 和 inet_ntoa 函数来转换。</p>
</blockquote>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>MySQL 中字符集包括 character 字符集 和 collation 校对规则，字符集用来定义数据字符串的存储方式，校对规则定义比较字符串的方式。</p>
<p>常见字符集包括 GBK、Latin1、UTF8、UTF8mb6：Latin1 目前已经不适用了；GBK 一个字符占 2 个字节，通用性没有 UTF8 好；UTF8 一个字符占 3 个字节；UTF8mb4 是 UTF8 的超集，一个字符占 4 个字节，可以存储 emoji 符号。建议使用 UTF8mb4。</p>
<blockquote>
<p>临时修改数据库字符集，可以在数据库命令执行 set names，如 set names utf8。</p>
</blockquote>
<h2 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h2><p>在表中删除大量的数据后，数据文件的大小可能并没有减小。</p>
<p>delete 删除数据，MySQL 不会把数据文件真实删除，而是将数据文件的标示位删除，也不会整理数据文件，所以不会释放空间。新数据写入时，MySQL 会再次利用这些区域，但无法彻底占用。</p>
<p>删除操作会产生数据碎片，碎片会占用磁盘空间，扫描全表时也会扫描碎片部分，并且在读取效率方面比正常的空间低很多。</p>
<p>通过 <code>show table status like &#39;%table_name%&#39;</code> 语句可以查看表的状态，碎片大小 = 数据总大小 - 实际表空间文件大小，数据总大小 = data_length + index_length，实际表空间文件大小 = rows * avg_row_length。</p>
<p>innodb 引擎的表可以通过 <code>alter table table_name engine = innodb</code> 来重新整理全表数据，缺点是需要给整个表加写锁，并且需要一些时间。备份原表数据，删除整个表，重新导入到新表中也可以清理掉碎片。</p>
<h2 id="库表常用命令"><a href="#库表常用命令" class="headerlink" title="库表常用命令"></a>库表常用命令</h2><ul>
<li><code>use database</code> 选择数据库</li>
<li><code>show databases</code> 查看全部数据库</li>
<li><code>show tables</code> 查看当前库所有的表</li>
<li><code>create database database_name</code> 创建数据库</li>
<li><code>drop database database_name</code> 删除数据库</li>
<li><code>create table table_name (字段列表)</code> 创建表</li>
<li><code>drop table table_name</code> 删除表</li>
<li><code>delete from table_name (where)</code> 、<code>truncate table table_name</code> 删除表内数据</li>
<li><code>insert into table_name (字段列表) values (对应字段的值)</code> 插入数据</li>
<li><code>update table_name set 字段名 = 值 (where)</code> 更新表内数据</li>
<li><code>select * from table_name (where)</code> 查看表内数据</li>
<li><code>show create table table_name</code> 查看建表语句</li>
<li><code>desc table_name</code> 、<code>describe table_name</code> 查看表结构</li>
<li><code>show table status</code> 获取表基础信息</li>
<li><code>show index from table_name</code> 查看当前表索引</li>
<li><code>show full processlist</code> 查看数据库当前连接</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 锁</title>
    <url>/2018/12/20/MySQL-%E9%94%81/</url>
    <content><![CDATA[<p>锁是一种使各种共享资源在被并发访问时变得有序，从而保证数据一致性的机制。</p>
<p>MySQL 中不同存储引擎支持不同的锁机制，InnoDB 支持行锁、表锁，MyISAM 只支持表锁。</p>
<p>表锁开销小、加锁快，不会出现死锁，但锁冲突概率大，并发度低；而行锁开销大、加锁慢，会出现死锁，但锁冲突概率小，并发度高。</p>
<a id="more"></a>
<h2 id="InnoDB-锁类型"><a href="#InnoDB-锁类型" class="headerlink" title="InnoDB 锁类型"></a>InnoDB 锁类型</h2><p>InnoDB 的锁类型包括读锁（共享锁）、写锁（排他锁）、MDL 锁和意向锁。</p>
<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>读锁，简称 S 锁，一个事务获取了一个数据行的读写，其他事务能获取该行对应的读锁，但不能获得写锁，即其他事务可以读取数据行，但不能对其进行修改。</p>
<p>通过 select 查询时，如果在尾部添加 <code>lock in share mode</code> ，会在读取的行记录或行记录的范围上加读锁，其他事务可以读，但修改操作会阻塞。不加 <code>lock in share mode</code> 则不会加读锁。</p>
<h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>写锁，简称 X 锁，优先级最高，一个事务获取了一个数据行的写锁，其他事务就不能再获取该行的其他锁。</p>
<p>DML 语句会对行记录或行记录范围加写锁。</p>
<p><code>select ... for update</code> 可以对读取的行记录加写锁，其他事务尝试对锁定的行加锁时会被阻塞。</p>
<h3 id="MDL-锁"><a href="#MDL-锁" class="headerlink" title="MDL 锁"></a>MDL 锁</h3><p>MDL 锁（meta data lock）在 MySQL 5.5 被引入，用于保证表中元数据的一致性。</p>
<p>一个会话开启事务后，会自动获取 MDL 锁，期间其他会话不可以执行任何 DDL 语句的操作。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB 中意向锁是表级锁，分为意向共享锁和意向排他锁，作用于 MDL 锁类似，都是防止在事务进行过程中执行 DDL 语句而导致数据不一致。</p>
<p>意向共享锁（IS）即给数据行加共享锁前必须先取得该表的 IS 锁，意向排他锁（IX）即给数据行加排他锁前必须先取得该表的 IX 锁。</p>
<h2 id="InnoDB-行锁种类"><a href="#InnoDB-行锁种类" class="headerlink" title="InnoDB 行锁种类"></a>InnoDB 行锁种类</h2><p>InnoDB 在默认事务隔离级别 RR 的模式下，行锁分为三种：单个行记录的锁 record lock 、间隙锁 gap lock 和 记录锁与间隙锁的组合 next-key lock。</p>
<h3 id="单个行记录的锁"><a href="#单个行记录的锁" class="headerlink" title="单个行记录的锁"></a>单个行记录的锁</h3><p>InnoDB 中对单个行记录的锁加在索引项上。</p>
<p>表 t 包含 id、name、age 三列，在事务中执行 <code>update t set age = 10 where name = &#39;AAA&#39;</code> 。事务执行过程中，如果 name 上有索引，则会在 name = ‘AAA’ 的行上加锁，如果 name 上无索引，则会在所有行记录上加锁。</p>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>可重复读事务隔离级别 RR 为了避免幻读现象，引入了间隙锁 gap lock，锁定行记录数据的范围，不包含记录本身，即不允许在此范围内插入任何数据。</p>
<p>如在事务中查询表 t 中 age 大于 10 的数据并加共享锁（age 上有索引），其他事务插入 age 大于 10 的数据会被阻塞。</p>
<p>间隙锁只针对 RR 可重复读事务隔离级别有效，RC 读已提交隔离级别允许幻读现象。</p>
<h3 id="Next-key-Locks"><a href="#Next-key-Locks" class="headerlink" title="Next-key Locks"></a>Next-key Locks</h3><p>Next-key Locks 是记录锁与间隙锁的组合，InnoDB 会首先对选中的索引记录加锁，再对间隙加锁。</p>
<p>如在事务中查询表 t 中 age 大于 10 的数据并加共享锁（age 上有索引），其他事务不但插入 age 大于 10 的数据会被阻塞，插入 age 等于 10 的数据也会被阻塞。</p>
<h2 id="锁等待与死锁"><a href="#锁等待与死锁" class="headerlink" title="锁等待与死锁"></a>锁等待与死锁</h2><p>锁等待指一个事务过程中获取锁，其他事务需要等待锁释放才能占用该资源。如果获取锁的事务一直不释放，其他事务会一直等待，直到超过锁等待时间。锁最长等待时间通过 innodb_lock_wait_timeout 参数控制，单位秒。</p>
<p>死锁指两个及以上的事务过程中，因争夺资源而造成的一种相互等待的现象，常见报错为 Deadlock found when trying to get lock; try restarting transaction。</p>
<p>InnoDB 可以自动检测死锁，并自动回滚造成死锁的事务。</p>
<p>出现锁问题时，可以通过 <code>show full processlist</code> 和 <code>show engine innodb status</code> 命令来判断事务中锁的情况，也可以通过 information_schema 库下的 INNODB_TRX、INNODB_LOCKS 和 INNODB_LOCK_WAITS 三张表来监控当前事务。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 安装和基础数据结构</title>
    <url>/2019/08/16/Redis-%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>Redis 包含 5 中基础数据结构，分别为字符串 string 、列表 list 、字典 hash 、集合 set 和有序集合 zset 。</p>
<p>本篇文章简要介绍 Redis 的安装和这 5 种基础数据结构的使用。</p>
<a id="more"></a>
<h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><p>官网下载源码压缩包，如 <code>redis-5.0.5.tar.gz</code> ，解压后编译即可完成安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd redis-5.0.5</span><br><span class="line"><span class="meta">$</span> make</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 运行 Redis 服务器</span><br><span class="line"><span class="meta">#</span> --daemonize yes 或在 redis.conf 中修改 daemonize 为 yes 表示后台运行</span><br><span class="line"><span class="meta">$</span> cd src</span><br><span class="line"><span class="meta">$</span> ./redis-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 运行命令行客户端</span><br><span class="line"><span class="meta">$</span> ./redis-cli</span><br></pre></td></tr></table></figure>
<h3 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h3><p>Redis 中所有的数据结构都以唯一的 key 作为名称，通过 key 来获取相应的 value。不同数据结构类型的差异在于 value 的结构不一样。</p>
<p>list 、 set 、hash 和 zset 这四种数据结构为容器型结构，对其进行操作时，如果 key 不存在则先创建再操作，最后一个元素被删除时数据结构被删除。</p>
<p>Redis 中可以对 key 设置过期时间，到时间会自动删除 key ，常用于控制缓存的失效时间。</p>
<p>需要注意的是，只能对整个 key 设置过期时间，不能对某个子 key 设置过期时间，另外对已经设置了过期时间的 key 进行修改，过期时间会消失。</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串是 Redis 中最简单的数据结构，可以动态地修改字符串，常见的用法如缓存用户信息。</p>
<p>string 的内部表示是一个字符数组，类似于 Java 中的 ArrayList ，通过预分配冗余空间来减少内存的频繁分配。</p>
<p>当字符串长度小于 1 MB 时，按现有空间加倍扩容，超过 1 MB 时每次扩容 1 MB ，最大长度为 512 MB 。</p>
<p>string 的操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 设置 name 的值为 Jack</span><br><span class="line"><span class="meta">&gt;</span> set name Jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取 name 的值</span><br><span class="line"><span class="meta">&gt;</span> get name</span><br><span class="line">"Jack"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 判断是否存在键 name</span><br><span class="line"><span class="meta">&gt;</span> exists name</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除键 name</span><br><span class="line"><span class="meta">&gt;</span> del name</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 批量设置</span><br><span class="line"><span class="meta">&gt;</span> mset name1 Jack name2 Tony name3 Jay</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 批量获取</span><br><span class="line"><span class="meta">&gt;</span> mget name1 name2 name3</span><br><span class="line">1) "Jack"</span><br><span class="line">2) "Tony"</span><br><span class="line">3) "Jay"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置 5 秒后过期</span><br><span class="line"><span class="meta">&gt;</span> expire name1 5</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置 key 且 5 秒后过期，相当于 set + expire</span><br><span class="line"><span class="meta">&gt;</span> setex name 5 Jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果 key 不存在就创建</span><br><span class="line"><span class="meta">&gt;</span> setnx name Jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果 value 为整数，可以对其进行自增操作</span><br><span class="line"><span class="meta">&gt;</span> set age 18</span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span> incr age</span><br><span class="line">(integer) 19</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> age 的值加 5（可传入负数表示减操作）</span><br><span class="line"><span class="meta">&gt;</span> incrby age 5</span><br><span class="line">(integer) 24</span><br></pre></td></tr></table></figure>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>Redis 中的列表相当于 Java 中的 LinkedList，是链表而非数组。插入和删除操作非常快，时间复杂度 O(1) ，但索引定位很慢，时间复杂度 O(n) 。</p>
<p>Redis 底层存储的不是简单的 LinkedList ，而是称为 QuickList 的结构。元素较少时使用连续的内存存储（ziplist 压缩列表），元素多时将多个 ziplist 组成链表，既满足快速插入删除的性能，又节约了空间。</p>
<p>Redis 列表常用做异步队列，将任务塞进列表，另一个线程从列表中轮询数据进行处理。</p>
<p>list 的操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 向右插入一个或多个元素</span><br><span class="line"><span class="meta">&gt;</span> rpush books b1 b2 b3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 向左插入一个或多个元素</span><br><span class="line"><span class="meta">&gt;</span> lpush books b4 b5 b6</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取列表长度</span><br><span class="line"><span class="meta">&gt;</span> llen books</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从左侧弹出一个元素</span><br><span class="line"><span class="meta">&gt;</span> lpop books</span><br><span class="line">"b6"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从右侧弹出一个元素</span><br><span class="line"><span class="meta">&gt;</span> rpop books</span><br><span class="line">"b3"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取指定索引的元素</span><br><span class="line"><span class="meta">&gt;</span> lindex books 3</span><br><span class="line">"b2"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 截取指定索引内的列表，仅保留截取范围内的区间</span><br><span class="line"><span class="meta">#</span> index 可以为负数，-1 表示倒数第一个元素，-2 表示倒数第二个元素</span><br><span class="line"><span class="meta">&gt;</span> ltrim books 1 2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取指定索引区间的元素</span><br><span class="line"><span class="meta">&gt;</span> lrange books 0 -1</span><br><span class="line">1) "b4"</span><br><span class="line">2) "b1"</span><br></pre></td></tr></table></figure>
<h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>Redis 中的字典相当于 Java 中的 HashMap ，实现结构也与 Java 一致，即数组和链表的二维结构，一维 hash 数组位置碰撞时，将碰撞的元素用链表串起来。</p>
<p>Redis 中字典的值只能是字符串，另外 rehash 时采用了渐进式 rehash 策略。</p>
<p>渐进式 rehash 策略在执行时，会同时保留两个 hash 结构，查询时同时查询两个结构，由定时任务循序渐进地将旧 hash 中的数据转移到新 hash 中，全部转移完成用新的 hash 取代旧的，旧的 hash 被删除。</p>
<p>字典可用于按字段存储用户信息，从而不必获取全部的信息，不过 hash 结构的存储消耗要高于字符串。</p>
<p>hash 的操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 对指定键插入 key - value ，更新操作返回 0</span><br><span class="line"><span class="meta">&gt;</span> hset books redis RedisBook</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span> hset books java JavaBook</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span> hset books java NewJavaBook</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取指定字典的全部内容</span><br><span class="line"><span class="meta">&gt;</span> hgetall books</span><br><span class="line">1) "redis"</span><br><span class="line">2) "RedisBook"</span><br><span class="line">3) "java"</span><br><span class="line">4) "NewJavaBook"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取字典长度</span><br><span class="line"><span class="meta">&gt;</span> hlen books</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取字典中指定 key 的 value</span><br><span class="line"><span class="meta">&gt;</span> hget books redis</span><br><span class="line">"RedisBook"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 批量插入 key - value</span><br><span class="line"><span class="meta">&gt;</span> hmset books python PythonBook golang GolangBook</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 对字典中单个 key 进行计数操作</span><br><span class="line"><span class="meta">&gt;</span> hset books number 1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span> hincrby books number 5</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>Redis 中的集合相当于 Java 中的 HashSet ，键值对无序且唯一，内部实现相当于一个特殊的字典，value 都是 NULL 。</p>
<p>集合可用于存储活动中奖用户 ID ，保证一个用户不会中奖两次。</p>
<p>set 的操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 向集合中插入一个或多个元素</span><br><span class="line"><span class="meta">&gt;</span> sadd books python</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span> sadd books python</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span> sadd books java golang</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取集合中全部元素</span><br><span class="line"><span class="meta">&gt;</span> smembers books</span><br><span class="line">1) "python"</span><br><span class="line">2) "golang"</span><br><span class="line">3) "java"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取集合大小</span><br><span class="line"><span class="meta">&gt;</span> scard books</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 判断元素是否在集合中</span><br><span class="line"><span class="meta">&gt;</span> sismember books java</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 弹出一个元素</span><br><span class="line"><span class="meta">&gt;</span> spop books</span><br><span class="line">"golang"</span><br></pre></td></tr></table></figure>
<h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>Redis 中的有序集合 zset 既可以保证内部元素的唯一性，又可以给每一个元素赋予一个排序权重 score 。</p>
<p>有序集合可以用于存储学生成绩，元素即学生 ID ，score 为其考试成绩，可以按成绩排序获取名次。</p>
<p>zset 的操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 向有序集合中插入元素</span><br><span class="line"><span class="meta">&gt;</span> zadd books 1 book1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span> zadd books 3 book2</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span> zadd books 2 book3</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按 score 排序列出指定名次范围的元素</span><br><span class="line"><span class="meta">&gt;</span> zrange books 0 1</span><br><span class="line">1) "book1"</span><br><span class="line">2) "book3"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按 score 逆序列出指定名次范围的元素</span><br><span class="line"><span class="meta">&gt;</span> zrevrange books 0 1</span><br><span class="line">1) "book2"</span><br><span class="line">2) "book3"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取集合大小</span><br><span class="line"><span class="meta">&gt;</span> zcard books</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取指定 value 的 score</span><br><span class="line"><span class="meta">&gt;</span> zscore books book1</span><br><span class="line">"1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取指定 value 的排名</span><br><span class="line"><span class="meta">&gt;</span> zrank books book1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按 score 区间遍历集合</span><br><span class="line"><span class="meta">&gt;</span> zrangebyscore books 0 2</span><br><span class="line">1) "book1"</span><br><span class="line">2) "book3"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除指定 value</span><br><span class="line"><span class="meta">&gt;</span> zrem books book3</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 开发者工具</title>
    <url>/2017/10/17/Spring-Boot-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>Spring Boot 自 1.3 版本起包含一组开发者工具，其中的 <strong>自动重启</strong> 和 <strong>LiveReload 支持</strong> 可以让开发过程更加便捷。</p>
<p>使用前需向工程中添加开发者工具，如 maven：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  程序以完整打包好的 JAR 或 WAR 文件形式运行时，开发者工具会被禁用，无需在生产部署前移除依赖。</p>
<a id="more"></a>
<h2 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h2><p>添加开发者工具后，classpath 中对文件的任何修改都会触发程序的重启。为了速度够快，不会修改的类（如第三方 JAR）会加载到基础类加载器中，应用程序的代码会单独加载到重启类加载器里。检测到变更时只有重启类加载器会被重启。</p>
<p>默认情况下，Spring Boot 会排除掉如下目录：<strong>/META-INF/resources、/resources、/static、/public 和 /templates</strong></p>
<p>通过 <code>spring.devtools.restart.exclude</code> 属性可以覆盖默认的重启排除目录，如 <code>spring.devtools.restart.exclude=/static/**, /templates/**</code>。</p>
<p>通过 <code>spring.devtools.restart.enabled=false</code> 可以彻底关闭自动重启。</p>
<p>需要注意的是，Intellij IDEA 默认关闭自动编辑功能，需在 <strong>preferences – Build, Execution, Deployment –Compiler</strong> 中打开自动编辑，如图</p>
<p><img src="https://blog.ulyssesss.com/assets/img/201710171.png" alt="preferences"></p>
<p>然后按 <code>Shift + Command + Alt + /</code>，选择 <strong>Registry</strong>，勾选 <code>compiler.automake.allow.when.app.running</code>，如图</p>
<p><img src="https://blog.ulyssesss.com/assets/img/201710172.png" alt="registry"></p>
<p>设置完毕并重启后生效。</p>
<h2 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h2><p>在 Web 应用开发过程中，比较常见的步骤包含：</p>
<p>1.修改要呈现的内容，如image、css、template。</p>
<p>2.刷新浏览器。</p>
<p>3.重复第一步。</p>
<p>Spring Boot 的开发者工具会在启动一个内嵌的 LiveReload 服务器，在资源文件变化时自动触发浏览器刷新，唯一要做的就是在浏览器中安装 LiveReload (<a href="http://livereload.com" target="_blank" rel="noopener">http://livereload.com</a>) 插件。</p>
<p>通过配置 <code>spring.devtools.livereload.enable=false</code> 可禁用 LiveReload 功能。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 消息队列</title>
    <url>/2019/08/20/Redis-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>Redis 可用作轻量级的消息队列，使用简单。</p>
<p>不过 Redis 不是专业的消息队列，缺少很多的高级功能，比如没有 ack 保证（ Acknowledgement ，消息确认机制）。如果对消息可靠性有较高的要求，就不适合使用 Redis 消息队列。</p>
<a id="more"></a>
<h3 id="异步消息队列"><a href="#异步消息队列" class="headerlink" title="异步消息队列"></a>异步消息队列</h3><p>Redis 中的 list 数据结构常用作异步消息队列，通过 lpush 或 rpush 指令操作入队列，通过 lpop 或 rpop 指令操作出队列，支持多个生产者和一组消费者（组内每个消费者拿到不同的列表元素），示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 消息入队列</span><br><span class="line"><span class="meta">&gt;</span> rpush notify-queue java python golang</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span> rpush notify-queue php</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 消息出队列</span><br><span class="line"><span class="meta">&gt;</span> lpop notify-queue</span><br><span class="line">"java"</span><br><span class="line"><span class="meta">&gt;</span> lpop notify-queue</span><br><span class="line">"python"</span><br></pre></td></tr></table></figure>
<h4 id="空队列处理"><a href="#空队列处理" class="headerlink" title="空队列处理"></a>空队列处理</h4><p>如果队列中的消息全部处理完成，pop 指令获取不到元素，客户端会陷入循环，浪费资源。</p>
<p>一种解决方法是让客户端线程 sleep ，每隔一段时间尝试一次获取消息，缺点是消息的消费会存在延迟。</p>
<p>更好的解决方法是使用 blpop 或 brpop 指令来阻塞读取消息，b 表示 blocking ，没有新消息时阻塞，来新消息时能够立即获取到消息。</p>
<p>需要注意的是，如果阻塞时间过长，Redis 服务端会主动断开连接以回收资源，blpop 或 brpop 会抛出异常，客户端消费者需要捕获异常并重试，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 读取消息，最长阻塞时间 5 s</span><br><span class="line"><span class="meta">&gt;</span> blpop notify-queue 5</span><br><span class="line">1) "notify-queue"</span><br><span class="line">2) "golang"</span><br><span class="line"><span class="meta">&gt;</span> blpop notify-queue 5</span><br><span class="line">1) "notify-queue"</span><br><span class="line">2) "php"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 5 s 内未读取到消息，断开</span><br><span class="line"><span class="meta">&gt;</span> blpop notify-queue 5</span><br><span class="line">(nil)</span><br><span class="line">(5.04s)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生产消息</span><br><span class="line"><span class="meta">&gt;</span> rpush notify-queue C#</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 阻塞 3.05 s 读取到消息</span><br><span class="line"><span class="meta">&gt;</span> blpop notify-queue 5</span><br><span class="line">1) "notify-queue"</span><br><span class="line">2) "C#"</span><br><span class="line">(3.05s)</span><br></pre></td></tr></table></figure>
<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延时队列可以通过 Redis 中的 zset 数据结构来实现，其中消息的内容作为 zset 的 value ，消息的到期处理时间作为 zset 的 score 。</p>
<p>使用时通过 zadd 指令生产消息，多个客户端线程通过 zrangebyscore 指令读取队列中的消息，再通过 zrem 指令来确定消息的所属消费者，成功删除消息的消费者执行消费逻辑，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 生产消息 zadd &lt;key&gt; &lt;score&gt; &lt;value&gt;</span><br><span class="line"><span class="meta">&gt;</span> zadd delay-queue 1566298823195 msg1</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取消息 zrangebyscore &lt;key&gt; &lt;min-score&gt; &lt;max-score&gt; &lt;offset&gt; &lt;count&gt;</span><br><span class="line"><span class="meta">&gt;</span> zrangebyscore delay-queue 0 1566298924936 0 1</span><br><span class="line">1) "msg1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除消息成功，执行消费逻辑 zrem &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="meta">&gt;</span> zrem delay-queue msg1</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除消息失败，消息已被其他消费者消费</span><br><span class="line"><span class="meta">&gt;</span> zrem delay-queue msg1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例中同一个任务被多个线程取到后，再通过删除决定从属关系，可以通过 lua 脚本将 zrangebyscore 和 zrem 一同在服务端进行原子化操作，从而节约资源。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分布式锁</title>
    <url>/2019/08/19/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>分布式应用进行逻辑处理需要考虑并发问题。</p>
<p>一个常见的场景如修改用户状态，修改前需要先读取用户当前状态，修改后进行保存。由于整个过程不是原子操作，一旦多个操作同时进行，就可能导致状态异常。</p>
<p>引入分布式锁可以解决上述问题，而 Redis 分布式锁是使用非常广泛的一种实现方式。</p>
<a id="more"></a>
<h3 id="分布式锁的特性"><a href="#分布式锁的特性" class="headerlink" title="分布式锁的特性"></a>分布式锁的特性</h3><p>分布式锁需要具备获取锁、释放锁的功能，并且需要能够处理异常情况。</p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>Redis 中的 setnx 指令可以用于实现获取锁的操作， set if not exists ，在锁没有被其他客户端占有的情况下获取锁，先来先占。</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>Redis 中的 del 指令可以用于实现释放锁的操作，逻辑处理完成之后通过 del 删除指定的 key 来释放锁。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>如果在逻辑处理执行过程中发生异常，可能会导致 del 指令不被调用，锁会一直得不到释放。</p>
<p>解决方法是在获取锁的同时给锁加一个过期时间，确保即使出现异常也会在过期后自动释放。</p>
<p>在 Redis 2.8 版本之前，没有 setnx 和 expire 合并到一起的原子指令，如果分开执行可能在 setnx 成功后 expire 指令执行失败，依然造成死锁。而 Redis 又不支持事务中 if - else 分支逻辑，所以 Redis 开源社区涌现了很多 Library 来解决这个问题。</p>
<p>Redis 2.8 版本中加入了 set 指令的扩展参数，使 setnx 和 expire 指令可以作为原子操作来执行，格式为 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> set &lt;key&gt; &lt;value&gt; ex &lt;seconds&gt; nx</span><br><span class="line"><span class="meta">&gt;</span> set lock:update true ex 5 nx</span><br></pre></td></tr></table></figure>
<h4 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h4><p>Redis 的分布式锁不能解决超时问题，所以 Redis 分布式锁不适用于耗时较长的任务。</p>
<p>如果获取锁后的操作耗时太长，超过锁的过期时间，其他线程就可以提前获取到锁，导致临界区代码不能得到严格的串行执行。</p>
<h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>可重入性，指线程在持有锁的情况下，能够再次请求获取到锁，比如 Java 中的 ReentrantLock 就是可重入锁。</p>
<p>Redis 分布式锁如果需要支持可重入，可以对客户端 set 方法进行包装，通过 ThreadLocal 存储当前持有锁的计数。</p>
<p>可重入锁还需要考虑内存锁计数的过期时间等问题，代码复杂度会持续升高，最好通过合理的处理逻辑来避免使用可重入锁。</p>
<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 线程一获取锁</span><br><span class="line"><span class="meta">#</span> 如果 lock:test 不存在，则设置 lock:test 键的值为 true ，10秒后过期</span><br><span class="line"><span class="meta">&gt;</span> set lock:test true ex 10 nx</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 线程二同时请求获取锁，获取失败</span><br><span class="line"><span class="meta">&gt;</span> set lock:test true ex 10 nx</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 线程一业务逻辑处理 ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 线程一释放锁</span><br><span class="line"><span class="meta">#</span> 删除 lock:test</span><br><span class="line"><span class="meta">&gt;</span> del lock:test</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Config 配置中心</title>
    <url>/2018/04/23/Spring-Cloud-Config-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<p>Spring Cloud Config 用于为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，分为服务端和客户端。</p>
<p>服务端为分布式配置中心，是一个独立的微服务应用；客户端为分布式系统中的基础设置或微服务应用，通过指定配置中心来管理相关的配置。</p>
<p>Spring Cloud Config 构建的配置中心，除了适用于 Spring 构建的应用外，也可以在任何其他语言构建的应用中使用。</p>
<p>Spring Cloud Config 默认采用 Git 存储配置信息，天然支持对配置信息的版本管理。</p>
<a id="more"></a>
<h2 id="构建配置中心"><a href="#构建配置中心" class="headerlink" title="构建配置中心"></a>构建配置中心</h2><p>创建 Spring Boot 工程 config-server，然后按以下步骤完成配置中心的构建。</p>
<h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-通过注解启用配置中心"><a href="#2-通过注解启用配置中心" class="headerlink" title="2.通过注解启用配置中心"></a>2.通过注解启用配置中心</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.configserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3.修改配置"></a>3.修改配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=7001</span><br><span class="line"></span><br><span class="line"># Git 仓库位置</span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/Ulyssesss/spring-cloud-config-example.git</span><br><span class="line"></span><br><span class="line"># 仓库路径下相对搜索位置，可配置多个</span><br><span class="line">spring.cloud.config.server.git.search-paths=config</span><br><span class="line"></span><br><span class="line"># 访问 Git 仓库的用户名</span><br><span class="line">spring.cloud.config.server.git.username=</span><br><span class="line"></span><br><span class="line"># 访问 Git 仓库的密码</span><br><span class="line">spring.cloud.config.server.git.password=</span><br></pre></td></tr></table></figure>
<h3 id="4-创建配置仓库并提交修改"><a href="#4-创建配置仓库并提交修改" class="headerlink" title="4.创建配置仓库并提交修改"></a>4.创建配置仓库并提交修改</h3><p>创建 Git 仓库及 config 目录，添加 <code>ulyssesss.properties</code>、<code>ulyssesss-dev.properties</code>，在配置中分别添加 <code>from=default-1.0</code> 和 <code>from=dev-1.0</code> 。</p>
<p>创建 <code>config-label-test</code> 分支，将配置文件中的版本号 <code>1.0</code> 修改为 <code>2.0</code> 。</p>
<p>提交修改并推送至远程仓库后启动 config-server，可按照以下规则访问配置信息：</p>
<ul>
<li>/ {application} / {profile} [ / {label} ]</li>
<li>/ {application} - {profile} . yml</li>
<li>/ {label} / {application} - {profile} . yml</li>
<li>/ {application} - {profile} . properties</li>
<li>/ {label} / {application} - {profile} . properties</li>
</ul>
<h2 id="客户端获取配置"><a href="#客户端获取配置" class="headerlink" title="客户端获取配置"></a>客户端获取配置</h2><p>创建Spring Boot 工程 config-client ，按以下步骤编写客户端：</p>
<h3 id="1-添加依赖-1"><a href="#1-添加依赖-1" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-增加配置"><a href="#2-增加配置" class="headerlink" title="2.增加配置"></a>2.增加配置</h3><p>创建 bootstrap.properties，并增加配置中心的相关配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=ulyssesss</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.label=config-label-test</span><br><span class="line">spring.cloud.config.uri=http://localhost:7001</span><br></pre></td></tr></table></figure>
<p>注意，以上属性必须配置在 bootstrap.properties 中。</p>
<p>由于 Spring Boot 应用会优先加载应用 jar 包以外的配置，而通过 bootstrap.properties 对 config-server 的配置会使应用从 config-server 中获取外部配置，优先级比本地配置高。</p>
<h3 id="3-创建控制器查看配置"><a href="#3-创建控制器查看配置" class="headerlink" title="3.创建控制器查看配置"></a>3.创建控制器查看配置</h3><p>创建 ConfigClientController，通过访问 <a href="http://localhost:8080/from" target="_blank" rel="noopener">http://localhost:8080/from</a> 获取配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.configclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;from&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"from"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问 <a href="http://localhost:8080/from" target="_blank" rel="noopener">http://localhost:8080/from</a> ，得到返回结果 <code>from=dev-2.0</code> 。修改配置中的 <code>spring.cloud.config.profile</code> 和 <code>spring.cloud.config.label</code> ，重启应用再次访问链接会得到相应的配置信息。</p>
<h2 id="服务模式高可用配置"><a href="#服务模式高可用配置" class="headerlink" title="服务模式高可用配置"></a>服务模式高可用配置</h2><p>传统模式的高可用不需要额外的配置，只需将所有的 config-server 实例全部指向同一个 Git 仓库，客户端指定 config-server 时指向上层负载均衡设备地址。</p>
<p>服务模式通过将 config-server 纳入 Eureka 服务治理体系，将 config-server 注册成为一个微服务应用，客户端通过服务名从服务注册中心获取配置中心的实例信息。</p>
<h3 id="1-添加服务端依赖"><a href="#1-添加服务端依赖" class="headerlink" title="1.添加服务端依赖"></a>1.添加服务端依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-注解启用服务发现功能"><a href="#2-注解启用服务发现功能" class="headerlink" title="2.注解启用服务发现功能"></a>2.注解启用服务发现功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.configserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-添加服务端配置"><a href="#3-添加服务端配置" class="headerlink" title="3.添加服务端配置"></a>3.添加服务端配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=7001</span><br><span class="line"></span><br><span class="line"># Git 仓库位置</span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/Ulyssesss/spring-cloud-config-example.git</span><br><span class="line"></span><br><span class="line"># 仓库路径下相对搜索位置，可配置多个</span><br><span class="line">spring.cloud.config.server.git.search-paths=config</span><br><span class="line"></span><br><span class="line"># 访问 Git 仓库的用户名</span><br><span class="line">spring.cloud.config.server.git.username=</span><br><span class="line"></span><br><span class="line"># 访问 Git 仓库的密码</span><br><span class="line">spring.cloud.config.server.git.password=</span><br><span class="line"></span><br><span class="line"># 服务注册中心地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure>
<h3 id="4-添加客户端依赖"><a href="#4-添加客户端依赖" class="headerlink" title="4.添加客户端依赖"></a>4.添加客户端依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-客户端启用服务发现功能"><a href="#5-客户端启用服务发现功能" class="headerlink" title="5.客户端启用服务发现功能"></a>5.客户端启用服务发现功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.configclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-修改客户端配置"><a href="#6-修改客户端配置" class="headerlink" title="6.修改客户端配置"></a>6.修改客户端配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=ulyssesss</span><br><span class="line">spring.cloud.config.profile=test</span><br><span class="line">spring.cloud.config.label=config-label-test</span><br><span class="line">#spring.cloud.config.uri=http://localhost:7001</span><br><span class="line"></span><br><span class="line"># 服务注册中心地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line"># 启用配置客户端的服务发现功能</span><br><span class="line">spring.cloud.config.discovery.enabled=true</span><br><span class="line"># 指定配置中心的服务名</span><br><span class="line">spring.cloud.config.discovery.service-id=config-server</span><br></pre></td></tr></table></figure>
<h2 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h2><p>有时需要对配置内容进行实时更新，Spring Cloud Config 通过 actuator 可实现此功能。</p>
<h3 id="1-客户端添加依赖"><a href="#1-客户端添加依赖" class="headerlink" title="1.客户端添加依赖"></a>1.客户端添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-添加刷新范围注解"><a href="#2-添加刷新范围注解" class="headerlink" title="2.添加刷新范围注解"></a>2.添加刷新范围注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.configclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;from&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"from"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改配置中 from 的值，提交到远程仓库，通过 post 方法访问 <a href="http://localhost:8080/refresh" target="_blank" rel="noopener">http://localhost:8080/refresh</a> 即可刷新配置项的值。</p>
<p>注意，spring boot 1.5 以上会默认开启安全认证，可通过一下配置关闭安全认证。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关闭安全认证</span><br><span class="line">management.security.enabled=false</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Ulyssesss/spring-cloud-example" target="_blank" rel="noopener">示例代码</a> 欢迎 Star </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Eureka 服务治理</title>
    <url>/2018/03/20/Spring-Cloud-Eureka-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    <content><![CDATA[<p>Spring Cloud Eureka 是对 Netflix Eureka 的二次封装，增加了 Spring Boot 风格的自动化配置，只需简单地引入依赖和注解就能提供完整的服务注册和服务发现。</p>
<a id="more"></a>
<h2 id="服务中心"><a href="#服务中心" class="headerlink" title="服务中心"></a>服务中心</h2><p>服务中心又称注册中心，集中式地管理各个服务的注册和发现。</p>
<p>在服务较多、每个服务又多份部署的的情况下，手动管理服务间的调用关系既麻烦又容易出错，其中一个服务改动，就会牵连好几个服务跟着重启。</p>
<p>在包含服务中心的微服务体系中，每个服务都将自身的信息注册到服务中心，各个服务间的调用都需要通过服务中心来调用，服务间调用关系有服务中心来统一管理。</p>
<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka 采用 C-S 设计架构，Eureka Server 作为服务注册、发现的服务器，系统中其他服务使用 Eureka Client 连接到 Eureka Server 并维持心跳。</p>
<h3 id="Eureka-Server-实践"><a href="#Eureka-Server-实践" class="headerlink" title="Eureka-Server 实践"></a>Eureka-Server 实践</h3><h4 id="1-添加-Eureka-服务端依赖"><a href="#1-添加-Eureka-服务端依赖" class="headerlink" title="1.添加 Eureka 服务端依赖"></a>1.添加 Eureka 服务端依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-使用注解启用-Eureka-Server"><a href="#2-使用注解启用-Eureka-Server" class="headerlink" title="2.使用注解启用 Eureka Server"></a>2.使用注解启用 Eureka Server</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.eurekaserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-添加-Eureka-相关配置"><a href="#3-添加-Eureka-相关配置" class="headerlink" title="3.添加 Eureka 相关配置"></a>3.添加 Eureka 相关配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port=8761</span><br><span class="line">spring.application.name=eureka-server</span><br><span class="line"></span><br><span class="line"># 多节点部署时各节点 url 用逗号分隔</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/,http://localhost:8762/eureka/</span><br><span class="line"></span><br><span class="line"># 关闭自我保护</span><br><span class="line"># 如 15 分钟内统计的心跳失败比例超过 85%，Eureka 会将所有实例信息保护起来，单机调试很容易出发保护机制</span><br><span class="line"># eureka.server.enable-self-preservation=false</span><br><span class="line"></span><br><span class="line"># 不向注册中间检索服务</span><br><span class="line"># eureka.client.fetch-registry=false</span><br><span class="line"></span><br><span class="line"># 不向注册中心注册自己</span><br><span class="line"># eureka.client.register-with-eureka=false</span><br></pre></td></tr></table></figure>
<h3 id="Eureka-Client-实践"><a href="#Eureka-Client-实践" class="headerlink" title="Eureka-Client 实践"></a>Eureka-Client 实践</h3><h4 id="1-添加-eureka-客户端依赖"><a href="#1-添加-eureka-客户端依赖" class="headerlink" title="1.添加 eureka 客户端依赖"></a>1.添加 eureka 客户端依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-使用注解启用-Eureka-Client"><a href="#2-使用注解启用-Eureka-Client" class="headerlink" title="2.使用注解启用 Eureka Client"></a>2.使用注解启用 Eureka Client</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.eurekaclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-添加-Eureka-相关配置-1"><a href="#3-添加-Eureka-相关配置-1" class="headerlink" title="3.添加 Eureka 相关配置"></a>3.添加 Eureka 相关配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=eureka-client</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line"></span><br><span class="line"># 服务续约任务调用间隔，默认为30秒</span><br><span class="line"># eureka.instance.lease-renewal-interval-in-seconds=20</span><br><span class="line"></span><br><span class="line"># 服务失效时间，默认为90秒</span><br><span class="line"># eureka.instance.lease-expiration-duration-in-seconds=60</span><br><span class="line"></span><br><span class="line"># 服务获取任务调用间隔，默认为30秒</span><br><span class="line"># eureka.client.registry-fetch-interval-seconds=20</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Ulyssesss/spring-cloud-example" target="_blank" rel="noopener">示例代码</a> 欢迎 Star</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Feign 声明式服务调用</title>
    <url>/2018/04/13/Spring-Cloud-Feign-%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>在微服务的实践过程中，Spring Cloud Ribbon 和 Spring Cloud Hystrix 通常一起使用。</p>
<p>Spring Cloud Feign 是对这两个基础工具的更高层次封装，在 Netflix Feign 的基础上扩展了对 Spring MVC 的注解支持，提供了一种声明式的 Web 服务客户端定义方式。</p>
<a id="more"></a>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>启动服务注册中心 eureka-server 及服务提供方 hello-service，创建 spring boot 工程 feign-consumer。</p>
<h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-注解启用-Feign"><a href="#2-注解启用-Feign" class="headerlink" title="2.注解启用 Feign"></a>2.注解启用 Feign</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.feignconsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.feign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-定义-HelloService-接口"><a href="#3-定义-HelloService-接口" class="headerlink" title="3.定义 HelloService 接口"></a>3.定义 HelloService 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.feignconsumer.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.feign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"hello-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"p1"</span>)</span> String p1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"p2"</span>)</span> String p2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 @FeignClient 指定服务名，Spring MVC 注解绑定具体的 REST 接口及请求参数。</p>
<p>注意在定义参数绑定时，@RequestParam 、@RequestHeader 等注解的 value 不能省略，Spring MVC 会根据参数名作为默认值，但 Feign 中必须通过 value 指定。</p>
<h3 id="4-编写-Controller"><a href="#4-编写-Controller" class="headerlink" title="4.编写 Controller"></a>4.编写 Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.feignconsumer.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.feignconsumer.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String p1, @RequestParam String p2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"feign consumer get hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> helloService.hello(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-配置服务注册中心地址"><a href="#5-配置服务注册中心地址" class="headerlink" title="5.配置服务注册中心地址"></a>5.配置服务注册中心地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=feign-consumer</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure>
<p>启动全部应用，访问 <a href="http://localhost:8080/hello?p1=a&amp;p2=b" target="_blank" rel="noopener">http://localhost:8080/hello?p1=a&amp;p2=b</a> ，feign-consumer 以声明式的服务调用访问 hello-service，返回 <code>hello, a, b</code> 。</p>
<h2 id="继承特性"><a href="#继承特性" class="headerlink" title="继承特性"></a>继承特性</h2><p>当使用 Spring MVC 注解来绑定服务接口时，几乎可以完全从服务提供方的 Controller 中复制，所以能够利用 Feign 的继承特性做进一步抽象，复用 REST 接口定义，减少编码量。</p>
<h3 id="1-添加依赖-1"><a href="#1-添加依赖-1" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><p>创建 Maven 工程 hello-service-api，由于需要用到 Spring MVC 的注解，所以添加 spring-boot-starter-web 依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-定义接口及-DTO"><a href="#2-定义接口及-DTO" class="headerlink" title="2.定义接口及 DTO"></a>2.定义接口及 DTO</h3><p>在 hello-service-api 中定义能够复用的 DTO 和接口定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.helloserviceapi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.helloserviceapi.dto.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"p1"</span>)</span> String p1, @<span class="title">RequestParam</span><span class="params">(<span class="string">"p2"</span>)</span> String p2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function">User <span class="title">user</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"post"</span>)</span><br><span class="line">    <span class="function">String <span class="title">post</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.helloserviceapi.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-改写-hello-service"><a href="#3-改写-hello-service" class="headerlink" title="3.改写 hello-service"></a>3.改写 hello-service</h3><p>在 hello-service 中引入 hello-service-api 依赖，重写 HelloController。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.helloservice.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.helloserviceapi.dto.User;</span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.helloserviceapi.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String p1, @RequestParam String p2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello service get hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, "</span> + p1 + <span class="string">", "</span> + p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello service get user"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"Jack"</span>, <span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello service post"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"post"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-改写-feign-consumer"><a href="#4-改写-feign-consumer" class="headerlink" title="4.改写 feign-consumer"></a>4.改写 feign-consumer</h3><p>在 feign-consumer 中引入 hello-service-api 依赖，创建 RefactorHelloService 继承自 HelloService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.feignconsumer.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.helloserviceapi.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.feign.FeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RefactorHelloService</span> <span class="keyword">extends</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 FeignConsumerController，注入 RefactorHelloService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.feignconsumer.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.feignconsumer.service.RefactorHelloService;</span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.helloserviceapi.dto.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RefactorHelloService refactorHelloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String p1, @RequestParam String p2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"feign consumer get hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> refactorHelloService.hello(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"feign consumer get user"</span>);</span><br><span class="line">        <span class="keyword">return</span> refactorHelloService.user();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"post"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"feign consumer post"</span>);</span><br><span class="line">        <span class="keyword">return</span> refactorHelloService.post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动全部应用，访问 <a href="http://localhost:8080/hello?p1=a&amp;p2=b" target="_blank" rel="noopener">http://localhost:8080/hello?p1=a&amp;p2=b</a> ，feign-consumer 以声明式的服务调用访问 hello-service，返回 <code>hello, a, b</code> 。</p>
<p>使用 Spring Cloud Feign 的继承特性，可以将接口从 Controller 中玻璃，配合 Maven 私有仓库可以实现接口定义的共享，减少服务消费方的绑定配置。</p>
<h2 id="Ribbon-及-Hystrix-配置"><a href="#Ribbon-及-Hystrix-配置" class="headerlink" title="Ribbon 及 Hystrix 配置"></a>Ribbon 及 Hystrix 配置</h2><p>Spring Cloud Feign 的客户端负载均衡通过 Spring Cloud Ribbon 实现，通过配置 Ribbon 可以定义客户端调用参数。Ribbon 和 Hystrix 的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=feign-consumer</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line"></span><br><span class="line">## 启用 hystrix</span><br><span class="line">feign.hystrix.enabled=true</span><br><span class="line">## 全局超时熔断时间</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000</span><br><span class="line"></span><br><span class="line">## 全局连接超时时间</span><br><span class="line">ribbon.ConnectTimeout=250</span><br><span class="line">## 全局接口调用超时时间</span><br><span class="line">ribbon.ReadTimeout=10000</span><br><span class="line">## 全局重试所有请求（POST 请求等）开关</span><br><span class="line">ribbon.OkToRetryOnAllOperations=false</span><br><span class="line"></span><br><span class="line">## 针对 hello-service 服务，重试切换的实例数</span><br><span class="line">hello-service.ribbon.MaxAutoRetriesNextServer=1</span><br><span class="line">## 针对 hello-service 服务，对当前实例重试次数</span><br><span class="line">hello-service.ribbon.MaxAutoRetries=0</span><br></pre></td></tr></table></figure>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>Hystrix 提供的服务降级是容错的重要方法，由于 Feign 在定义服务客户端时将 HystrixCommand 的定义进行了封装，导致无法使用 @HystrixCommand 的 fallback 参数指定降级逻辑。</p>
<p>Spring Cloud Feign 提供了一种简单的定义服务降级的方式，创建 HelloServiceFallback 实现 HelloService 接口，通过 @Component 声明为 Bean，在 HelloServiceFallback 中实现具体的降级逻辑，最后在 @FeignClient 中通过 fallback 属性声明处理降级逻辑的 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.feignconsumer.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.helloserviceapi.dto.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceFallback</span> <span class="keyword">implements</span> <span class="title">RefactorHelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String p1, String p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"error"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.feignconsumer.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.helloserviceapi.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.feign.FeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"hello-service"</span>, fallback = HelloServiceFallback.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RefactorHelloService</span> <span class="keyword">extends</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务后断开服务提供方 hello-service，访问 feign-consumer 接口，feign-consumer 会按照 HelloServiceFallback 中的定义执行降级逻辑。</p>
<p><a href="https://github.com/Ulyssesss/spring-cloud-example" target="_blank" rel="noopener">示例代码</a> 欢迎 Star</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Ribbon 客户端负载均衡</title>
    <url>/2018/03/21/Spring-Cloud-Ribbon-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的客户端负载均衡工具。</p>
<p>Spring Cloud Ribbon 在单独使用时，可以通过在客户端中配置 ribbonServerList 来指定服务实例列表，通过轮训访问的方式起到负载均衡的作用。</p>
<p>在与 Eureka 联合使用时，ribbonServerList 会被重写，改为通过 Eureka 服务注册中心获取服务实例列表，可以通过简单的几行配置完成 Spring Cloud 中服务调用的负载均衡。</p>
<a id="more"></a>
<h2 id="负载均衡实践"><a href="#负载均衡实践" class="headerlink" title="负载均衡实践"></a>负载均衡实践</h2><p>在实践客户端负载均衡之前，首先构建并启动 eureka-server，作为服务注册中心。</p>
<p>然后创建 hello-service 作为服务提供方，启动两个实例，分别注册到 eureka-server。</p>
<p>完成以上步骤之后开始构建具有负载均衡功能的服务消费方 ribbon-consumer。</p>
<h3 id="1-添加相关依赖"><a href="#1-添加相关依赖" class="headerlink" title="1.添加相关依赖"></a>1.添加相关依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-启用服务发现客户端，声明负载均衡的-restTemplate"><a href="#2-启用服务发现客户端，声明负载均衡的-restTemplate" class="headerlink" title="2.启用服务发现客户端，声明负载均衡的 restTemplate"></a>2.启用服务发现客户端，声明负载均衡的 restTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.ribbonconsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RibbonConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-添加配置注册到服务中心"><a href="#3-添加配置注册到服务中心" class="headerlink" title="3. 添加配置注册到服务中心"></a>3. 添加配置注册到服务中心</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=ribbon-consumer</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure>
<h3 id="4-编写-Controller-向-hello-service-发起请求"><a href="#4-编写-Controller-向-hello-service-发起请求" class="headerlink" title="4.编写 Controller 向 hello-service 发起请求"></a>4.编写 Controller 向 hello-service 发起请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.ribbonconsumer.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.ribbonconsumer.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_SERVICE = <span class="string">"HTTP://hello-service/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return restTemplate.getForObject(HELLO_SERVICE + "hello", String.class);</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(HELLO_SERVICE + <span class="string">"/hello"</span>, String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">(@RequestParam <span class="keyword">int</span> id, @RequestParam String name)</span> </span>&#123;</span><br><span class="line">        User user = restTemplate.getForObject(HELLO_SERVICE + <span class="string">"user?id=&#123;1&#125;&amp;name=&#123;2&#125;"</span>, User.class, id, name);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"post-user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(HELLO_SERVICE + <span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="number">666</span>, <span class="string">"AAA"</span>), String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动 eureka-server、两个 hello-service 实例和 ribbon-consumer 后，多次访问 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> ，可以观察到 ribbon-consumer 通过负载均衡的 restTemplate 轮训地向两个 hello-service 发起请求。</p>
<p><a href="https://github.com/Ulyssesss/spring-cloud-example" target="_blank" rel="noopener">示例代码</a> 欢迎 Star</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Zuul 网关（一）</title>
    <url>/2018/04/17/Spring-Cloud-Zuul-%E7%BD%91%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>利用之前提到的微服务组件，已经可以建立起一个简单的微服务系统：</p>
<ul>
<li>通过 Spring Cloud Eureka 实现高可用服务注册中心</li>
<li>通过 Spring Cloud Ribbon 或 Feign 实现服务间负载均衡的接口调用</li>
<li>通过 Spring Cloud Hystrix 实现线程隔离和熔断，防止故障扩散</li>
</ul>
<a id="more"></a>
<p>但是由于在微服务架构中，后端服务往往不直接开放给外部程序调用，所以需要一个 API 网关，根据请求的 Url 路由到相应的服务。API 网关负责外部应用到微服务系统之间的请求路由、负载均衡和校验过滤等功能的实现。</p>
<p>在 Spring Cloud 体系中，Spring Cloud Zuul 组件提供 API 网关的支持。</p>
<p>Spring Cloud Zuul 将自身注册为 Eureka 服务治理下的应用，从 Eureka 中获取服务实例信息，从而维护路由规则和服务实例。</p>
<p>同时， Zuul 提供了一套过滤器机制，通过创建过滤器对校验过滤提供支持，可以使微服务应用更专注于业务逻辑的开发。</p>
<h2 id="网关实践"><a href="#网关实践" class="headerlink" title="网关实践"></a>网关实践</h2><p>在实现网关服务的功能之前，需要搭建几个用于路由和过滤使用的微服务应用，之后就可以着手网关的构建。</p>
<h3 id="1-添加相关依赖"><a href="#1-添加相关依赖" class="headerlink" title="1.添加相关依赖"></a>1.添加相关依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-通过注解启用网关功能"><a href="#2-通过注解启用网关功能" class="headerlink" title="2.通过注解启用网关功能"></a>2.通过注解启用网关功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.apigateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-配置路由规则"><a href="#3-配置路由规则" class="headerlink" title="3.配置路由规则"></a>3.配置路由规则</h3><p>Zuul 可以按传统路由方式进行配置，<code>zuul.routes.&lt;route&gt;.path</code> 配置匹配规则，<code>zuul.routes.&lt;route&gt;.url</code> 配置服务地址，其中 \&lt;route> 为路由名称，可以任意指定。</p>
<p>按下方配置启动应用，访问 <a href="http://localhost:5555/hello-service/hello" target="_blank" rel="noopener">http://localhost:5555/hello-service/hello</a> 会转发到 <a href="http://localhost:8081/hello" target="_blank" rel="noopener">http://localhost:8081/hello</a> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 服务名称、端口号、服务注册中心地址</span><br><span class="line">spring.application.name=api-gateway</span><br><span class="line">server.port=5555</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line"></span><br><span class="line">## 传统路由单实例配置</span><br><span class="line">zuul.routes.hello-service.path=/hello-service/**</span><br><span class="line">zuul.routes.hello-service.url=http://localhost:8081/</span><br></pre></td></tr></table></figure>
<p>按传统路由方式进行多服务实例配置时，需关闭负载均衡和 Eureka 的结合，通过配置 Ribbon 的服务列表进行负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 传统路由多实例配置</span><br><span class="line">zuul.routes.hello-service.path=/hello-service/**</span><br><span class="line">zuul.routes.hello-service.service-id=hello-service</span><br><span class="line">ribbon.eureka.enabled=false</span><br><span class="line">hello-service.ribbon.listOfServers=http://localhost:8081/,http://localhost:8082/</span><br></pre></td></tr></table></figure>
<p>传统配置方式需要花费大量时间维护 path 和 url 的关系，在与 Eureka 结合后，可以通过服务发现机制自动维护映射关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 面向服务的路由</span><br><span class="line">zuul.routes.hello-service.path=/hello-service/**</span><br><span class="line">zuul.routes.hello-service.service-id=hello-service</span><br><span class="line"></span><br><span class="line">## 面向服务路由的简介配置</span><br><span class="line">## zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</span><br><span class="line">zuul.routes.feign-consumer=/feign-consumer/**</span><br></pre></td></tr></table></figure>
<p>由于大部分的路由配置规则都会采用服务名作为外部请求的前缀，所以 Spring Cloud Zuul 为 Eureka 中的每一个服务都自动创建一个默认的路由规则，如同上面的面上服务的路由。要排除指定服务的默认规则，需要添加如下配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 排除指定服务的默认规则</span><br><span class="line">zuul.ignored-services=hello-service,feign-consumer</span><br><span class="line"></span><br><span class="line">## 关闭所有服务的默认规则</span><br><span class="line">#zuul.ignored-services=*</span><br></pre></td></tr></table></figure>
<p>以上全部配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=api-gateway</span><br><span class="line">server.port=5555</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line"></span><br><span class="line">## 传统路由单实例配置</span><br><span class="line">#zuul.routes.hello-service.path=/hello-service/**</span><br><span class="line">#zuul.routes.hello-service.url=http://localhost:8081/</span><br><span class="line"></span><br><span class="line">## 传统路由多实例配置</span><br><span class="line">#zuul.routes.hello-service.path=/hello-service/**</span><br><span class="line">#zuul.routes.hello-service.service-id=hello-service</span><br><span class="line">#ribbon.eureka.enabled=false</span><br><span class="line">#hello-service.ribbon.listOfServers=http://localhost:8081/,http://localhost:8082/</span><br><span class="line"></span><br><span class="line">## 面向服务的路由</span><br><span class="line">## zuul.routes.&lt;route&gt;.path 指定请求路径</span><br><span class="line">## zuul.routes.&lt;route&gt;.serviceId 指定服务名称</span><br><span class="line">## &lt;route&gt; 为路由名称，可任意指定</span><br><span class="line">#zuul.routes.hello-service.path=/hello-service/**</span><br><span class="line">#zuul.routes.hello-service.service-id=hello-service</span><br><span class="line"></span><br><span class="line">## 面向服务路由的简洁配置</span><br><span class="line">## zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</span><br><span class="line">#zuul.routes.feign-consumer=/feign-consumer/**</span><br><span class="line"></span><br><span class="line">## 外部请求前缀作为服务名为 zuul 默认规则，上方面向服务路由其实都可以省略</span><br><span class="line"></span><br><span class="line">## 排除指定服务的默认规则</span><br><span class="line">#zuul.ignored-services=hello-service,feign-consumer</span><br><span class="line"></span><br><span class="line">## 关闭默认规则</span><br><span class="line">#zuul.ignored-services=*</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Ulyssesss/spring-cloud-example" target="_blank" rel="noopener">示例代码</a> 欢迎 Star </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Hystrix 容错保护</title>
    <url>/2018/04/09/Spring-Cloud-Hystrix-%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<p>在微服务架构中，系统被拆分成很多个服务单元，各个服务单元的应用通过 HTTP 相互调用、依赖。</p>
<p>在某个服务由于网络或其他原因自身出现故障、延迟时，调用方也会出现延迟。若调用方请求不断增加，可能会形成任务积压，最终导致调用方服务瘫痪，服务不可用现象逐渐放大。</p>
<a id="more"></a>
<h2 id="Spring-Cloud-Hystrix"><a href="#Spring-Cloud-Hystrix" class="headerlink" title="Spring Cloud Hystrix"></a>Spring Cloud Hystrix</h2><p>针对上述问题，Spring Cloud Hystrix 实现了一系列服务保护措施，从而实现服务降级、服务熔断等功能，对延迟和故障提供强大的容错能力。</p>
<p>Hystrix 有以下主要特性：</p>
<ul>
<li>服务熔断</li>
</ul>
<blockquote>
<p>Hystrix 会记录各个服务的请求信息，通过 <code>成功</code>、<code>失败</code>、<code>拒绝</code>、<code>超时</code> 等统计信息判断是否打开断路器，将某个服务的请求进行熔断。一段时间后切换到半开路状态，如果后面的请求正常则关闭断路器，否则继续打开断路器。</p>
</blockquote>
<ul>
<li>服务降级</li>
</ul>
<blockquote>
<p>服务降级是请求失败时的后备方法，故障时执行降级逻辑。</p>
</blockquote>
<ul>
<li>线程隔离</li>
</ul>
<blockquote>
<p>Hystrix 通过线程池实现资源的隔离，确保对某一服务的调用在出现故障时不会对其他服务造成影响。</p>
</blockquote>
<h2 id="容错实践"><a href="#容错实践" class="headerlink" title="容错实践"></a>容错实践</h2><p>首先启动之前提到的服务注册中心 eureka-server、服务提供方 hello-service 和服务消费放 ribbon-consumer，然后改造 ribbon-consumer 使其具备容错能力。</p>
<h3 id="1-添加相关依赖"><a href="#1-添加相关依赖" class="headerlink" title="1.添加相关依赖"></a>1.添加相关依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-配置-hystrix-超时时间"><a href="#2-配置-hystrix-超时时间" class="headerlink" title="2.配置 hystrix 超时时间"></a>2.配置 hystrix 超时时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=ribbon-consumer</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br><span class="line"></span><br><span class="line"># hystrix command 请求执行超时进入降级逻辑</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=1000</span><br></pre></td></tr></table></figure>
<h3 id="3-编写-service-完成服务调用"><a href="#3-编写-service-完成服务调用" class="headerlink" title="3.编写 service 完成服务调用"></a>3.编写 service 完成服务调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.ribbonconsumer.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.ribbonconsumer.exception.NotFallbackException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_SERVICE = <span class="string">"http://hello-service/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>, ignoreExceptions = &#123;NotFallbackException.class&#125;</span><br><span class="line">            , groupKey = <span class="string">"hello"</span>, commandKey = <span class="string">"str"</span>, threadPoolKey = <span class="string">"helloStr"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String p1, String p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(HELLO_SERVICE + <span class="string">"hello"</span>, String.class, p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helloFallback</span><span class="params">(String p1, String p2, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"class: "</span> + e.getClass());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error, "</span> + p1 + <span class="string">", "</span> + p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 fallbackMethod 指定处理降级逻辑的方法，ignoreExceptions 指定不执行降级逻辑的异常，groupKey、commandKey 作为命令统计的分组及命令名称，threadPoolKey 用于指定线程池的划分。</p>
<h3 id="4-Controller-通过-HelloService-完成请求"><a href="#4-Controller-通过-HelloService-完成请求" class="headerlink" title="4.Controller 通过 HelloService 完成请求"></a>4.Controller 通过 HelloService 完成请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.ribbonconsumer.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ulyssesss.ribbonconsumer.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String p1, @RequestParam String p2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> helloService.hello(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调整-hello-service-使其便于测试"><a href="#5-调整-hello-service-使其便于测试" class="headerlink" title="5.调整 hello-service 使其便于测试"></a>5.调整 hello-service 使其便于测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.helloservice.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String p1, @RequestParam String p2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sleepTime = <span class="keyword">new</span> Random().nextInt(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello sleep "</span> + sleepTime);</span><br><span class="line">        Thread.sleep(sleepTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, "</span> + p1 + <span class="string">", "</span> + p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述步骤后启动应用，访问 <a href="http://localhost:8080/hello?p1=1&amp;p2=2" target="_blank" rel="noopener">http://localhost:8080/hello?p1=1&amp;p2=2</a> ，正常情况下响应为 <code>hello, 1, 2</code> ，关闭 hello-service 或在 sleepTime 超过 1000ms 时，执行降级逻辑，返回 <code>error, 1, 2</code> 。</p>
<p><a href="https://github.com/Ulyssesss/spring-cloud-example" target="_blank" rel="noopener">示例代码</a> 欢迎 Star</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Zuul 网关（二）</title>
    <url>/2018/04/20/Spring-Cloud-Zuul-%E7%BD%91%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>上篇文章 <a href="http://blog.ulyssesss.com/2018/04/17/Spring-Cloud-Zuul-%E7%BD%91%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89/">Spring Cloud Zuul 网关（一）</a> 介绍了 Spring Cloud Zuul 的基本使用方法，本篇文章会对 Zuul 的过滤器机制、hystrix 及 ribbon 支持做进一步介绍。</p>
<a id="more"></a>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Zuul 中的过滤器负责在转发外部请求的过程中对处理过程进行干预，在实际运行时，路由映射和请求转发等步骤都是由不同的过滤器完成。</p>
<p>Spring Cloud Zuul 中的过滤器包含以下 4 个基本特征：</p>
<ul>
<li>过滤类型</li>
</ul>
<blockquote>
<p>过滤器所处的生命周期，Zuul 默认定义了 4 种不同生命周期，分别为 pre（请求被路由前调用）、routing（在路由请求时被调用）、post（在 routing 和 error 过滤器之后被调用） 和 error（发生错误时被调用）。</p>
</blockquote>
<ul>
<li>执行顺序</li>
</ul>
<blockquote>
<p>过滤器执行顺序，数值越小优先级越高</p>
</blockquote>
<ul>
<li>执行条件</li>
</ul>
<blockquote>
<p>通过返回的 boolean 值判断过滤是否执行</p>
</blockquote>
<ul>
<li>具体操作</li>
</ul>
<blockquote>
<p>过滤器的具体逻辑</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>外部 HTTP 请求到达网关直到返回请求结果的整个生命周期如图：</p>
<p><img src="http://image.ulyssesss.com/201804201.png" alt="生命周期"></p>
<p>请求到达网关时首先被 pre 类型的过滤器处理，主要目的是在请求路由前做一些请求校验等前置加工。</p>
<p>完成 pre 阶段后进入 routing 请求转发阶段，将外部请求转发到具体服务实例。</p>
<p>routing 之后进入 post，此阶段过滤器不仅可以获取请求信息，还能获得服务实例返回的信息，做一些加工处理。</p>
<p>error 在上述三个阶段发生异常时出发，最后还是流向 post 类型的过滤器。</p>
<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>Zuul 允许通过定义过滤器实现对请求的拦截和过滤，实现时只需继承 ZuulFilter 抽象类并实现抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.apigateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.ZuulFilter;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.context.RequestContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);<span class="comment">//过滤请求，不对其进行路由</span></span><br><span class="line">            ctx.setResponseBody(<span class="string">"error token"</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 AccessFilter 过滤器后重新启动，向 api-gateway 发起请求，请求包含 token 参数时响应正常，不包含 token 参数时返回 error token，响应码 401。</p>
<h2 id="Ribbon-和-Hystrix-支持"><a href="#Ribbon-和-Hystrix-支持" class="headerlink" title="Ribbon 和 Hystrix 支持"></a>Ribbon 和 Hystrix 支持</h2><p>spring-cloud-starter-zuul 包含对 spring-cloud-starter-ribbon 和 spring-cloud-starter-hystrix 模块的依赖，天然拥有线程隔离和断路器的自我保护功能。</p>
<p>需要注意的是通过传统路由方式配置时不会受到保护，也没有负载均衡能力。只有通过服务路由才会有自我保护和负载均衡的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 指定路由请求转发的超时时间</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000</span><br><span class="line"></span><br><span class="line">## 指定路由转发请求创建连接的超时时间</span><br><span class="line">ribbon.ConnectTimeout=250</span><br><span class="line"></span><br><span class="line">## 指定路由转发请求处理过程的超时时间</span><br><span class="line">ribbon.ReadTimeout=1000</span><br></pre></td></tr></table></figure>
<p>Zuul 在默认配置下请求异常时不会发起重试，如需开启重试功能，首先需要添加 spring-retry 依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加依赖后针对重试添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 全局重试机制开关</span><br><span class="line">zuul.retryable=true</span><br><span class="line"></span><br><span class="line">## 关闭指定路由的重试机制</span><br><span class="line">## zuul.routes.&lt;route&gt;.retryable</span><br><span class="line">zuul.routes.hello-service.retryable=false</span><br><span class="line"></span><br><span class="line">## 对当前服务实例的重试次数</span><br><span class="line">ribbon.MaxAutoRetries=2</span><br><span class="line">## 重试切换的实例数</span><br><span class="line">ribbon.MaxAutoRetriesNextServer=0</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Ulyssesss/spring-cloud-example" target="_blank" rel="noopener">示例代码</a> 欢迎 Star </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 简介</title>
    <url>/2018/03/10/Spring-Cloud-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Spring Cloud 是一些列框架的集合，基于 Spring Boot，是实现微服务的一整套解决方案。</p>
<p>Spring Cloud 为微服务中涉及的配置管理、服务治理、负载均衡、断路器、消息总线、数据监控等提供了一种简单的开发方式，降低了构建大型系统的要求，能以较低的成本搭建出一套高效、分布式、容错的平台。</p>
<a id="more"></a>
<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务是系统架构的一种设计风格，主旨是将原本独立的系统拆分为多个小型服务。</p>
<p>每个服务维护着自身的数据存储、业务开发、自动化测试案例及部署机制，能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p>
<h2 id="为什么要采用微服务"><a href="#为什么要采用微服务" class="headerlink" title="为什么要采用微服务"></a>为什么要采用微服务</h2><p>相比于单体应用，微服务具有如下优势：</p>
<ul>
<li>独立开发</li>
<li>独立部署</li>
<li>独立伸缩性</li>
<li>可重用</li>
<li>更好的容错</li>
<li>技术选型灵活</li>
</ul>
<h2 id="微服务面临的挑战"><a href="#微服务面临的挑战" class="headerlink" title="微服务面临的挑战"></a>微服务面临的挑战</h2><ul>
<li>开发复杂性增加（可能会依赖于其他服务）</li>
<li>运维复杂性增加</li>
<li>对技术的要求高</li>
<li>现实界限不清晰导致服务拆分困难</li>
<li>分布式事务</li>
<li>性能（服务间通过 HTTP 协议通信）</li>
</ul>
<h2 id="为什么要选择-Spring-Cloud"><a href="#为什么要选择-Spring-Cloud" class="headerlink" title="为什么要选择 Spring Cloud"></a>为什么要选择 Spring Cloud</h2><ul>
<li>产出于 Spring 大家族</li>
<li>基于 Spring Boot，简化开发</li>
<li>提供一站式的解决方案，覆盖面广</li>
<li>社区活跃度很高，教程丰富</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 故障处理与注意事项</title>
    <url>/2018/05/04/ZooKeeper-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>为了有效使用 ZooKeeper，需要了解 ZooKeeper 可能发生的故障种类及处理方式。</p>
<a id="more"></a>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>当客户端从 ZooKeeper 服务端获取响应时，可以肯定这个响应信息与其他响应信息能够保持一致性。而在连接丢失等无法保证一致性的情况下，客户端会使用 Disconnected 事件和 ConnectionLossException 异常来表示异常状态。</p>
<p>出现上述情况时，ZooKeeper 客户端会不断尝试连接到另一个 ZooKeeper 服务器，直到最终重新建立会话。会话重新建立会产生 SyncConnected 事件，开始处理请求，注册之前已经注册的监视点，并对失去连接这段时间的数据变更产生监视点事件。</p>
<p>如果发生异常时没有正在进行的请求，则对客户端几乎没有影响；如果存在正在进行的请求，就需要认真处理异常状况。</p>
<p>对于异常时正在进行的请求，比如 create 操作，客户端无法通过异常信息判断请求是否被处理，需要在重新建立连接后先获取节点状态，再根据节点状态选择是否重新执行 create 操作，而不能直接简单地重复操作。</p>
<h2 id="故障导致-exists-监视点丢失事件"><a href="#故障导致-exists-监视点丢失事件" class="headerlink" title="故障导致 exists 监视点丢失事件"></a>故障导致 exists 监视点丢失事件</h2><p>ZooKeeper 在故障重连后，对于数据没有发生变更的监视点会重新注册，对已经发生变化的节点产生监视点事件，但存在一种情况会错误监视点事件 —— exists 监视点。</p>
<p>exists 操作比较特殊，是对一个不存在的监视点设置监视点，如果在连接断开期间所监视的节点被创建然后删除，待重新连接后，没有发现这个节点，所以只是重新注册，并不会产生监视点事件。</p>
<p>因为这种特殊情况，所以要尽量避免监视一个 znode 节点的创建事件，如果一定要监视创建事件，应该尽量监视存活期较长的 znode 节点。</p>
<h2 id="群首选举与外部资源"><a href="#群首选举与外部资源" class="headerlink" title="群首选举与外部资源"></a>群首选举与外部资源</h2><p>ZooKeeper 为所有客户端提供了系统的一致性视图，客户端与 ZooKeeper 的任何交互操作，ZooKeeper 都会保持同步，但 ZooKeeper 无法保护与外部设备的交互操作。</p>
<p>比如多个客户端通过群首选举让主节点持有外部资源的情况：客户端 A 首先称为主节点持有节点，但因为线程调度等原因（比如持续较长时间的垃圾回收），ZooKeeper 判断与 A 会话中止，重新选举客户端 B 为主节点并持有外部资源，待 A 恢复正常时发送已经队列化的更新到外部资源，损害系统状态。</p>
<p>为了解决上述问题，可以尽量确保应用不会在超载或时钟偏移的环境中运行，另外可以通过 ZooKeeper 来扩展对外部设备协作的数据，比如使用隔离符号。简单的隔离符号比如 只有持有最新符号的客户端才能访问资源，对外部资源进行访问时，客户端需要提供隔离符号，如果外部资源在之前已经接收过更高版本的符号，访问就会被拒绝。</p>
<h2 id="数据字段和子节点限制"><a href="#数据字段和子节点限制" class="headerlink" title="数据字段和子节点限制"></a>数据字段和子节点限制</h2><p>ZooKeeper 默认对数据字段的传输限制为 1MB，该限制为任意节点数据的最大存储字节数，同时也限制任意父节点可以拥有的子节点数。</p>
<p>ZooKeeper 默认的限制值已经足够大，需要避免接近该限制值的使用。如果有特殊用途可以通过修改配置调整限制值。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 使用 Java API</title>
    <url>/2018/05/03/ZooKeeper-%E4%BD%BF%E7%94%A8-Java-API/</url>
    <content><![CDATA[<p>zkCli 工具适用于调试，不推荐使用 zkCli 工具来搭建系统。</p>
<p>实际开发时一般也不直接使用 ZooKeeper 的 Java API，而是使用更高层次的封装库 Curator，不过对 Java API 的学习仍然有很多益处。</p>
<p>本篇文章介绍通过 ZooKeeper 的 Java API 来实现创建会话、实现监视点等功能，演示主从模式。</p>
<a id="more"></a>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="建立会话"><a href="#建立会话" class="headerlink" title="建立会话"></a>建立会话</h2><p>启动 ZooKeeper 服务端，通过 Java API 建立会话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher)</span><br></pre></td></tr></table></figure>
<p>其中 connectString 包含主机名及端口号，sessionTimeout 为会话超时时间，watcher 对象用于接收会话事件。</p>
<p>Watcher 为一个接口，实现 Watcher 需要重写 <code>void process(WatchedEvent event)</code> 方法。</p>
<p>当遇到网络故障时，如果连接断开，ZooKeeper 客户端会自动重新连接。</p>
<h2 id="获取管理权"><a href="#获取管理权" class="headerlink" title="获取管理权"></a>获取管理权</h2><p>下面通过 ZooKeeper Java API 来实现简单的群首选举算法，确保同一时间只有一个主节点进程处于活动状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String serviceId = Integer.toString(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLeader = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startZk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181"</span>, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopZk</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        zk.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"event: "</span> + watchedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Master master = <span class="keyword">new</span> Master();</span><br><span class="line">		master.startZk();</span><br><span class="line"></span><br><span class="line">		master.runForMaster();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"serviceId: "</span> + master.serviceId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (master.isLeader) &#123;</span><br><span class="line">            System.out.println(<span class="string">"master"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"not master"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		master.stopZk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMaster</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">                <span class="keyword">byte</span> data[] = zk.getData(<span class="string">"/master"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">                isLeader = <span class="keyword">new</span> String(data).equals(serviceId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runForMaster</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zk.create(<span class="string">"/master"</span>, serviceId.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                isLeader = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NodeExistsException e) &#123;</span><br><span class="line">                isLeader = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkMaster()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数执行创建一个演示实例，实例会分配一个随机整数作为 id，建立 ZooKeeper 连接后尝试创建主节点 master。</p>
<p>如果 master 主节点创建成功，则该实例为群首 leader；如果节点已经存在则其他实例为 leader；发生断开连接等异常时，响应信息丢失，无法确定当前进程是否为主节点，需要通过 checkMaster() 方法重新检查主节点状态。</p>
<p>多次执行主函数，其中第一次执行时会打印 master，在 master 断开连接前的 10 秒钟内，再次执行会打印 not master，当第一次执行的 master 断开连接后，再次执行主函数，打印 master。</p>
<h2 id="异步创建需要的目录"><a href="#异步创建需要的目录" class="headerlink" title="异步创建需要的目录"></a>异步创建需要的目录</h2><p>在 ZooKeeper 中所有的同步操作都有对应的异步操作，异步调用不会阻塞应用程序，还能简化应用的实现方式。</p>
<p>主从模型的设计需要用到 /tasks、/assign 和 /workers 3 个目录，可以通过某些系统配置来创建这些目录。下面的代码示例会通过异步的方式创建出所需要的目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createParent(<span class="string">"/workers"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    createParent(<span class="string">"/assign"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    createParent(<span class="string">"/tasks"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createParent</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, createParentCallback, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsyncCallback.StringCallback createParentCallback = <span class="keyword">new</span> AsyncCallback.StringCallback() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (KeeperException.Code.get(rc)) &#123;</span><br><span class="line">            <span class="keyword">case</span> OK:</span><br><span class="line">                System.out.println(<span class="string">"parent "</span> + path + <span class="string">" created"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NODEEXISTS:</span><br><span class="line">                System.out.println(<span class="string">"parent "</span> + path + <span class="string">" already registered"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONNECTIONLOSS:</span><br><span class="line">                createParent(path, (<span class="keyword">byte</span>[]) ctx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"create "</span> + path + <span class="string">" error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="注册从节点"><a href="#注册从节点" class="headerlink" title="注册从节点"></a>注册从节点</h2><p>前面的部分已经有了主节点，为了使主节点可以发号施令，现在要配置从节点，在 /workers 下创建临时节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String serviceId = Integer.toString(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startZk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181"</span>, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        zk.create(<span class="string">"/workers/worker-"</span> + serviceId, <span class="string">"Idle"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE</span><br><span class="line">                , CreateMode.EPHEMERAL, createWorkerCallback, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsyncCallback.StringCallback createWorkerCallback = <span class="keyword">new</span> AsyncCallback.StringCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (KeeperException.Code.get(rc)) &#123;</span><br><span class="line">                <span class="keyword">case</span> OK:</span><br><span class="line">                    System.out.println(<span class="string">"registered successfully: "</span> + serviceId);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NODEEXISTS:</span><br><span class="line">                    System.out.println(<span class="string">"already registered: "</span> + serviceId);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CONNECTIONLOSS:</span><br><span class="line">                    register();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">"error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        updateStatus(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status.equals(<span class="keyword">this</span>.status)) &#123;</span><br><span class="line">            zk.setData(<span class="string">"/workers/worker-"</span> + serviceId, status.getBytes(), -<span class="number">1</span>, statusUpdateCallback, status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AsyncCallback.StatCallback statusUpdateCallback = <span class="keyword">new</span> AsyncCallback.StatCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (KeeperException.Code.get(rc)) &#123;</span><br><span class="line">                <span class="keyword">case</span> CONNECTIONLOSS:</span><br><span class="line">                    updateStatus((String) ctx);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">		worker.startZk();</span><br><span class="line">		worker.register();</span><br><span class="line">		Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数创建 worker 实例，开启会话，执行注册逻辑，创建节点时如发生连接丢失则再次执行注册逻辑，注册所创建的节点为临时节点。</p>
<p>从节点开始处理某些任务时，需要通过 setStatus() 方法更新节点状态。</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>系统中 client 组件用于添加任务，以便从节点执行任务。以下为 client 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startZk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181"</span>, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">queueCommand</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String name = zk.create(<span class="string">"/tasks/task-"</span>, command.getBytes()</span><br><span class="line">                        , ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Client client = <span class="keyword">new</span> Client();</span><br><span class="line">		client.startZk();</span><br><span class="line">		String name = client.queueCommand(<span class="string">"command-1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"created "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client 使用有序节点 task- 标示任务，task- 后面会跟随一个递增整数，在执行 create 时如发生连接丢失，则重试 create 操作，适用于【至少执行一次】策略的应用。如要采用【至多执行一次】策略，可以将任务的唯一标识添加到节点名中。</p>
<h2 id="管理客户端"><a href="#管理客户端" class="headerlink" title="管理客户端"></a>管理客户端</h2><p>管理客户端 AdminClient 用于展示系统运行状态，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ulyssesss.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminClient</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startZk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181"</span>, <span class="number">5000</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listState</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">            <span class="keyword">byte</span>[] masterData = zk.getData(<span class="string">"/master"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">            Date startDate = <span class="keyword">new</span> Date(stat.getCtime());</span><br><span class="line">            System.out.println(<span class="string">"master: "</span> + <span class="keyword">new</span> String(masterData) + <span class="string">" since "</span> + startDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"no master"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"workers: \n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String worker : zk.getChildren(<span class="string">"/workers"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = zk.getData(<span class="string">"/workers/"</span> + worker, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            String state = <span class="keyword">new</span> String(data);</span><br><span class="line">            System.out.println(<span class="string">"worker: "</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		AdminClient adminClient = <span class="keyword">new</span> AdminClient();</span><br><span class="line">		adminClient.startZk();</span><br><span class="line">		adminClient.listState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会简单的列出各个节点的信息。</p>
<p>通过 Java API 编程与 zkCli 命令非常接近，不同的是 zkCli 常用于调试，一般会在一个相对稳定的环境下使用。通过 Java API 编写的程序，需要考虑到异常情况，尤其是 ConnectionLossException 异常，需要检查状态并合理恢复。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 概念与基础</title>
    <url>/2018/05/02/ZooKeeper-%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>信息飞速膨胀，很多应用无法依赖单个服务器处理庞大的数据量。由于分布式系统和应用可以提供更强的计算能力，还能更好地容灾和扩展，所以逐渐受到青睐。</p>
<p>在开发分布式应用时，通常需要花费大量时间和精力来处理异构系统中的协作通信问题。</p>
<a id="more"></a>
<h2 id="什么是-ZooKeeper"><a href="#什么是-ZooKeeper" class="headerlink" title="什么是 ZooKeeper"></a>什么是 ZooKeeper</h2><p>ZooKeeper 专注于任务协作，能为大型分布式系统提供可靠的协作处理能力，简化开发流程，让开发人员更专注于应用本身的逻辑。</p>
<p>ZooKeeper 具有 C-S 结构，在使用时，开发的应用可以看做为连接到 ZooKeeper 服务器的客户端，通过客户端 API 进行操作，保障强一致性、有序性和持久性，具有实现同步原语的能力，提供简单的并发处理机制。常见的用法如：选举主节点、崩溃检测、存储元数据等。</p>
<p>注意，ZooKeeper 不适用于海量信息存储，设计应用时最好将应用数据与协同数据分开，使用数据库、分布式文件系统等存储应用数据。</p>
<h2 id="ZooKeeper-基础"><a href="#ZooKeeper-基础" class="headerlink" title="ZooKeeper 基础"></a>ZooKeeper 基础</h2><p>由若干条指令组成，用于完成特定功能的过程称为原语。</p>
<p>为了保证灵活性，ZooKeeper 不直接提供原语，而是暴露出类似文件系统的 API，让开发人员通过 API 实现自己的原语，通常使用菜谱（ recipes ）来表示原语的实现。</p>
<p>ZooKeeper 操作和维护的为一个个数据节点，称为 znode，采用类似文件系统的层级树状结构进行管理。如果 znode 节点包含数据则存储为字节数组（byte array）。</p>
<h3 id="API-概述"><a href="#API-概述" class="headerlink" title="API 概述"></a>API 概述</h3><p>ZooKeeper 暴露如下 API：</p>
<ul>
<li><code>create /path data</code> 创建节点并包含数据</li>
</ul>
<ul>
<li><code>delete /path</code> 删除节点</li>
<li><code>exists /path</code> 检查节点是否存在</li>
<li><code>setData /path data</code> 设置节点数据</li>
<li><code>getData /path</code> 获取节点数据</li>
<li><code>getChildren /path</code> 获取子节点列表</li>
</ul>
<p>ZooKeeper 不允许局部读取或写入数据，读取时会将节点数据全部读取，写入时会整个替换。</p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>创建 znode 时需要指定节点类型，节点的类型会影响其行为方式。</p>
<p>znode 分为持久节点和临时节点。持久节点只有通过调用 delete API 才能删除；临时节点在客户端崩溃或关闭与 ZooKeeper 服务器连接时就会被删除，调用 delete API 也能删除临时节点。</p>
<p>znode 可设置为有序节点。有序节点在创建时会分配一个整数序号追加到路径之后，如创建 /tasks/task- 有序节点，追加整数后节点路径为 /tasks/task-1 。</p>
<p>综上，znode 共有 4 种类型，分别为：持久（无序）、临时（无序）、持久有序和临时有序。 </p>
<h3 id="监听通知"><a href="#监听通知" class="headerlink" title="监听通知"></a>监听通知</h3><p>ZooKeeper 通常以远程服务的方式被访问，在数据不发生变化时频繁地访问代价较大，ZooKeeper 的通知机制可以代替客户端的轮训。</p>
<p>客户端通过设置监视点（watcher）向 ZooKeeper 注册需要接收通知的 znode，在 znode 发生变化时 ZooKeeper 向客户端发送消息。</p>
<p>通知机制是单次触发的操作，如需不断监听 znode 的变化，需要在接收到 znode 变更时设置新的监视点。</p>
<p>监视点有多种类型，如监控 znode 数据变化、监控 znode 子节点变化、监控 znode 创建或删除。</p>
<h3 id="版本匹配"><a href="#版本匹配" class="headerlink" title="版本匹配"></a>版本匹配</h3><p>每个 znode 都有一个随数据变化而自增的版本号，多个写入操作会有条件的执行。写入操作会将版本号作为参数，当与服务器上版本号一致时才会调用成功，这点在多个客户端对同一个 znode 进行操作时很重要。</p>
<h3 id="仲裁模式"><a href="#仲裁模式" class="headerlink" title="仲裁模式"></a>仲裁模式</h3><p>只有一台单独的 ZooKeeper 服务器时为独立模式，状态无法复制。具有一组 ZooKeeper 服务器时为仲裁模式，仲裁模式下各个服务器间进行状态的复制，同时服务于客户端的请求。</p>
<p>仲裁模式下，如果让客户端等待所有服务器完成数据保存再继续，延迟问题就会很大，ZooKeeper 通过法定人数确定工作时必须有效运行的服务器最小数量。如果有 5 台服务器，任意 3 台服务器保存了数据，客户端就可以继续工作。其他 2 台服务器最终也会捕获到数据进行保存。</p>
<p>服务器的个数应该为奇数，如有 5 台服务器，则最多允许 2 台崩溃。假如服务器个数为偶数，允许崩溃的服务器数量不会增加，法定人数却更大，需要更多的确认操作。</p>
<h2 id="开始使用-ZooKeeper"><a href="#开始使用-ZooKeeper" class="headerlink" title="开始使用 ZooKeeper"></a>开始使用 ZooKeeper</h2><p>开始使用 ZooKeeper 之前，需要 <a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">下载 ZooKeeper 发行包</a> 。解压 tar 格式的压缩文件，bin 目录下有启动 ZooKeeper 的脚本，conf 目录下存放着 ZooKeeper 的配置文件，lib 目录下存放着一些运行所需的第三方文件。</p>
<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>在 ZooKeeper 目录下执行以下命令启动 ZooKeeper 服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> bin/zkCli.sh</span><br></pre></td></tr></table></figure>
<h3 id="列出根节点下的所有节点"><a href="#列出根节点下的所有节点" class="headerlink" title="列出根节点下的所有节点"></a>列出根节点下的所有节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /test ""</span><br><span class="line">Created /test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[zookeeper, test]</span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] delete /test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure>
<h3 id="退出客户端"><a href="#退出客户端" class="headerlink" title="退出客户端"></a>退出客户端</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] quit</span><br><span class="line">Quitting...</span><br><span class="line">2018-05-02 15:58:34,004 [myid:] - INFO  [main:ZooKeeper@684] - Session: 0x1630a0cdc400001 closed</span><br><span class="line">2018-05-02 15:58:34,006 [myid:] - INFO  [main-EventThread:ClientCnxn$EventThread@519] - EventThread shut down for session: 0x1630a0cdc400001</span><br></pre></td></tr></table></figure>
<h3 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 监视点详解</title>
    <url>/2018/05/04/ZooKeeper-%E7%9B%91%E8%A7%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>应用程序需要知道 ZooKeeper 节点状态的情况很常见，如主从模式中从节点需要知道主节点是否崩溃。</p>
<p>轮训的方式很低效，尤其是在期望变化频率很低时。</p>
<p>ZooKeeper 提供了监视点（watch）这一处理节点变化的重要机制，客户端对指定 znode 节点注册通知请求，在节点状态发生变化时就会收到一个单次的通知。</p>
<a id="more"></a>
<h2 id="单次通知"><a href="#单次通知" class="headerlink" title="单次通知"></a>单次通知</h2><p>监视点是一个单次的触发器，应用对某个节点注册了一个监视点，会在该节点第一次触发事件时向应用发送通知。</p>
<p>监视点与会话关联，当客户端与一台 ZooKeeper 服务器断开连接后，会连接到集合中另一台服务器，同时将未触发的监视列表发送到服务器。如果所监视的节点已经发生变化，会向客户端发送通知，否则会在新的服务器上注册监视点。</p>
<p>单次触发的通知可能会丢失事件，比如在收到通知、注册新的监视点之间的这段时间所发生的事件。不过丢失事件通常不会造成影响，节点变化可以通过注册新监视点时读取节点状态来捕获。</p>
<h2 id="设置监视点"><a href="#设置监视点" class="headerlink" title="设置监视点"></a>设置监视点</h2><p>ZooKeeper 中的所有读操作均可设置监视点，包括 getData、getChildren 和 exists。</p>
<p>使用监视点需要实现 Watcher 接口，重写 void process(WatchedEvent event) 方法。其中 WatchedEvent 包含 ZooKeeper 的会话状态（KeeperState）和事件类型（EventType）。</p>
<p>事件类型包括 NodeCreated、NodeDeleted、NodeDataChanged、NodeChildrenChanged 和 None。前 3 个类型涉及单个 znode 节点，第 4 个即 NodeChildrenChanged 涉及所监视节点的子节点。None 表示 ZooKeeper 会话状态发生变化。</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>设置监视点方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>NodeCreated</td>
<td>通过 exists 调用设置监视点</td>
</tr>
<tr>
<td>NodeDeleted</td>
<td>通过 exists 或 getData 调用设置监视点</td>
</tr>
<tr>
<td>NodeDataChanged</td>
<td>通过 exists 或 getData 调用设置监视点</td>
</tr>
<tr>
<td>NodeChildrenChanged</td>
<td>通过 getChildren 调用设置监视点</td>
</tr>
</tbody>
</table>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>ZooKeeper 在 3.4.0 版本添加了原子操作的特性，通过 multiop 可以原子性地执行多个 ZooKeeper 操作，这些操作要么全部成功，要么全部失败。</p>
<p>使用 multiop 时，首先创建出包含 ZooKeeper 操作的 Op 对象，再把多个 Op 对象放到 Iterable 类型的对象中供客户端调用，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Op <span class="title">deleteZnode</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Op.delete(path, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Op <span class="title">createZnode</span><span class="params">(String path, String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Op.create(path, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;OpResult&gt; results = zk.multi(Arrays.asList(deleteZnode(<span class="string">"/a"</span>), createZnode(<span class="string">"b"</span>, <span class="string">"data"</span>)));</span><br></pre></td></tr></table></figure>
<p>multi 方法同样有异步版本，同步和异步方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OpResult&gt; <span class="title">multi</span><span class="params">(Iterable&lt;Op&gt; ops)</span> throw InterruptedException,KeeperException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multi</span><span class="params">(Iterable&lt;Op&gt; ops, MultiCallback callback, Object context)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Transaction 封装 multi 方法，提供了更简单的调用方式，可以通过创建 Transaction 对象来添加操作、提交事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;OpResult&gt; results = zk.transaction().delete(<span class="string">"/a"</span>, -<span class="number">1</span>).create(<span class="string">"/b"</span>, <span class="string">"data"</span>.getBytes()</span><br><span class="line">        , ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT).commit();</span><br></pre></td></tr></table></figure>
<p>multi 提供的另一个功能是检查 znode 的版本号，在输入的 znode 节点与版本号不匹配时，multi 会调用失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Op <span class="title">check</span><span class="params">(String path, <span class="keyword">int</span> version)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="消除隐藏通道"><a href="#消除隐藏通道" class="headerlink" title="消除隐藏通道"></a>消除隐藏通道</h2><p>ZooKeeper 的状态会在所有服务器间互相复制，服务端对状态变化的顺序会达成一致，并使用相同的顺序对状态进行更新。但事实上服务端很少同时执行更新操作，如果通过隐藏通道进行通信可能会出现状态不一致的现象。</p>
<p>比如 Client-1 连接到 Server-1，Client-2 连接到 Server-2，/z 节点中的数据由 a 变为 b。</p>
<p>Server-1 更新状态会向 Client-1 发送通知，Client-1 收到通知后向 Client-2 发送 /z 节点变化的消息，Client-2 再通过 Server-2 进行操作，如果此时 Server-2 还没有对 /z 节点的状态进行更新，就会读取到过期的数据。</p>
<p>Client-1 向 Clinet-2 发送消息，就是隐藏的通道，会导致错误发生，正确的做法是 Client-2 只通过 ZooKeeper 服务端接收消息，消除隐藏通道。</p>
<h2 id="避免在同一个节点设置过多监视点"><a href="#避免在同一个节点设置过多监视点" class="headerlink" title="避免在同一个节点设置过多监视点"></a>避免在同一个节点设置过多监视点</h2><p>当节点发生变化时，会向设置监视点的客户端发送消息，如果对同一节点设置过多的监控点，就会在节点状态变更时出现发送消息的高峰，可能会对性能造成影响。</p>
<p>条件允许的话，最好对节点设置少量的监视点，理想情况下只设置一个。</p>
<p>比如多个客户端争相获取一个锁：可以一个客户端通过创建临时节点获取锁，其他客户端对这个节点设置监视点；也可以改为让客户端创建有序临时节点，最小序号的客户端获取锁，其他客户端只对比自己序号小 1 的节点设置监视点。</p>
<p>一个监视点会占用服务端约 300 字节的内存，开发时需要注意监视点数量。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 公钥认证免密码登录</title>
    <url>/2016/12/29/ssh-%E5%85%AC%E9%92%A5%E8%AE%A4%E8%AF%81%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><p><strong>ssh 公钥认证</strong>是 ssh 的认证方式之一，通过公钥认证可以实现 <strong>ssh 免密码登录</strong>。</p>
</li>
<li><p>在用户的主目录下有一个<code>.ssh</code> 目录，用来存放当前用户的 ssh 配置相关的文件。如不存在可以使用 <code>mkdir .ssh</code> 命令创建目录。</p>
</li>
<li><p>进入到.ssh 目录，通过 <code>ssh-keygen</code> 命令来生成 ssh 公钥认证所需要的公钥和私钥文件。如不指定文件名和密钥类型，默认生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，分别为私钥和公钥。</p>
</li>
<li><p>可以通过 <code>-f</code> 来指定 <code>ssh-keygen</code> 命令所生成密钥的文件名，通过 <code>-C &quot;xxx&quot;</code> 添加备注。</p>
</li>
<li><p>如使用 <code>ssh-keygen</code> 时未指定文件名，会有提示要求输入文件名，直接按回车使用默认文件名(<code>id_rsa</code>)。</p>
</li>
<li><p>之后会提示要求输入密码，如不需要直接回车。至此本机的公钥和私钥创建完毕。</p>
</li>
<li><p>最后需要将本机的公钥添加到服务器中的 <code>~/.ssh/authorized_keys</code> 文件中(如不存在需手动创建)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>代码质量</title>
    <url>/2020/02/12/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/</url>
    <content><![CDATA[<p>本篇文章的内容源自 <strong>极客时间 - 设计模式之美</strong> ，为其中一节课程的笔记记录，主要介绍了一些常见的代码质量评判维度，以及简要地说明如何写出高质量的代码。</p>
<p>如果您对文章内容感兴趣，可以扫描文章尾部的二维码，到专栏进行系统学习。</p>
<a id="more"></a>
<h2 id="如何评判代码质量"><a href="#如何评判代码质量" class="headerlink" title="如何评判代码质量"></a>如何评判代码质量</h2><p>辨别代码好还是烂，是一种能力，也是写出好代码的前提。</p>
<p>常见的描述代码质量的词汇包括灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）等等。</p>
<p>代码质量高低就像小说的精彩程度，有很强的主观性，并且很难量化。主观评价的准确度，跟工程师自身的经验有很大的关系，经验越丰富，给出的评价越准确。</p>
<p>以下为几个最常见、最重要的评价标准。</p>
<h3 id="1-可维护性（maintainability）"><a href="#1-可维护性（maintainability）" class="headerlink" title="1. 可维护性（maintainability）"></a>1. 可维护性（maintainability）</h3><p>维护即修复 bug、调整老代码和添加新代码。</p>
<p>易维护即在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或添加代码。反之，不易维护就是指，修改或者添加代码需要冒极大的引入新 bug 的风险，并且完成需要花很长时间。</p>
<p>通常维护代码的时间远大于编写代码的时间，所以代码的可维护性非常重要。</p>
<p>可维护性是一个很难量化、偏向对代码整体的评价标准，受很多因素影响。可读性好、简洁、可扩展性好，就会使代码易维护，反之就会使得代码不易维护。</p>
<p>除此之外，可维护性还跟代码量的多少、业务的复杂程度、所用技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。</p>
<p>正面分析代码的可维护性很难，不过可以从侧面给出主观但又比较准确的感受。如果 bug 容易修复，修改或添加功能可以轻松完成，就可以认为代码易维护。反之，如果修复 bug，修改或添加功能，需要花费很长时间，就可以认为代码不易维护。</p>
<p>可维护性针对的是维护代码的人，不同水平的人对于同一份代码的维护能力不同。</p>
<h3 id="2-可读性（readability）"><a href="#2-可读性（readability）" class="headerlink" title="2. 可读性（readability）"></a>2. 可读性（readability）</h3><p>Martin Fowler 曾经说过：”Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”</p>
<p>代码被阅读的次数远超过被编写的次数，所以可读性是评价代码质量最重要的指标之一，并且在很大程度上影响代码的可维护性。</p>
<p>评价代码的可读性，要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。</p>
<p>正面很难给出一个涵盖所有评价指标的列表，所以可读性也很难量化。Code Review 是一个很好的测验代码可读性的手段，如果你的同事可以轻松读懂你的代码，说明你的代码可读性很好。</p>
<h3 id="3-可扩展性（extensibility）"><a href="#3-可扩展性（extensibility）" class="headerlink" title="3. 可扩展性（extensibility）"></a>3. 可扩展性（extensibility）</h3><p>可扩展性，即代码应对未来需求变化的能力，同样在很大程度上影响代码的可维护性。</p>
<p>可扩展性强，即在不修改或少量修改原有代码的情况下，能够通过扩展的方式添加新的功能。代码预留了一些功能扩展点，可以把新功能代码直接插到扩展点上，而不需要大量改动原有代码。</p>
<h3 id="4-灵活性（flexibility）"><a href="#4-灵活性（flexibility）" class="headerlink" title="4. 灵活性（flexibility）"></a>4. 灵活性（flexibility）</h3><p>灵活性是一个比较抽象的评价标准，含义非常宽泛。易扩展、易复用或易用，都可以称其比较灵活。</p>
<p>灵活性好，比如要添加一个新功能时，原有代码已经预留好了扩展点，不需要修改原有的代码，只要在扩展点上添加新代码即可；比如要实现一个功能时，原有代码中已经抽象出很多可以复用的模块，可以直接使用；又比如使用某组接口时，接口可以应对各种使用场景，满足各种不同的需求。</p>
<h3 id="5-简洁性（simplicity）"><a href="#5-简洁性（simplicity）" class="headerlink" title="5. 简洁性（simplicity）"></a>5. 简洁性（simplicity）</h3><p>KISS 原则：Keep It Simple，Stupid。这个原则说的是，尽量保持代码简单。</p>
<p>代码简单、逻辑清晰，就意味着易读、易维护。</p>
<p>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。</p>
<h3 id="6-可复用性（reusability）"><a href="#6-可复用性（reusability）" class="headerlink" title="6. 可复用性（reusability）"></a>6. 可复用性（reusability）</h3><p>可复用性，即尽量减少重复代码的编写，复用已有的代码，是很多设计原则、思想、模式等所追求的效果。</p>
<h3 id="7-可测试性（testability）"><a href="#7-可测试性（testability）" class="headerlink" title="7. 可测试性（testability）"></a>7. 可测试性（testability）</h3><p>可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。</p>
<p>代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。</p>
<p>代码的可测试性差，比较难写单元测试，基本就能够说明代码设计的有问题。</p>
<h2 id="如何写出高质量代码"><a href="#如何写出高质量代码" class="headerlink" title="如何写出高质量代码"></a>如何写出高质量代码</h2><p>要写出满足以上评价标准的高质量代码，需要掌握一些更加细化、且能够落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p>
<p>所有编程方法论的最终目的，都是为了编写出高质量的代码。比如，面向对象中的继承、多态能够提高代码的可复用性；编码规范能提高代码的可读性；设计原则中的单一职责原则、里氏替换原则等，能提高代码的可复用性、灵活性、可读性、可扩展性、可维护性；设计模式能提高代码的可扩展性；持续重构可以时刻保持代码的可维护性等等。</p>
<p><img src="http://image.ulyssesss.com/design-pattern.jpeg" alt="设计模式之美"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>代码质量</tag>
      </tags>
  </entry>
  <entry>
    <title>刻意练习</title>
    <url>/2019/11/05/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>本篇文章为阅读《刻意练习》一书所做的简要笔记，将集中记录书中对本人产生较大影响的重要观点。</p>
<p>受篇幅限制，本篇文章不会对所涉及的观点做详细解释，也不会提及任何可增强理解的小故事。</p>
<p>如果您对文章中提到的观点感兴趣，可以直接阅读《刻意练习》一书。</p>
<a id="more"></a>
<h3 id="天才是训练的产物"><a href="#天才是训练的产物" class="headerlink" title="天才是训练的产物"></a>天才是训练的产物</h3><p>大脑拥有极强的适应能力，专注训练可以促使大脑做出改变，人不仅可以挖掘潜力，更能创造潜力。</p>
<blockquote>
<p>雷·阿伦：不要低估我每天付出的巨大努力，不是一天两天，是每一天。</p>
</blockquote>
<h3 id="有目的的练习"><a href="#有目的的练习" class="headerlink" title="有目的的练习"></a>有目的的练习</h3><p>一般而言，从开始学习，到水平可以接受，再到能够自然地做出反应，如果接下来的练习不够有效，就很难再有进步。</p>
<p>有目的的练习，即走出舒适区，制定明确的目标，为目标制定计划，分解目标，并想出监测进步的方法，专注地练习，而且需要保持动机。</p>
<p>遇到瓶颈时，试着做不能的事情，而非更难的事情。也可能并非到达瓶颈，而是心理因素或动机不足。</p>
<h3 id="大脑的适应能力"><a href="#大脑的适应能力" class="headerlink" title="大脑的适应能力"></a>大脑的适应能力</h3><p>大脑拥有无限的适应能力，结构与运行都会为了应对各种不同的心理训练而改变，很大程度上像肌肉和心血管系统响应体育锻炼。</p>
<p>人的身体偏爱稳定性，被迫走出舒适区会重建体内平衡，逐步建立新的舒适区。要使改变不断进行下去，必须不断加码。</p>
<p>挑战越大，变化越大，但不要太过。对于舒适区外却离得不太远的挑战，大脑和身体的改变最为迅速。</p>
<p>三个细节：年轻人的大脑比成年人的大脑更具适应能力；通过长时间训练发展大脑中的某些部位，可能导致某些其他能力下降；由训练引起的变化需要持续保持，停止训练就开始消失。</p>
<h3 id="心理表征"><a href="#心理表征" class="headerlink" title="心理表征"></a>心理表征</h3><p>心理表征是一种我们大脑正在思考的某个物体、某个观点、某些信息或其他任何事物相对应的<strong>心理结构</strong>，或具体或抽象。比如提到蒙娜丽莎脑海中油画的形象。</p>
<p>心理表征保存在长时记忆中，是信息预先存在的模式，使人可以有效且迅速地处理信息，能够回避短时记忆存在容量有限等局限。刻意练习包括创建心理表征。</p>
<p>心理表征有助于找出规律，从而做到预测未来（如篮球比赛中预测对手的动作）和无意识决策。</p>
<p>心理表征有助于解释信息，理解和解读它，在记忆中组织它、分析它，并用它来决策。</p>
<p>心理表征有助于组织信息，好的心理表征使人可以立即吸收和考虑更多的信息。</p>
<p>心理表征有助于指定计划，监测、评估、提升自己技能水平，并在必要时调整心理表征使之更加高效。</p>
<p>心理表征有助于高效学习，敏锐地察觉自己所犯的错误并加以改正。技能与心理表征是一个良性循环。</p>
<h3 id="黄金标准"><a href="#黄金标准" class="headerlink" title="黄金标准"></a>黄金标准</h3><p>在所有的行业和领域中，有些训练方法比另一些更有效。刻意练习是最有效、最理想的方法，它是黄金标准。</p>
<p>刻意练习具有以下特点：</p>
<ul>
<li>刻意练习发展的技能，已经拥有一整套行之有效的训练方法，训练方案由导师设计和监管，他们既熟悉杰出人物的能力，也熟悉如何最好地提升能力。</li>
<li>发生在舒适区之外（一般这并不令人心情愉悦）。</li>
<li>包含良好定义的特定目标，及目标达成的具体表现，而非某些模糊的总体目标。</li>
<li>专注和有意识的行动，紧跟目标，控制练习。</li>
<li>包含反馈，以及根据反馈努力进行调整。</li>
<li>既产生有效的心理表征，又依靠有效的心理表征。</li>
<li>着重关注已有技能的某些方面，并致力于有针对性地提高，不断改进。</li>
</ul>
<p>并非每个行业和领域都能进行严格意义的刻意练习，不必担心，尽可能遵循刻意练习的原则，可能依然是最有效的练习方式。</p>
<p>可以通过额外步骤尽可能遵循刻意练习的原则。首先辨别杰出人物，尽可能通过客观的、可复制的测量指标。接着找出杰出人物和其他人的差别。不过最佳方式还是找到优秀导师。</p>
<h3 id="工作中运用刻意练习"><a href="#工作中运用刻意练习" class="headerlink" title="工作中运用刻意练习"></a>工作中运用刻意练习</h3><p>三种错误思想：能力受基因特征限制；长时间做某件事一定会有提升；努力、刻苦就能优秀。</p>
<p>边干边学，养成练习的习惯，并思考如何练习。</p>
<p>要使用或创建有反馈的训练工具，并不断改进心理表征（尝试在某个决策点停下来，如观看篮球比赛录像，暂停并思考进攻选择）。</p>
<p>了解知识和技能之间的区别，聚焦于绩效、表现，以及如何提高绩效和表现。</p>
<h3 id="生活中运用刻意练习"><a href="#生活中运用刻意练习" class="headerlink" title="生活中运用刻意练习"></a>生活中运用刻意练习</h3><p>开始学习一门技能时，找到好导师尤其重要，有助于创建新的、更有效的心理表征。</p>
<p>导师只能引导你达到他们或他们的学生曾经达到过的水平，当自己提升到一定水准，需要更换导师。</p>
<p>投入和专注至关重要，如果你在走神，或者你很放松，你可能不会进步。</p>
<p>如果不能集中注意力，尝试把训练时间缩短，在短时间内集中注意力，并逐渐延长。</p>
<p>没有导师的情况下，需要自己设计练习方法、创造练习机会，用三个 F 建立有效的心理表征： focus （专注）、 feedback （反馈）和 fix it （纠正）。</p>
<p>将技能分解成一些组成部分，反复练习，有效地分析、确定不足之处，并聚焦于在那些地方取得进步。</p>
<p>遇到瓶颈时，在不同类型的训练之间切换，找到并攻克特定的弱点。你不能再提高，可能只是那项技能中的一两个组成部分在妨碍你，不是所有的组成部分都在绊住你。</p>
<p>想办法逼自己一下通常会帮你确定瓶颈的停滞点在哪，如跟更高水平的网球运动员比赛弱点会更明显地暴露出来。</p>
<p>保持动机可能是每个投入到练习中的人面对的最大问题，不存在可以在任何情形中运用的一般意志力（运动员可能无法坚持弹钢琴）。</p>
<p>保持动机，要么强化继续前进的理由，要么弱化停下脚步的理由。</p>
<p>控制可能带来干扰练习的事，如保证睡眠质量、预留固定的练习时间。</p>
<p>一旦练习有了效果，技能本身就可以成为动机的一部分。</p>
<p>身边人的鼓励可以强化继续前进的理由，将对同样事情感兴趣的人聚集起来，或者加入一个现有团体，会出现达成目标的额外动机。</p>
<p>想要放弃时，和自己达成协议，越过停滞阶段或恢复到之前的状态再放弃。</p>
<p>刻意练习的核心是一种孤独的追求，将旅程分解成一系列可控的目标，每次只关注其中一个，甚至可以在达成目标后给自己小小的奖励。</p>
<h3 id="杰出人物路线图"><a href="#杰出人物路线图" class="headerlink" title="杰出人物路线图"></a>杰出人物路线图</h3><p>成为杰出人物通常有 4 个阶段：产生兴趣，变得认真，全力投入，开拓创新。</p>
<p>日后成为杰出人物的孩子，父母在其成长和发展中扮演了至关重要的角色，兄弟姐妹也有明显的激励作用。</p>
<p>父母和导师可以采用许多方法激励孩子，但动机必须来自孩子的内心，否则不会长久。</p>
<p>随年龄增大，身体的适应能力会减弱，但心理的适应能力依然十分强大。</p>
<p>杰出人物的进展只有在局外人眼中才是重大进展，他们没有见证过那些微小的进展，正式微小的进展最终累积成大的飞跃。</p>
<h3 id="天生才华"><a href="#天生才华" class="headerlink" title="天生才华"></a>天生才华</h3><p>长远看来，占上风的是那些练习更勤奋的人，是拥有更高质量的心理表征和能够更加有效运用心理表征的人，而不是一开始在智商或其他才能方面稍有优势的人，</p>
<p>练习是决定某人在特定行业和领域中最终成就的唯一重要因素，基因在其中的作用会慢慢消失。</p>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>行动</tag>
      </tags>
  </entry>
  <entry>
    <title>图（未完）</title>
    <url>/2016/07/25/%E5%9B%BE/</url>
    <content><![CDATA[<p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为： G(V, E) ，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p>
<p>通常，在线性表中将数据元素称为元素，树中将数据元素称为结点，而图中，称为<strong>顶点（Vertex）</strong>。</p>
<p>线性表和树中可以没有数据元素，称为空表和空树，但图中强调了顶点集合是<strong>非空</strong>的。</p>
<p>图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边表示，边集可以是空的。</p>
<a id="more"></a>
<h3 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h3><p><strong>无向边</strong>：若顶点 $v_i$ 到 $v_j$ 之间的边没有方向，则称这条边为无向边（Edge），用无序偶对 ($v_i, v_j$) 或 ($v_j, v_i$) 表示。</p>
<p>若图中任意两个顶点之间的边都是无向边，则称该图为<strong>无向图（Undirected graphs）</strong>。</p>
<p><strong>有向边</strong>：若顶点 $v_i$ 到 $v_j$ 之间的边有方向，则称这条边为有向边，也称为<strong>弧（Arc）</strong>，用有序偶对 &lt;$v_i, v_j$&gt; 来表示，其中 $v_i$ 称为弧尾（Tail），$v_j$ 称为弧头（Head）。</p>
<p>若图中任意两个顶点之间的边都是有向边，则称该图为<strong>有向图（Directed graphs）</strong>。</p>
<p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，责成这样的图为<strong>简单图</strong>。</p>
<p>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong>。含 n 个顶点的无向完全图有 n * (n - 1) / 2 条边。</p>
<p>在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为<strong>有向完全图</strong>。含 n 个顶点的有向完全图有 n * (n - 1) 条边。</p>
<p>有很少条边或弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。</p>
<p>与图的边或弧相关的数叫做<strong>权（Weight）</strong>，带权的图称为<strong>网（Network）</strong>。</p>
<p>假设有两个图 $G_1$ = ($V_1$, {$E_1$}) 和 $G_2$ = ($V_2$, {$E_2$}) ，如果 $V_2 \subseteq V_1$ 且 $E_2 \subseteq E_1$ ，则称 $G_2$ 为 $G_1$ 的<strong>子图（Subgraph）</strong>。</p>
<p>对于无向图 G = (V, {E}) ，如果边 ($v_1$, $v_2$) $\in$ E ，则称 顶点 $v_1$ 和 $v_2$ 互为<strong>邻接点（Adjacent）</strong>，即 $v_1$ 和 $v_2$ 相连。边 ($v_1$, $v_2$) 依附（incident）于顶点 $v_1$ 和 $v_2$ ，或 ($v_1$, $v_2$) 与顶点 $v_1$ 和 $v_2$ 相关联。顶点 v 的<strong>度（Degree）</strong>是和 v 相关联的边的数目，记为 TD(v)。</p>
<p>对于有向图 G = (V, {E}) ，如果弧 &lt;$v_1$, $v_2$&gt; $\in$ E ，则称顶点 $v_1$ 邻接到 $v_2$ ，顶点 $v_2$ 邻接自 $v_1$ 。弧 &lt;$v_1$, $v_2$&gt; 和顶点 $v_1$ 、 $v_2$ 相关联。以顶点 v 为头的弧的数目称为 v 的<strong>入度（InDegree）</strong>，记为 ID(v) ；以 v 为尾的弧的数目称为 v 的<strong>出度（OutDegree）</strong>，记为 OD(v) ；顶点 v 的度为 TD(v) = ID(v) + OD(v) 。</p>
<p>路径的长度是路径上的边或弧的数目。</p>
<p>第一个顶点和最后一个顶点相同的路径称为<strong>回路</strong>或<strong>环（Cycle）</strong>。序列中顶点不重复出现的路径称为<strong>简单路径</strong>。除第一个和最后一个顶点，其余顶点不重复出现的回路，称为<strong>简单回路</strong>或<strong>简单环</strong>。</p>
<p>在无向图 G 中，如果从顶点 $v_1$ 到 $v_2$ 有路径，则称 $v_1$ 和 $v_2$ 是连通的。如果图中任意两个顶点都是连通的，则称该图为<strong>连通图（Connected Graph）</strong>。</p>
<p>无向图中的极大连通子图称为<strong>连通分量</strong>。</p>
<p>在有向图 G 中，如果对于每一对 $v_i 、 v_j \in V$  、$v_i \ne v_j$ ，从 $v_i$ 到 $v_j$ 和 从 $v_j$ 到 $v_i$ 都存在路径，则称 G 是<strong>强连通图</strong>。</p>
<p>有向图中的极大强连通子图称作有向图的<strong>强连通分量</strong>。</p>
<p><strong>连通图的生成树</strong>是一个极小的连通子图，含有图中全部的 n 的顶点，但只有足以构成一棵树的 n - 1 条边。</p>
<p>如果一个有向图洽有一个顶点入度为 0 ，其余顶点入度均为 1 ，则是一棵有向树。一个有向图的生成森林由若干棵有向树组成，含图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
<h3 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h3><p>ADT ： 图（Graph）</p>
<p>Data ：顶点的有穷非空集合和边的集合。</p>
<p>Operation ：</p>
<ul>
<li>create（按顶点集合边集构造图）</li>
<li>locateVertex（获取顶点位置）</li>
<li>getVertex（获取顶点的值）</li>
<li>putVertex（对顶点赋值）</li>
<li>getFirstAdjVertex（获取顶点的第一个邻接点）</li>
<li>getNextAdjVertex（获取顶点的下一个邻接点）</li>
<li>insertVertex（插入新顶点）</li>
<li>deleteVertex（删除顶点及相关的边或弧）</li>
<li>insertArc（添加弧）</li>
<li>deleteArc（删除弧）</li>
<li>dfsTraversal（深度优先遍历）</li>
<li>hfsTraversal（广度优先遍历）</li>
</ul>
<p>endADT</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>图的结构比较复杂，任意两个顶点之间都可能存在联系，所以无法以数据元素在内存中的物理位置来表示元素间的关系。而多重链表按最大度数顶点设计指针域，不仅存在空间浪费，结构不同造成的操作也很不方便。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>图的邻接矩阵（Adjancency Matrix）存储方式是用两个数组表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p>
<p>邻接矩阵中用 1 表示存在边或弧，0 表示不存在边或弧。如图为网图，可以用权值大小作为邻接矩阵中的值，不存在的边或弧用无穷大表示（权值可能为 0）。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对于边数相对顶点较少的图，邻接矩阵会存在大量的空间浪费。</p>
<p>数组与链表相结合的存储方法称为<strong>邻接表（Adjacency List）</strong> ：顶点用一个一维数组存储，每个数据元素需额外存储指向第一个邻接点的指针，<code>data|firstedge</code> ；每个顶点的所有邻接点构成一个链表，<code>adjvex|next</code> ，adjvex 存储邻接点在数组中的下标，next 指向下一个邻接点。</p>
<p>若是有向图，邻接表结构类似，以顶点为<strong>弧尾</strong>存储边表。也可以建立有向图的逆邻接表，以顶点的弧头建立边表。</p>
<p>对于网图，可以在边表结点中增加 weight 的数据域。</p>
<h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>对于有限图，邻接表是有缺陷的，入度和出度只能关注其一。而<strong>十字链表</strong>就是邻接表和逆邻接表的结合。</p>
<p>顶点表由数据域、入边表第一个结点指针和出边表第一个结点指针组成，如 <code>data|firstin|firstout</code> 。</p>
<p>边表由弧起点在顶点表中下标、弧终点在顶点中下标、入边表指针域和出边表指针域组成，网可以增加权值域，如 <code>tailvex|headvex|headlink|taillink</code> 。</p>
<h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p>无向图的应用中，如果关注的是顶点，邻接表是不错的选择，但如果关注的是变，如删除一条边等操作，就需要对两个边表结点进行操作。</p>
<p>对边表结点进行改造，改为由边的两个顶点在顶点表中的下标及已付两个顶点的下一条边组成，这就是<strong>邻接多重表</strong>，如 <code>ivex|ilink|jvex|jlink</code> 。</p>
<h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><p>边集数组由两个一维数组组成。一个存储顶点信息；另一个存储边的信息，边数组中的数据元素由起点下标、终点下标和权值组成，如 <code>begin|end|weight</code> 。</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>从图中某一顶点出发，访问图中其余顶点，且使每个顶点仅被访问一次，这一过程叫图的遍历（Traversing Graph）。</p>
<p>todo</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Kafka</title>
    <url>/2018/06/05/%E5%88%9D%E8%AF%86-Kafka/</url>
    <content><![CDATA[<p>Kafka 最初是 LinkedIn 的一个内部基础组件，用于处理持续的数据流，之后开源成为 Apache 项目。</p>
<p>Kafka 初衷是构建一个流平台，在平台上发布和订阅数据流，保存和处理数据。</p>
<p>Kafka 不同于一般的消息系统。作为现代分布式系统，Kafka 以集群方式运行，可以自由伸缩；Kafka 可以按要求存储数据，通过复制、持久化提供数据传递保证；Kafka 拥有流式处理能力，可动态处理派生流和数据集。</p>
<a id="more"></a>
<h2 id="发布与订阅消息系统"><a href="#发布与订阅消息系统" class="headerlink" title="发布与订阅消息系统"></a>发布与订阅消息系统</h2><p>在正式介绍 Kafka 之前，先介绍一下发布与订阅消息系统的概念及重要性。</p>
<p>在发布与订阅消息系统中，发送方不直接将消息发送到接收方，而是先以某种方式对消息进行分类，然后发送到消息中心；接收者订阅特定类型的消息，从而通过消息中心接收特定类型的消息。</p>
<p>如果不使用消息系统，应用 A 直接将消息发送给应用 B，在简单场景下没有问题。而如果应用 C 也需要接收此类消息，应用 A 就需要将消息同时发送给 B 和 C。当发送方和接收方逐渐增多，情况会越来越糟。</p>
<h2 id="Kafka-中的基础概念"><a href="#Kafka-中的基础概念" class="headerlink" title="Kafka 中的基础概念"></a>Kafka 中的基础概念</h2><p>Kafka 是一款基于发布与订阅的消息系统，消息按一定的顺序持久化保存，可按需读取，具备故障保护和性能伸缩能力。</p>
<h3 id="消息与批次"><a href="#消息与批次" class="headerlink" title="消息与批次"></a>消息与批次</h3><p>消息是 Kafka 的数据单元，类似数据库中一个数据行。消息由字节数组组成，同时有一个可选的元数据——键。键也是一个字节数组，用于将消息以可控方式写入到不同分区。</p>
<p>批次为属于同一个主题和分区的一组消息，消息分批写入 Kafka 可以减小网络开销，提升效率。注意，批次越大，单次传输时间越长。压缩批次数据可以通过计算处理提升传输和存储能力。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式（schema）即消息内容的结构，由于 Kafka 的消息内容为晦涩难懂的字符数组，额外的结构可以使消息容易理解，如 JSON 或 XML。</p>
<p>Kafka 的许多开发者使用 Apache Avro 序列化框架。Avro 提供一种紧凑的序列化格式，模式与消息体分开，模式发生变化时不需要重新生成代码，既向前兼容又向后兼容。</p>
<h3 id="主题和分区"><a href="#主题和分区" class="headerlink" title="主题和分区"></a>主题和分区</h3><p>Kafka 中的消息通过主题进行分类，相当于数据库中的表。主题可以分为若干个分区，消息以追加的方式写入其中一个分区，按先入先出的顺序读取。</p>
<p>一个主题通常包含多个分区，无法在主题范围内保证消息顺序，但可以保证单个分区内的顺序。</p>
<p>分区可以分布在不同的服务器上，主题横跨多个服务器，能够提供比单个服务器更强的性能。</p>
<h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>Kafka 的客户端有生产者和消费者两种基本类型。</p>
<p>生产者创建特定主题的消息，默认情况把消息均衡地写入到主题的所有分区上，也可以通过键或直接指定写入的分区。</p>
<p>消费者订阅一个或多个主题，按消息生成顺序来读取消息。消费者通过检查消息的偏移量来区分是否已经读取过某条消息。</p>
<p>偏移量是一种元数据（不断递增的整数值），创建消息时会将偏移量添加到消息中，分区内消息的偏移量唯一。消费者将每个分区最后读取消息的偏移量记录在 ZooKeeper 或 Kafka 中，消费者关闭或重启读取状态不会丢失。</p>
<p>Kafka 中有消费者群组的概念，消费者是消费者群组的一部分，一个或多个消费者共同读取一个主题。群组保证每个分区只能被一个消费者使用，群组中的消费者和分区之间的映射称为消费者对分区的所有权关系。当一个消费者失效，群组内的其他消费者可以接管失效消费者的工作。</p>
<h3 id="broker-和集群"><a href="#broker-和集群" class="headerlink" title="broker 和集群"></a>broker 和集群</h3><p>一个独立的 Kafka 服务器被称为 broker。broker 接收来自生产者的消息，为消息设置偏移量并保存。broker 为消费者提供服务，接收读取分区的请求并返回消息。单个 broker 可以轻松处理数千个分区及每秒百万级的消息量。</p>
<p>多个 broker 组成集群，每个集群中都有一个 broker 同时充当了集群控制器的角色，负责将分区分配给 broker 和监控等工作。每个分区从属于一个 broker，该 broker 称为分区的首领。分区分配给多个 broker 时会发生分区复制，提供消息冗余，在首领 broker 失效时接管领导权。</p>
<p>随 Kafka 部署数量增加，可以使用多个集群，多个集群间实现消息复制需要使用一个叫 MirrorMaker 的工具。</p>
<h2 id="为什么选择-Kafka"><a href="#为什么选择-Kafka" class="headerlink" title="为什么选择 Kafka"></a>为什么选择 Kafka</h2><p>基于发布与订阅的消息系统很多，而 Kafka 有以下优点：</p>
<h3 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h3><p>Kafka 天然支持多个生产者，并以统一的格式对外提供数据，消费者无需协调来自不同生产者的数据流。</p>
<h3 id="多个消费者"><a href="#多个消费者" class="headerlink" title="多个消费者"></a>多个消费者</h3><p>Kafka 支持多个消费者从一个消息流上读取数据，消费者之间互不影响。多个消费者也可以组成一个群组，共享一个消息流，保证整个群组对每条消息只处理一次。</p>
<h3 id="基于磁盘的数据存储"><a href="#基于磁盘的数据存储" class="headerlink" title="基于磁盘的数据存储"></a>基于磁盘的数据存储</h3><p>Kafka 中消息被提交到磁盘，根据设置的保留规则进行保存，每个主题可以设置单独的保留规则，所以允许消费者非实时地读取消息，无需担心消息丢失。</p>
<h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><p>Kafka 是一个具有灵活伸缩性的系统，可以先使用单个 broker，再扩展到包含 3 个 broker 的小型开发集群。对在线集群进行扩展不会影响整体的可用性。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>通过横向扩展生产者、消费者和 broker，Kafka 可以轻松处理巨大的信息流，同时保证亚秒级的消息延迟。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://kafka.apache.org/documentation/" target="_blank" rel="noopener">Kafka 官方文档</a></p>
<p><a href="http://shop.oreilly.com/product/0636920044123.do" target="_blank" rel="noopener">Kafka 权威指南</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>常见 bash shell 命令总结</title>
    <url>/2016/09/30/%E5%B8%B8%E8%A7%81-bash-shell-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇文章整理了常见的 bash shell 命令，其中包括 man、cd、pwd、ls、touch、cp、ln、mv、rm、mkdir、rmdir、file、cat、more、less、tail、head、ps、top、kill、mount、umount、df、du、sort、grep、gzip 及 tar。</p>
<a id="more"></a>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>访问手册，作为快速参考，格式为 <code>man xxx</code> ，使用空格进行翻页、回车逐行查看、方向键上下滚动，q 键退出。使用 -k 参数可以按照关键词查找相关命令。</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>切换目录，格式为 <code>cd destination</code> ，destination 参数可以使用绝对路径或相对路径。<code>~</code> 表示主目录，<code>.</code> 表示当前目录，<code>..</code> 表示上级目录。</p>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>显示当前目录。</p>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>显示当前目录下的文件及目录，<code>-F</code> 参数可以区分文件和目录，<code>-a</code> 参数显示全部文件（包含隐藏文件），<code>-R</code> 列出当前目录下包含的子目录中的文件，<code>-l</code> 长列表显示详细信息，<code>-i</code> 显示 inode 编号。多个参数可以一起使用，如 <code>ls -alF</code> 。另外 <code>--time=atime</code> 用于显示访问时间（默认显示文件的修改时间）。</p>
<p>ls 命令后可以接过滤规则，如 <code>ls tes*</code> 和 <code>ls tes?</code> ，其中 <code>*</code> 表示零或多个字符，<code>?</code> 表示一个字符，另外<code>[xy]</code> 表示 x 或 y，<code>[!a]</code> 表示排除 a。</p>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>创建空文件或改变文件的修改时间，格式为 <code>touch file</code> 。<code>-a</code> 参数用于改变访问时间。</p>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>复制文件或目录，格式为 <code>cp source destination</code> 。<code>-R</code> 参数用于递归复制整个目录的内容。</p>
<p>如果 destination 为文件名，则将源文件复制为一个以 destination 命名的新文件，<code>-i</code> 参数用于提醒覆盖；如果 destination 为目录，如 <code>cp test ~/Desktop/</code> ，则将源文件复制到 destination 目录下，文件名和源文件相同。</p>
<p>cp 命令中可以使用通配符。</p>
<blockquote>
<p>制表键 tab 具有自动补全的功能，可以在输入命令、文件名或目录时自动补全内容。</p>
</blockquote>
<h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><p>链接文件，格式为 <code>ln file link_file</code> ，<code>-s</code> 参数用于创建软链接。</p>
<blockquote>
<p>在 Linux 中文件的数据和文件名被分成两部分：用户数据和元数据。用户数据即文件数据块，记录文件真实内容；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等。元数据中的 inode 号是文件的唯一标识。</p>
<p>Linux 支持保存一份物理文件副本和多个虚拟副本的方式维护同一份文件的多份副本，这种虚拟副本称为链接，是指向文件真实位置的占位符。</p>
<p>链接分为符号链接（软链接）和硬链接。符号链接是一个实实在在的文件，拥有独立的 inode 编号，只是数据块内容为另一文件的路径指向；硬链接为一个 inode 对应的多个文件名，引用硬链接等同于引用源文件。</p>
</blockquote>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>将文件或目录移动到另一个位置，或重命名，格式为 <code>mv source destination</code> ，<code>-i</code> 参数用于提醒覆盖。</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除，格式为 <code>rm destination</code> ，<code>-i</code> 参数用于提醒确认，<code>-f</code> 用于强制删除，<code>-r</code> 用于递归删除整个目录。</p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>创建新目录，格式为 <code>mkdir dir_name</code> ，<code>-p</code> 参数用于同时创建目录及子目录。</p>
<h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><p>删除目录，只允许删除空目录。</p>
<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>查看文件类型及编码，格式为 <code>file destination</code> 。</p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>显示文本文件中的所有数据，<code>-n</code> 参数用于给数据加上行号，<code>-b</code> 用于给非空行加行号，<code>-T</code> 用于忽略制表符，格式为 <code>cat file</code> 。</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>分页显示文本内容，空格键翻页、回车键下一行、q 键退出，格式为 <code>more file</code> 。</p>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>more 的升级版（less is more），提供一些高级搜索功能。</p>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>显示文件最后几行内容，默认为 10 行，<code>-n</code> 用于修改显示的行数，<code>-f</code> 保持活跃状态、允许查看其它进程添加到文件中的内容（可用于实时监测日志）。</p>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>显示文件开头的内容，默认为 10 行，<code>-n</code> 修改显示的行数（head 和 tail 都可以直接在破折号后面直接输入要显示的行数）。</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>ps 命令用于探查进程，默认情况下只会显示运行在当前控制台下的属于当前用户的进程。</p>
<p>Linux 中的 ps 支持 3 种不同类型的命令行参数，分别为 Unix 风格加单破折号、BSD 风格不加破折号和 GNU 风格加双破折号，在此仅介绍 Unix 风格的常用参数。<code>-e</code> 显示所有进程，<code>-f</code> 显示完整格式的输出，<code>-l</code> 显示长列表。</p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>实时显示进程信息。</p>
<p>输出的第一行为系统概况，分别为当前时间、系统运行时间、登录用户数及平均负载（3 个值分别为最近 1、5、15 分钟的平均负载）。第二行为进程的概要信息，包括总进程数及运行、休眠、停止和僵化（进程完成但父进程无响应）的进程数。后面 3 行分别为 CPU 概要、内存概要和系统交换空间的信息。最后为各进程的信息，和 ps 命令类似。</p>
<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>结束进程，格式为 <code>kill pid</code> ，<code>-s</code> 参数用于指定向进程发送的信号，如 HUP、KILL，也可直接指定信号值，如 <code>kill -9 &lt;pid&gt;</code> 。killall 命令支持通过进程名（支持通配符）结束进程。</p>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><blockquote>
<p>Linux 将所有磁盘并入一个虚拟目录，使用新的存储媒体前需要把它放到虚拟目录下，这个过程称为挂载。</p>
</blockquote>
<p>mount 命令用于挂载媒体，默认情况下会售出当前系统挂载的设备列表。手动挂载的命令格式为 <code>mount -t type device directory</code> ，其中 type 指定磁盘被格式化的文件系统类型。<code>mount -a</code> 会挂载 /etc/fstab 文件中指定的所有文件系统。</p>
<h2 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h2><p>卸载设备，格式为 <code>umount [directory|device]</code> 。</p>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>查看所有已挂载磁盘的使用情况，<code>-h</code> 参数用于将磁盘空间按用于易读的形式显示。</p>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>显示特定目录（默认为当前目录）的磁盘使用情况，默认会显示所有的文件、目录及子目录的使用情况，以磁盘快为单位。<code>-c</code> 显示已列出文件的总大小，<code>-h</code> 按用户易读形式显示，<code>-s</code> 显示每个输出参数的总计。</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>对数据进行排序，格式为 <code>sort file</code> ，默认按语言的排序规则对文本文件中的数据进行排序。<code>-n</code> 用于将数字识别为数字而不是字符，并按数值排序。<code>-M</code> 用于识别三字符的月份名。</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>在输入或指定的文件中查找包含匹配指定模式的字符的行，格式为 <code>grep [option] pattern [file]</code> 。<code>-v</code> 参数用于反向搜索，<code>-n</code> 用于显示匹配模式的行所在的行号，<code>-c</code> 用于获取匹配的行数，<code>-e</code> 用于匹配多个模式，如 <code>grep -e a -e b file</code> 。</p>
<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>用于压缩文件，格式为 <code>gzip file</code> ，支持通配符。另外 gzcat 用于查看压缩过的文本文件的内容，gunzip 用于解压文件。</p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>用于归档，格式为 <code>tar function [option] object1 object2 ...</code> 。</p>
<p>function 定义了 tar 命令应该做什么，其中常用的有 <code>-c</code> 表示创建一个新的归档文件，<code>-x</code> 表示从已有 tar 文件中提取文件，<code>-t</code> 列出归档文件的内容。option 定义了能跟 tar 命令一起使用的选项，常用的有 <code>-v</code> 表示处理文件时显示文件，<code>-z</code> 表示将输出重定向给 gzip 命令来压缩内容，<code>-f</code> 输出结果到文件。</p>
<p>一些选项经常合并到一起使用，如 <code>tar -cvf test.tar test/ test2/</code> 创建归档文件，<code>tar -tf test.tar</code> 列出 test.tar 的内容，<code>tar -xvf test.tar</code> 提取内容。</p>
<blockquote>
<p>下载的开源软件经常以 <code>.tgz</code> 结尾，这是 gzip 压缩过的 tar 文件，可以使用 <code>tar -zxvf filename.tgz</code> 来解压。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举类型强化 Singleton 属性</title>
    <url>/2017/05/03/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%8C%96-Singleton-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p><strong>Singleton</strong> 指仅仅被 <strong>实例化一次</strong> 的类，通常被用来代表本质上唯一的系统组件，如窗口管理器或文件系统。</p>
<p>使类称为 Singleton 会使它的客户端测试变得困难，因为无法给 Singleton 替换模拟实现。除非它实现一个充当其类型的接口。</p>
<a id="more"></a>
<h2 id="Java-1-5-之前"><a href="#Java-1-5-之前" class="headerlink" title="Java 1.5 之前"></a>Java 1.5 之前</h2><p>在 Java 1.5 版本发行前，实现 Singleton 有两种方法，将构造器保持私有，并导出公有的静态成员。</p>
<h3 id="1-公有静态成员是个-final-域"><a href="#1-公有静态成员是个-final-域" class="headerlink" title="1. 公有静态成员是个 final 域"></a>1. 公有静态成员是个 final 域</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestSingleton INSTANCE = <span class="keyword">new</span> TestSingleton();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">TestSingleton</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//public method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有构造器仅被调用一次，用于实例化公有的静态 final 域实例。</p>
<h3 id="2-公有静态成员是个静态工厂方法"><a href="#2-公有静态成员是个静态工厂方法" class="headerlink" title="2. 公有静态成员是个静态工厂方法"></a>2. 公有静态成员是个静态工厂方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestSingleton INSTANCE = <span class="keyword">new</span> TestSingleton();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">TestSingleton</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//public method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态方法的所有调用，返回同一个对象引用。</p>
<p><strong>公有域</strong> 的好处在于，类的成员声明清楚的表明这个类是一个 Singleton。</p>
<p><strong>工厂方法</strong> 的优势在于提供了 <strong>灵活性</strong>。可以在不改变其 API 的前提下改变类是否应该为 Singleton。第二个优势与泛型有关。</p>
<p><strong><em>需要提醒一点：享有特权的客户端可以借助 AccesssibleObject.setAccessible 方法，通过反射机制调用私有构造器。要抵御这种攻击，可以修改私有构造器，让它被要求创建第二个实例时抛出异常。</em></strong></p>
<p>以上方法实现的 Singleton 如要变成 <strong>可序列化</strong>，仅在声明中添加 <code>implement Serializable</code> 是不够的，必须声明所有实例域都 <strong>是瞬时（transient）</strong> 的，并提供readResolve 方法。否则反序列化时会创建新的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现-Singleton-的最佳方法"><a href="#实现-Singleton-的最佳方法" class="headerlink" title="实现 Singleton 的最佳方法"></a>实现 Singleton 的最佳方法</h2><p>从 Java 1.5 发行版起，实现 Singleton 只需编写一个包含单个元素的枚举类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TestSingleton &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//public method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>简洁</li>
<li>无偿提供序列化机制</li>
<li>绝对防止多次实例化，即便面对反射攻击</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2016/07/18/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>串（String）是由零个或多个字符组成的有限序列，又叫字符串。</p>
<p>串中字符的个数称为串的长度，零个字符组成的传称为空串。</p>
<a id="more"></a>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>串的逻辑结构和线性表相似，不同之处在于串针对的是字符集，另外串的基本操作和线性表有很大差别。</p>
<p>线性表更关注单个元素的操作，如单个元素的查找、插入、删除；而串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。</p>
<p><strong>ADT</strong> ： 串（String）</p>
<p><strong>Data</strong> ：串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</p>
<p><strong>Operation</strong> ：</p>
<ul>
<li>create（生成字符串）</li>
<li>isEmpty（判断串是否为空）</li>
<li>compareTo（字符串比较）</li>
<li>concat（字符串拼接）</li>
<li>substring（截取子串）</li>
<li>indexOf（查找子串位置）</li>
<li>replace（替换子串）</li>
<li>charAt（得到指定位置的字符）</li>
<li>trim（去除两边空格）</li>
<li>length（获取串的元素个数）</li>
</ul>
<p>endADT</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>串的存储结构与线性表相同，分为顺序存储结构和链式存储结构。</p>
<h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>串的顺序存储结构，用一组地址连续的存储单元来存储字符序列，按预定义大小分配固定长度的存储区，一般用定长数组。</p>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>串的链式存储结构与线性表相似。由于串的每个元素只有一个字符，所以用一个节点存放多个字符以节省空间，最后一个节点未被占满时用 <code>#</code> 或其他非串值字符补全。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法概述</title>
    <url>/2016/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>数据结构，是相互之间存在一种或者多种特定关系的数据元素的集合。</p>
<p>数据结构研究非数值计算程序设计问题中的操作对象，以及它们之间的关系和操作。</p>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，每条指令表示一个或多个操作。</p>
<p>程序设计 = 数据结构 + 算法。</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>数据是描述客观事物的符号，是能够被计算机识别、处理并输出的符号集合。</p>
<h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p>数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体来处理，比如人、汽车。</p>
<h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>数据元素由若干个数据项组成，数据项是不可分割的最小单位，比如人的性别、年龄。</p>
<h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>数据对象指性质相同的数据元素的集合，是数据的子集，比如同一个班级的 60 名学生。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型指一组性质相同的值的集合以及定义在此集合上的操作的总称，比如整型、字符型。</p>
<h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p>Abstract Data Type，ADT，指一个数学模型（数据元素间的逻辑关系）及定义在该模型上的一组操作，取决于逻辑特性，与在计算机内部的表示和实现无关。</p>
<h3 id="逻辑与物理结构"><a href="#逻辑与物理结构" class="headerlink" title="逻辑与物理结构"></a>逻辑与物理结构</h3><p>按照关注点的不同，数据结构可以分为逻辑机构和物理结构。</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>逻辑结构指数据对象中各数据元素之间的逻辑关系，分为以下 4 种：</p>
<ul>
<li>集合结构 —— 数据元素除了同属于一个集合外无其他关系</li>
<li>线性结构 —— 数据元素之间是一对一的关系</li>
<li>树形结构 —— 数据元素之间存在一对多的层次关系</li>
<li>图形结构 —— 数据元素是多对多的关系</li>
</ul>
<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>物理结构指数据的逻辑结构在计算机中的存储形式，也叫存储结构，分为以下 2 中：</p>
<ul>
<li>顺序存储结构</li>
</ul>
<p>数据存储在地址连续的存储单元中，逻辑关系与物理关系一致。</p>
<ul>
<li>链式存储结构</li>
</ul>
<p>数据元素存放在任意的存储单元中，可以连续也可以不连续，物理关系不能反映其逻辑关系，需要通过指针存放数据元素的地址，以找到相关数据元素的位置。</p>
<h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p>算法具有以下 5 个基本特性：</p>
<ul>
<li>有零个或多个输入</li>
<li>有至少一个输出</li>
<li>有穷性，即算法在执行有限的步骤之后结束，且每个步骤在可接受的时间内完成</li>
<li>确定性，即每个步骤有确定的含义，不会出现二义性</li>
<li>可行性，即每个步骤都是可行的，且每一步都能通过执行有限次数完成</li>
</ul>
<h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><p>好的算法需要满足以下条件：</p>
<ul>
<li>正确性，算法至少应该能正确反映问题，并能够得到正确答案</li>
<li>可读性，好的算法应易于阅读、易于理解</li>
<li>健壮性，当输入不合法时，算法能够做出恰当的处理</li>
<li>时间效率高，尽可能缩短执行时间</li>
<li>存储量低，占用尽可能少的存储空间</li>
</ul>
<h3 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h3><p>由于 <strong>事后统计</strong> 存在 必须编写程序、依赖软硬件环境、测试数据设计困难等缺点，所以通常采用 <strong>事前分析估算</strong> 的方法来评估算法的执行效率。</p>
<p>程序运行的耗时主要取决于算法、编译后的代码质量、问题输入规模、机器执行指令的速度等因素，抛开外部因素，程序的运行时间依赖于 <strong>算法的好坏</strong> 和 <strong>问题的输入规模</strong>。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法执行时，语句的总执行次数（总执行时间）<code>T(n)</code> 是关于问题规模 n 的函数，记作 <code>T(n) = O( f(n) )</code> 。问题规模 n 增大，执行时间的增长率与 <code>f(n)</code> 的增长率相同，即算法的渐进时间复杂度，简称时间复杂度，通常使用 <code>O()</code> 来表示。</p>
<p>计算时间复杂度时，只保留最高阶项，同时去除这个项的系数，如 f(n) = $4n^{4}$ +3n + 2 的时间复杂度为 O($n^{4}$) 。</p>
<p>常见的时间复杂度所耗费的时间有小到大依次为：</p>
<p>O(1)  &lt;  O(logn)  &lt;  O(n)  &lt;  O(nlogn)  &lt;  O($n^{2}$)  &lt;  O($n^{3}$)  &lt;  O($2^{n}$)  &lt;  O(n!)  &lt;  O($n^{n}$)</p>
<blockquote>
<p>分析算法的时间复杂度，关键是分析循环结构的运行情况。</p>
<p>平均运行时间是算法的期望运行时间，而最坏情况运行时间是一种保证，通常提到的运行时间都指最坏情况的运行时间。</p>
</blockquote>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法的空间复杂度与时间复杂度类似，表示随问题规模 n 增长而所需的存储空间，<code>S(n) = O( f(n) )</code> 。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/2016/07/17/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本篇文章从定义、抽象数据类型和存储结构等方面，分别介绍两种特殊的线性表，即栈（Stack）和队列（Queue）。</p>
<a id="more"></a>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p>栈（Stack）是限定仅在表尾进行插入和删除操作的线性表。</p>
<p>允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不包含任何元素的栈称为空栈。栈又称为后进先出（<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut）的线性表。</p>
<p>栈的插入操作，叫做进栈，也称压栈、入栈；删除操作叫做出栈，也叫弹栈。</p>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p><strong>ADT</strong> ： 栈（Stack）</p>
<p><strong>Data</strong> ：同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。</p>
<p><strong>Operation</strong> ：</p>
<ul>
<li>init（初始化，建立一个空栈）</li>
<li>clear（将栈清空）</li>
<li>isEmpty（判断栈是否为空）</li>
<li>getTop（获取栈顶元素）</li>
<li>push（入栈操作）</li>
<li>pop（出栈操作）</li>
<li>length（获取栈的元素个数）</li>
</ul>
<p>endADT</p>
<h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><p>栈为线性表的一种，存储结构跟线性表一样，分为 <strong>顺序存储结构</strong> 和 <strong>链式存储结构</strong> 两种。</p>
<h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><p>栈的顺序存储结构是线性表顺序存储结构的简化，称为顺序栈，可以用一维数组来实现。</p>
<p>用下标为 0 的一端作为栈底，再定义一个 top 变量记录栈顶元素在数组中的位置。</p>
<p>当两个栈的空间需求有相反关系时（一个栈增长时另一个栈缩短），可以让两个栈共有一个数组，栈底分别在数组两段，随栈中元素增加，栈顶分别向中间靠拢。</p>
<h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p>栈的链式存储结构简称为链表。</p>
<p>定义 top 变量记录栈顶元素的指针，每个元素除数据域外还包含指向下一个元素的指针域。</p>
<h4 id="两种存储结构的对比"><a href="#两种存储结构的对比" class="headerlink" title="两种存储结构的对比"></a>两种存储结构的对比</h4><p>顺序栈和链栈，进栈和出栈的时间复杂度均为 O(1)。</p>
<p>顺序栈需要事前确定固定的长度，可能存在空间浪费的问题，优势是存取时定位方便。</p>
<p>链栈没有长度的限制，但每个元素都有指针域这一额外开销。</p>
<h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>栈的引入简化了程序设计，划分了不同的关注层次，使思考范围更小，更加聚焦于问题核心。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>一个直接调用自己，或通过一系列调用语句间接调用自己的函数，称为递归函数，是栈的一个重要应用。</p>
<p>每个递归定义必须至少有一个条件，满足条件时递归不再进行，即不再引用自身，返回结果值并退出。</p>
<p>使用递归的例子：斐波那些数列（1，1，2，3，5，8，13 … ）。</p>
<h3 id="逆波兰式"><a href="#逆波兰式" class="headerlink" title="逆波兰式"></a>逆波兰式</h3><p>逆波兰式，即四则运算表达式的后缀表示法，如中缀表达式 <code>9 + ( 3 - 1 ) * 3 + 10 / 2</code> 可转后后缀表达式 <code>9 3 1 - 3 * + 10 2 / +</code> 。</p>
<p>后缀表达式计算结果：从左至右遍历表达式的每个数字和符号，遇到数字进栈，遇到符号取出栈顶两个数字出栈，运算后将结果进栈，直到获得最终结果。</p>
<p>中缀表达式转后缀表达式：从左至右遍历表达式的每个数字和符号，数字直接输出称为表达式的一部分，遇到符号先判断与栈顶符号的优先级，是右括号或优先级不高于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号入栈，最后将栈中符号全部出栈并输出。</p>
<p>通过将中缀表达式转为后缀表达式，可以让计算机具有处理中缀表达式的能力。</p>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>队列（Queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>允许插入的一端称为队尾，允许删除的一端称为队头。队列又称为先进先出（<strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut ）的线性表。</p>
<h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><p><strong>ADT</strong> ： 队列（Queue）</p>
<p><strong>Data</strong> ：同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。</p>
<p><strong>Operation</strong> ：</p>
<ul>
<li>init（初始化，建立一个空队列）</li>
<li>clear（将队列清空）</li>
<li>isEmpty（判断队列是否为空）</li>
<li>getHead（获取队头元素）</li>
<li>enQueue（入队列操作）</li>
<li>deQueue（出队列操作）</li>
<li>length（获取队列的元素个数）</li>
</ul>
<p>endADT</p>
<h3 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h3><p>队列是一种特殊的线性表，存储结构分为 <strong>顺序存储结构</strong> 和 <strong>链式存储结构</strong> 两种。</p>
<h4 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h4><p>顺序存储的队列需要建立一个数组，将元素存储在数组的前 n 的单元中，数组下标为 0 的一端为队头。</p>
<p>入队列操作直接在队尾追加一个元素，不需要移动任何元素，时间复杂度为 O(1) 。而出队列操作需要将所有元素向前移动，时间复杂度为 O(n) 。</p>
<p>如出队列操作不移动元素，而是改变队头的位置，性能会大大增加。而如果数组头部有空闲空间，数组尾部没有空闲空间，再继续添加元素就会出现假溢出。</p>
<p>使队列头尾相接相接，数组尾部满了时将元素添加到数组的头部，这种循环队列可以解决假溢出的问题。</p>
<h4 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h4><p>队列的链式存储结构，其实就是线性表的单链表，不过只能尾进头出。</p>
<h4 id="两种存储结构的对比-1"><a href="#两种存储结构的对比-1" class="headerlink" title="两种存储结构的对比"></a>两种存储结构的对比</h4><p>循环队列和链队列的基本操作复杂度都为 O(1) ，不过循环队列是预先申请好空间，而链队列每次操作都要申请和释放空间。循环队列必须有一个固定的长度，存在元素个数的限制，还可能出现空间浪费，而链队列没有这些问题。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2016/07/19/%E6%A0%91/</url>
    <content><![CDATA[<p>树（Tree）是 n（n &gt;= 0）个结点的有限集。n = 0 时称为空树。</p>
<p>在任意一颗非空树中：</p>
<ol>
<li>有且仅有一个特定的、称为根（root）的结点；</li>
<li>当 n &gt; 1 时，其余结点可分为 m（m &gt; 0）个互不相交的有限集 T1、T2 … Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</li>
</ol>
<a id="more"></a>
<h3 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h3><p>树的结点包含一个<strong>数据元素</strong>及若干指向其子树的<strong>分支</strong>。</p>
<p>结点拥有的<strong>子树个数</strong>称为结点的<strong>度（Degree）</strong>，树内各结点度的最大值为树的度。</p>
<p>度为 0 的结点称为<strong>叶结点</strong>或<strong>终端结点</strong>，度不为 0 的结点称为<strong>非终端结点</strong>或<strong>分支结点</strong>。除根结点外，分支结点也称为<strong>内部结点</strong>。</p>
<p>结点的子树的根，称为该结点的<strong>孩子（Child）</strong>，该结点称为孩子的<strong>双亲（Parent）</strong>，同一个双亲的孩子之间互称<strong>兄弟（Sibling）</strong>。</p>
<p>根到某一结点所经分支上所有结点称为这一结点的<strong>祖先</strong>；反之，以某结点为根的子树中的任一结点称为该结点的<strong>子孙</strong>。</p>
<p>结点的<strong>层次（Level）</strong>从根开始定义，根为第一层，跟的孩子为第二层。双亲在同一层的结点互为<strong>堂兄弟</strong>。</p>
<p>树中结点的最大层次称为树的<strong>深度（Depth）</strong>或<strong>高度</strong>。</p>
<p>如果树中结点的各子树看成从左至右是有次序的、不能互换的，则称该树为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</p>
<p><strong>森林（Forest）</strong>是 m（m &gt;= 0）棵互不相交的树的集合。</p>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>ADT ： 树（Tree）</p>
<p>Data ：树由一个根结点和若干棵子树构成。树中结点具有层次关系及相同数据类型。</p>
<p>Operation ：</p>
<ul>
<li>init（创建一个空树）</li>
<li>clear（将树清为空树）</li>
<li>isEmpty（判断是否为空树）</li>
<li>depth（返回树的深度）</li>
<li>getRoot（返回根结点）</li>
<li>getParent（返回双亲结点）</li>
<li>getLeftChild（返回最左孩子结点）</li>
<li>getRightSibling（返回最右兄弟结点）</li>
<li>insertChild（插入子树）</li>
<li>deleteChild（删除子树）</li>
</ul>
<p>endADT</p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>树中各元素间的逻辑关系较线性表更为复杂，树中结点的孩子可能有多个，要表示结点间的逻辑关系，需要充分利用顺序存储和链式存储结构的特点，以下为 3 种常见的表示方法。</p>
<h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>以一组连续空间存储树的结点，每个结点除数据域外，附设一个指示其双亲结点在数组中位置的指针域， <code>data|parent</code> 。这样的存储结构可以很容易地通过指针域找到双亲结点。</p>
<p>如遇到的场景需要不但关注结点的双亲，又需要关注的孩子、兄弟，可以将其扩展为包含双亲域、长子域和右兄弟域的结构，<code>data|parent|firstchild|rightsib</code> 。</p>
<h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>由于每个结点可能有多棵子树，所以可以用多重链表，即每个结点有多个指针域，每个指针指向一棵子树的根结点，这种方法称作多<strong>重链表表示法</strong>。</p>
<p>由于每个结点的度可能不同，所以<strong>多重链表表示法</strong>有两种方案：一是使每个结点的指针域个数等于树的度；二是每个结点指针域的个数等于该结点的度数，同时额外取一个位置存放结点的指针域个数。</p>
<p>前一种方案浪费空间，后一种方案需要维护结点的度，且各结点的链表结构不同，运算上会有损耗。</p>
<p><strong>孩子表示法</strong>：把每个结点放到顺序存储的数组中，再对每个结点的孩子建立单链表以体现它们的关系，同时把这些链表的头指针存储在对应的数组元素中。</p>
<p>孩子表示法中包含两种结构，一是包含数据域和链表头指针的结构 <code>data|firstchild</code> ，另一个是孩子结点单链表的结构 <code>child|next</code> 。</p>
<p>如需要知道结点的双亲，可以综合双亲表示法和孩子表示法，增加双亲域 <code>data|parent|firstchild</code> ，即<strong>双亲孩子表示法</strong>。</p>
<h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>任意一棵树，结点的第一个孩子如果存在就是唯一的，结点的右兄弟如果存在也是唯一。</p>
<p>孩子兄弟表示法，即设置两个指针，分别指向该结点的第一个孩子和该结点的右兄弟，<code>data|firstchild|rightsib</code>。</p>
<p>孩子兄弟法最大的好处，就是将一棵复杂的树变成一棵二叉树，从而可以利用二叉树的特性和算法处理这棵树。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的定义及特点"><a href="#二叉树的定义及特点" class="headerlink" title="二叉树的定义及特点"></a>二叉树的定义及特点</h4><p>二叉树（Binary Tree）是 n（n &gt;= 0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<p>二叉树有以下特点：</p>
<ul>
<li>每个结点最多有两棵子树</li>
<li>左子树和右子树有顺序</li>
<li>即使树中某个结点只有一颗子树，也要区分左右</li>
</ul>
<h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><p>所有结点都只有左子树的二叉树叫<strong>左斜树</strong>，所有结点都只有右子树的二叉树叫<strong>右斜树</strong>，统称为<strong>斜树</strong>。</p>
<p>如果二叉树的所有分支结点都存在左子树和右子树，且所有叶子结点都在同一层，这样的二叉树称为<strong>满二叉树</strong>。</p>
<p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1 &lt;= i &lt;= n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同，则这棵二叉树称为<strong>完全二叉树</strong>。</p>
<h4 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h4><ul>
<li>二叉树的第 i 层之多有 $2^{i-1}$ 个结点（i &gt;= 1）。</li>
<li>深度为 k 的二叉树至多有 $2^{k} - 1$ 个结点（k &gt;= 1）。</li>
<li>对任何一棵二叉树 T ，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 。</li>
</ul>
<blockquote>
<p>对于二叉树，全部结点数 n = n0 + n1 + n2 。</p>
<p>结点间连线数 = n - 1 = n1 + 2*n2 。</p>
<p>综上得到 n0 + n1 + n2 - 1 = n1 + 2n2 ，进而得到 n0 = n2 + 1 。</p>
</blockquote>
<ul>
<li>具有 n 个结点的完全二叉树深度为 $\lfloor log_2{n} \rfloor + 1$ （$\lfloor x \rfloor$ 表示不大于 x 的最大整数）。</li>
<li>对一棵有 n 个结点的完全二叉树按层序编号，对任意结点 i（1 &lt;= i &lt;= n）：<ul>
<li>如果 i = 1，则 i 是二叉树的根，无双亲；如果 i &gt; 1 ，则其双亲是结点 $\lfloor i/2 \rfloor$ 。</li>
<li>如果 2i &gt; n，则结点 i 无左孩子；否则其左孩子为结点 2i 。</li>
<li>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子为结点 2i + 1 。</li>
</ul>
</li>
</ul>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><p>二叉树的顺序存储结构，就是用一维数组，按完全二叉树中的层序依次存储二叉树中的结点，不存在的结点用空占位表示。右斜树等情况会浪费存储空间，所有顺序存储结构一般用于完全二叉树。</p>
<p>二叉树的链式存储结构成为二叉链表，即每个结点包含一个数据域和两个孩子指针域，<code>lchild|data|rchild</code> 。如果有需要，可以增加双亲指针域，称为三叉链表。</p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树的遍历，是指按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<p>如果限定了从左到右的遍历方式，可分为以下 4 种：</p>
<ul>
<li>前序遍历：先访问根结点，然后前序遍历左子树，再前序遍历右子树。</li>
<li>中序遍历：从根结点开始（不是先访问根结点），中序遍历根结点左子树，然后访问根结点，再中序遍历右子树。</li>
<li>后续遍历：按从左到右、先叶子后结点的方式遍历访问左右子树，最后访问根结点。</li>
<li>层序遍历：从树的第一层开始，从上而下逐层访问。</li>
</ul>
<p>二叉树的定义是用递归的方式，实现遍历算法也可以采用递归。</p>
<p>已知前序（或后续）遍历序列，和中序遍历序列，可以唯一确定一棵二叉树。</p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>包含 n 个结点的二叉链表，有 2n 个指针域，分支线数为 n - 1 ，也是是存在 2n - (n - 1) = n + 1 个空指针域。</p>
<p>这些空指针域可以用来存放结点在某种遍历次序下的前驱和后继结点的地址。这种指向前驱和后继的指针称为<strong>线索</strong>，加上线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong>。对二叉树以某种次数遍历使其变为线索二叉树的过程称为<strong>线索化</strong>。</p>
<h4 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h4><p>对树的处理非常复杂，很难去研究树的性质和算法，转为二叉树就容易得多。</p>
<p>以下为几种转换的具体步骤。</p>
<h5 id="树转为二叉树"><a href="#树转为二叉树" class="headerlink" title="树转为二叉树"></a>树转为二叉树</h5><ol>
<li>所有兄弟结点间加线。</li>
<li>对树的每个结点，保留它与第一个孩子结点的连线，去掉与其他孩子结点间的连线。</li>
<li>层次调整。</li>
</ol>
<h5 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h5><ol>
<li>把每棵树转为二叉树。</li>
<li>从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，并用线连接。</li>
</ol>
<h5 id="二叉树转为树"><a href="#二叉树转为树" class="headerlink" title="二叉树转为树"></a>二叉树转为树</h5><ol>
<li>若某结点的左孩子结点存在，将这个左孩子的右孩子结点、右孩子的…右孩子结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接。</li>
<li>删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。</li>
</ol>
<h5 id="二叉树转为森林"><a href="#二叉树转为森林" class="headerlink" title="二叉树转为森林"></a>二叉树转为森林</h5><ol>
<li>从根结点开始，若右孩子存在，则删除与右孩子结点的连线，再处理分离后的二叉树，直到所有右孩子连线都被删除。</li>
<li>将每个分离后的二叉树转为树。</li>
</ol>
<h4 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h4><p>树的遍历分为两种方式：</p>
<ul>
<li>先根遍历：先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>后根遍历：先后跟遍历根结点的每棵子树，然后访问根结点。</li>
</ul>
<p>森林的遍历也分为两种方式：</p>
<ul>
<li>前序遍历：每棵树依次先根遍历。</li>
<li>后序遍历：每棵树依次后根遍历。</li>
</ul>
<h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><p>从树中的一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度就是从根结点到每个结点路径长度之和。</p>
<p>结点的带权路径长度为路径长度与权的乘积，树的带权路径长度为树中所有叶子结点的带权路径长度之和。</p>
<p>假设有 n 个权值 {w1, w2, … ,wn} ，构造一棵有 n 个叶子结点的二叉树，每个叶子结点权值为 wk ，每个叶子结点的路径长度为 lk ，其中<strong>带权路径长度 WPL 最小</strong>的二叉树称为<strong>赫夫曼树</strong>。</p>
<p>赫夫曼树的构造方法：</p>
<ol>
<li>将带权叶子结点按权值由小到大排序。</li>
<li>取前 2 个权值最小的结点作为一个新结点 N1 的左右孩子结点（权值较小的是左孩子），新结点的权值为 2 个结点权值之和。</li>
<li>用 N1 结点替换其 2 个孩子结点，插入结点序列，并保持序列权值从小到大的顺序。</li>
<li>重复步骤 2 。</li>
</ol>
<p>设需要编码的字符集为 {d1, d2, … , dn} ，各个字符在电文中出现的次数或频率集合为 {w1, w2, … , wn} ，以字符集作为叶子结点，以次数或频次为权值构建一棵赫夫曼树。规定左分支代表 0 ，右分支代表 1 ，从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列即该结点对应字符的编码，称为赫夫曼编码。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2016/07/07/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表（List）：零个或多个数据元素的有限序列。线性表中元素的个数即线性表的长度，元素个数为 0 的线程表为空表。</p>
<a id="more"></a>
<h3 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h3><p><strong>ADT</strong> ：线性表（List）</p>
<p><strong>Data</strong> ：线性表的数据对象集合为 {a1, a2, a3 … an} ，每个元素的类型均为 DataType。除第一个元素外，每个元素有且只有一个直接前驱元素；除最后一个元素外，每个元素有且只有一个直接后继元素。数据元素之间为一对一的关系。</p>
<p><strong>Operation</strong> ：</p>
<ul>
<li>init（创建一个空表）</li>
<li>isEmpty（判断线性表是否为空）</li>
<li>clear（清空线性表）</li>
<li>get（获取第 i 个位置的元素）</li>
<li>indexOf（获取指定元素在线性表中的位置）</li>
<li>insert（插入元素）</li>
<li>delete（删除元素）</li>
<li>length（获取线性表长度）</li>
</ul>
<p>endADT</p>
<h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><p>线性表的存储结构分为 <strong>顺序存储结构</strong> 和 <strong>链式存储结构</strong> 两种。</p>
<h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>线性表的顺序存储结构，指用一段地址连续的存储单元依次存储线性表的数据元素，可以用一维数组来实现。线性表的顺序存储结构实现称为顺序表。</p>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>线性表的链式存储结构中，每个存储单元除了存储元素数据外，额外存储一个指示其后继元素位置的信息。线性表的链式存储结构实现称为链表。</p>
<p>存储数据元素信息的域称为数据域，存储后继元素位置信息的域称为指针域，两部分信息合在一起称为结点 Node。链表中每个结点包含一个指针域，所以称为单链表。</p>
<h4 id="两种存储结构的对比"><a href="#两种存储结构的对比" class="headerlink" title="两种存储结构的对比"></a>两种存储结构的对比</h4><p>顺序存储结构无需为元素之间的逻辑关系增加额外的存储空间，并且可以快速存储表中任一位置的元素；而链式存储结构插入和删除操作不需要移动大量元素，也不必提前分配存储空间。</p>
<p>如需要频繁查找，而很少进行插入和删除操作，宜使用顺序存储结构；如元素个数变化较大不好确认范围，或需要频繁插入和删除，宜使用链式存储结构。</p>
<h4 id="其他链表结构"><a href="#其他链表结构" class="headerlink" title="其他链表结构"></a>其他链表结构</h4><ul>
<li>静态链表</li>
</ul>
<p>静态链表即用数组描述的链表，每个元素有数据域和指针域。</p>
<p>第一个元素的指针域用于存放第一个未使用的结点位置，最后一个元素的指针域用于存放第一个使用中的结点位置，不使用指针。</p>
<ul>
<li>循环链表</li>
</ul>
<p>单链表中终端结点的指针域由空改为指向头结点。</p>
<ul>
<li>双向链表</li>
</ul>
<p>跟单链表相比，每个节点再设置一个指向其前驱结点的指针域。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>管理 Kafka</title>
    <url>/2018/07/25/%E7%AE%A1%E7%90%86-Kafka/</url>
    <content><![CDATA[<p>Kafka 提供了一些用于管理集群变更的命令行工具，这些工具由 Java 实现，Kafka 提供一些脚本来调用这些 Java 类。这些工具只提供一些基本的功能，无法完成复杂操作。Kafka 社区有很多高级工具，如 Kafka Manager。</p>
<a id="more"></a>
<h2 id="一、主题操作"><a href="#一、主题操作" class="headerlink" title="一、主题操作"></a>一、主题操作</h2><p>使用 kafka-topics.sh 可以执行主题的大部分操作，如创建、修改、删除和查看集群内的主题（配置变更部分已经移动到 kafka-configs.sh 中），使用时需要通过 –zookeeper 参数提供 ZooKeeper 地址，如 zoo1.example.com:2181/kafka。</p>
<h3 id="1-创建主题"><a href="#1-创建主题" class="headerlink" title="1.创建主题"></a>1.创建主题</h3><p>在集群内创建主题，需要指定主题名、复制系数和分区数 3 个必要参数，主题名建议不适用英文句号及下划线（会用于度量指标），格式为 <code>kafka-topics.sh --zookeeper &lt;zookeeper connect&gt; --create --topic &lt;topic name&gt; --replication-factor &lt;integer&gt; --partitions &lt;integer&gt;</code> 。</p>
<p>如果不需要基于机架信息的分配分区，可以指定参数 <code>--disable-rack-aware</code> 。添加 <code>--if-not-exists</code> 参数可以仅在主题不存在时创建主题。</p>
<h3 id="2-增加分区"><a href="#2-增加分区" class="headerlink" title="2.增加分区"></a>2.增加分区</h3><p>主题基于分区进行伸缩和复制，当需要扩展主题容量或降低单个分区吞吐量时可以增加分区，如果消费者群组内需要增加消费者，主题的分区数也需要增加至大于组内消费者数。</p>
<p>对于基于键来划分消息分区的主题，改变分区数会导致键和分区的映射关系发生变化，对于这种主题，最好在一开始就确定好分区数，尽量不要调整。</p>
<p>调整主题分区数的命令格式为 <code>kafka-topics.sh --zookeeper &lt;zookeeper connect&gt; --alter --topic &lt;topic name&gt; --partitions &lt;integer&gt;</code> ，<code>--if-exists</code> 参数可以在主题不存在时忽略错误。</p>
<p>通常情况下无法减少主题的分区数，如果删除了分区，分区内的数据也会被删除，导致数据不一致。如果一定要减少分区数，只能删除整个主题，然后重新创建。</p>
<h3 id="3-删除主题"><a href="#3-删除主题" class="headerlink" title="3.删除主题"></a>3.删除主题</h3><p>如果一个主题不再使用，可以删除主题从而减少磁盘占用、释放资源。要删除主题，broker 的 delete.topic.enable 参数必须为 true，否则删除请求会被忽略。</p>
<p>删除命令的格式为 <code>kafka-topics.sh --zookeeper &lt;zookeeper connect&gt; --delete --topic &lt;topic name&gt;</code> 。</p>
<h3 id="4-列出集群内主题"><a href="#4-列出集群内主题" class="headerlink" title="4.列出集群内主题"></a>4.列出集群内主题</h3><p><code>kafka-topics.sh --zookeeper &lt;zookeeper connect&gt; --list</code> 用于列出集群内的所有主题，将 <code>--list</code> 参数改为 <code>--describe</code> 参数会列出包含分区数等信息的主题。指定 <code>--topic &lt;topic name&gt;</code> 可以用于主题过滤。</p>
<p>如果要找出所有包含覆盖配置的主题可以添加 <code>--topics-with-overrides</code> 参数，<code>under-replicated-partitions</code> 参数用于列出包含不同步副本的分区，<code>--unavailable-partition</code> 参数可以列出所有没有首领的分区。注意这些参数都不能和 <code>--topic</code> 参数一起使用。</p>
<h2 id="二、消费者群组操作"><a href="#二、消费者群组操作" class="headerlink" title="二、消费者群组操作"></a>二、消费者群组操作</h2><p>Kafka 提供 kafka-consumer-groups.sh 工具来列出消费者群组信息，对于旧版的 Kafka 还可以删除消费者群组和管理偏移量。新版 Kafka 的消费者群组信息保存在 broker 中，使用命令行工具时需要指定 –bootstrap-server；旧版 Kafka 的消费者群组信息保存在 ZooKeeper 中，使用时需指定 –zookeeper。</p>
<h3 id="1-列出并描述群组"><a href="#1-列出并描述群组" class="headerlink" title="1.列出并描述群组"></a>1.列出并描述群组</h3><p>通过命令 <code>kafka-consumer-groups.sh --bootstrap-server &lt;server connect&gt; --list</code> 可以列出所有的消费者群组，将 <code>--list</code> 改为 <code>--describe</code> ，并通过 <code>--group &lt;group name&gt;</code> 参数指定特定的群组，可以获得该群组更详细的信息。</p>
<h3 id="2-删除群组"><a href="#2-删除群组" class="headerlink" title="2.删除群组"></a>2.删除群组</h3><p>旧版本的 Kafka 支持使用命令行工具删除群组，也支持在不删除群组的情况下删除单个主题的偏移量。注意，删除群组或偏移量前必须关闭组内所有消费者，否则可能会导致消费者不可预测的行为。</p>
<p>删除群组的命令格式为 <code>kafka-consumer-groups.sh --zookeeper &lt;zookeeper connect&gt; --delete --group &lt;group name&gt;</code> 。删除主题偏移量的命令格式为 <code>kafka-consumer-groups.sh --zookeeper &lt;zookeeper connect&gt; --delete --group &lt;group name&gt; --topic &lt;topic name&gt;</code> 。</p>
<h3 id="3-管理偏移量"><a href="#3-管理偏移量" class="headerlink" title="3.管理偏移量"></a>3.管理偏移量</h3><p>旧版本的 Kafka 将偏移量保存在 ZooKeeper 的 /consumers 路径下，通过命令 <code>kafka-run-class.sh kafka.tools.ExportZkOffsets --zkconnect &lt;zk connect&gt; --group &lt;group name&gt; --output-file &lt;file name&gt;</code> 可以导出偏移量到文件，而通过命令 <code>kafka-run-class.sh kafka.tools.ImportZkOffsets --zkconnect &lt;zk connect&gt; --group &lt;group name&gt; --input-file &lt;file name&gt;</code> 可以将偏移量导入。</p>
<p>注意导入时必须关闭所有消费者，否则有可能将导入的偏移量覆盖掉。</p>
<p>新版本的 Kafka 将偏移量保存在一个内部主题 __consumer_offsets 中，目前没有工具管理客户端提交到 Kafka 的偏移量，只能通过客户端使用相应 API 提交群组偏移量。</p>
<h2 id="三、动态配置变更"><a href="#三、动态配置变更" class="headerlink" title="三、动态配置变更"></a>三、动态配置变更</h2><p>在集群处于运行状态时，可以通过 kafka-configs.sh 来覆盖主题及客户端的配置参数，一旦设置完毕，就会成为集群的永久配置，保存在 ZooKeeper 中，broker 会读取它们。</p>
<h3 id="1-覆盖主题的默认配置"><a href="#1-覆盖主题的默认配置" class="headerlink" title="1.覆盖主题的默认配置"></a>1.覆盖主题的默认配置</h3><p>为了满足不同的使用场景，主题可以进行单独的配置，配置在没有被覆盖的情况下使用 broker 的默认配置。更改主题配置的命令格式为 <code>kafka-configs.sh --zookeeper &lt;zk connect&gt; --alter --entity-type topics --entity-name &lt;topic name&gt; --add-config &lt;key&gt;=&lt;value&gt;[,&lt;key&gt;=&lt;value&gt;...]</code> 。</p>
<h3 id="2-覆盖客户端的默认配置"><a href="#2-覆盖客户端的默认配置" class="headerlink" title="2.覆盖客户端的默认配置"></a>2.覆盖客户端的默认配置</h3><p>对于 Kafka 客户端，只能覆盖生产者和消费者的配额，即每秒在单个 broker 上的生产速率和消费速率，如有 2 个 broker，配额为 10 MB/s，则生成数据的总速率为 20 MB/s。</p>
<p>修改客户端配置的命令格式为 <code>kafka-configs.sh --zookeeper &lt;zk connect&gt; --alter --entity-type clients --entity-name &lt;client-id&gt; --add-config &lt;key&gt;=&lt;value&gt;[,&lt;key&gt;=&lt;value&gt;...]</code> 。可选参数有 producer_byte_rate 和 consumer_byte_rate。</p>
<h3 id="3-列出被覆盖的配置"><a href="#3-列出被覆盖的配置" class="headerlink" title="3.列出被覆盖的配置"></a>3.列出被覆盖的配置</h3><p>此功能通过 –describe 来实现，格式为 <code>kafka-configs.sh --zookeeper &lt;zk connect&gt; --describe --entity-type topics --entity-name &lt;topic name&gt;</code> 。该命令只能显示被覆盖的配置，包含 broker 的默认配置。</p>
<h3 id="4-移除被覆盖的配置"><a href="#4-移除被覆盖的配置" class="headerlink" title="4.移除被覆盖的配置"></a>4.移除被覆盖的配置</h3><p>动态配置可以被移除，恢复到集群的默认配置，命令格式为 <code>kafka-configs.sh --zookeeper &lt;zk connect&gt; --alter --entity-type topics --entity-name &lt;topic name&gt; --delete-config &lt;config key&gt;</code> 。</p>
<h2 id="四、分区管理"><a href="#四、分区管理" class="headerlink" title="四、分区管理"></a>四、分区管理</h2><p>Kafka 提供了两个用于管理分区的工具，一个用于重新选举首领，另一个用于将分区分配给 broker。</p>
<h3 id="1-首领选举"><a href="#1-首领选举" class="headerlink" title="1.首领选举"></a>1.首领选举</h3><p>broker 有一个配置 auto.leader.rebalance.enable 用于启用自动首领再均衡，即如果当前首领不是首选首领会自动触发再均衡，不过不建议在生产环境使用此功能，在大型集群中可能带来严重的性能问题。</p>
<p>Kafka 提供命令行工具来手动触发副本选举，命令格式为 <code>kafka-perferred-replica-election.sh --zookeeper &lt;zk connect&gt;</code> 。</p>
<p>进行选举时，集群元数据需要写入 ZooKeeper，如果元数据超过节点允许的大小（默认 1 MB）就会选举失败。这种情况需要将分区清单的信息写到一个 JSON 文件中，通过参数 <code>--path-to-json &lt;json file&gt;</code> 分多个步骤进行。JSON 文件的格式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"partitions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"partition"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"t1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"partition"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"t2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-修改分区副本"><a href="#2-修改分区副本" class="headerlink" title="2.修改分区副本"></a>2.修改分区副本</h3><p>主题的分区在集群内分配不均衡时会造成负载的不均衡，Kafka 提供了 kafka-reassign-partitions.sh 工具来修改分区分布。首先需要根据 broker 清单和主题清单生成一组迁移步骤，然后执行迁移步骤，最后（可选）使用生成的迁移步骤验证分区重新分配的进度和完成情况。</p>
<p>为了生成迁移步骤，首先需要创建一个包含了主题清单的 JSON 文件，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"topics"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"t1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"t2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令 <code>kafka-reassign-partitions.sh --zookeeper &lt;zk connect&gt; --generate --topics-to-move-json-file &lt;json file&gt; --broker-list &lt;brokers&gt;</code> 会得到两个 JSON，其中 brokers 为使用英文逗号分隔的 broker id。第一个为当前分配情况，可以用于回滚；第二个为分配步骤。</p>
<p>使用命令 <code>kafka-reassign-partitions.sh --zookeeper &lt;zk connect&gt; --execute --reassignment-json-file &lt;josn file&gt;</code> 来执行第二个步骤。  </p>
<p>重分配完成后可以使用命令 <code>kafka-reassign-partitions.sh --zookeeper &lt;zk connect&gt; --verify --reassignment-json-file &lt;json file&gt;</code> 来验证重分配情况。</p>
<h3 id="3-修改复制系数"><a href="#3-修改复制系数" class="headerlink" title="3. 修改复制系数"></a>3. 修改复制系数</h3><p>分区重分配工具提供了修改分区复制系数的功能，不过没有在文档中说明。如果在创建分区时指定了错误的复制系数，可以通过创建一个 JSON 对象并通过分区重分配工具完成对复制系数的修改。JSON 的格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"partitions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"partition"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"replicas"</span>: [</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"topic"</span>: <span class="string">"t1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"version"</span>: <span class="number">1</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-查看日志片段"><a href="#4-查看日志片段" class="headerlink" title="4.查看日志片段"></a>4.查看日志片段</h3><p>通过命令 <code>kafka-run-class.sh kafka.tools.DumpLogSegments --file &lt;file&gt;</code> 可以在不读取消息的情况下查看消息内容，接收以逗号分隔的日志片段文件清单为参数，打印出每个消息的概要信息及数据内容。</p>
<p>这个工具也会检查日志片段的索引文件，–index-sanity-check 将会检查无用的索引，–verify-index-only 将会只检查索引匹配而不打印出全部索引。</p>
<h3 id="5-副本验证"><a href="#5-副本验证" class="headerlink" title="5.副本验证"></a>5.副本验证</h3><p>kafka-replica-verification.sh 工具用于验证集群副本分区一致性，从指定分区的副本上获取消息并检查所有副本是否具有相同的消息，使用时需使用正则表达式传入要验证的主题，否则会检查所有的主题，另外需要显示地提供 broker 清单，格式为 <code>kafka-replica-verification.sh --broker-list &lt;broker list&gt; --topic-white-list &lt;regexp&gt;</code> 。</p>
<h2 id="五、控制台生产者和消费者"><a href="#五、控制台生产者和消费者" class="headerlink" title="五、控制台生产者和消费者"></a>五、控制台生产者和消费者</h2><p>有时为了验证应用程序，可以使用命令行工具 kafka-console-producer.sh 和 kafka-console-consumer.sh 手动生成和读取消息，不过不应该在生产环境采用此种方式，控制台生产者和消费者无法使用客户端的所有特性，本篇文章不对这部分做详细介绍。</p>
<h2 id="六、不安全操作"><a href="#六、不安全操作" class="headerlink" title="六、不安全操作"></a>六、不安全操作</h2><p>有些操作在技术上是可行的，但涉及 ZooKeeper 上的元数据，有可能给应用程序带来风险，除非情况紧急，否则不应该使用。</p>
<h3 id="1-移动集群控制器"><a href="#1-移动集群控制器" class="headerlink" title="1.移动集群控制器"></a>1.移动集群控制器</h3><p>有时需要将控制器从一个 broker 移到另一个 broker 上，如当前控制器网络波动大无法提供正常服务。手动删除 /controller 节点会释放当前控制器，集群会进行新的控制器选举。</p>
<h3 id="2-取消分区重分配"><a href="#2-取消分区重分配" class="headerlink" title="2.取消分区重分配"></a>2.取消分区重分配</h3><p>分区重分配是并行进行的，一般情况下没理由取消任务，不过如果在重分配进行一半时，broker 发生故障且无法重启，就会导致重分配无法结束，这是可以让集群忽略这个任务，即从 ZooKeeper 中删除 /admin/reassign_partitions 节点并重新选举控制器（删除 /controller 节点）。</p>
<p>注意，取消重分配时，旧的 broker 不会在副本清单中删除，导致部分分区的复制系数比正常的大。如果主题的分区包含不同的复制系数，broker 会禁止对其操作（如增加分区），所以需要在取消任务后检查分区可用性，确保复制系数正确。</p>
<h3 id="3-移除待删除的主题"><a href="#3-移除待删除的主题" class="headerlink" title="3.移除待删除的主题"></a>3.移除待删除的主题</h3><p>使用命令行删除主题，会在 ZooKeeper 上创建一个节点作为删除主题的请求，正常会立即执行这个请求，但如果集群没有开启删除主题的功能，请求会被挂起。删除 /admin/delete_topic 节点下创建的以删除主题名字命名的子节点即可移除被挂起的请求。</p>
<h3 id="4-手动删除主题"><a href="#4-手动删除主题" class="headerlink" title="4.手动删除主题"></a>4.手动删除主题</h3><p>如果集群禁用了删除主题的功能，或者需要通过非正式的途径删除主题，可以进行手动删除。</p>
<p>手动删除前，首先需要关闭集群内所有的 broker，否则会造成集群不稳定。然后删除 /brokers/topics/TOPICNAME 路径（先删除其子节点）。接着删除每个 broker 的分区目录（log-dirs），名称为 <code>&lt;topic name&gt;-&lt;partition id&gt;</code>。最后重启所有 broker。</p>
<h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><p><a href="http://kafka.apache.org/documentation/" target="_blank" rel="noopener">Kafka 官方文档</a></p>
<p><a href="http://shop.oreilly.com/product/0636920044123.do" target="_blank" rel="noopener">Kafka 权威指南</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式中的基本原则</title>
    <url>/2018/08/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
<p>使用设计模式能够增加代码的可维护性、可重用性、可扩展性及灵活性，进而改善系统的设计。</p>
<p>设计模式遵从以下原则：单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、最小知识原则和复用原则。下面将分别介绍这些设计原则。</p>
<a id="more"></a>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则，即对一个类而言，应该仅有一个引起它变化的原因。</p>
<p>每个类应该只负责单一的功能。如果一个类承担的职责过多，维护、复用的难度就会增大，同时缺乏灵活性。将多个职责耦合在一起，其中一个职责的变化可能会削弱或抑制完成其他职责的能力，对类产生破坏。</p>
<h2 id="开放-闭合原则"><a href="#开放-闭合原则" class="headerlink" title="开放-闭合原则"></a>开放-闭合原则</h2><p>开放-闭合原则，即软件实体（类、模块、函数等）应该可以扩展，但是不可修改。</p>
<p>当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有代码来实现变化，因为修改可能会引入错误，并且需要重新测试。</p>
<h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>里氏代换原则，即子类型必须能够替换掉它们的父类型。</p>
<p>一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且察觉不出父类对象和子类对象的区别。把父类替换为子类，程序的行为不发生变化。</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两个都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。</p>
<p>要针对接口编程，不要针对实现编程，因为现实中实现时相对易变的，而抽象是相对稳定的。依赖抽象时，实现的变化不会影响客户端调用。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则也称为最小化原则，强调一个接口拥有的行为应该尽可能的小。</p>
<p>如果接口拥有一些多余的行为，类在实现接口时很多方法是空着的，会给使用者造成假象，导致调用时没有得到想要的结果。</p>
<h2 id="最小知识原则"><a href="#最小知识原则" class="headerlink" title="最小知识原则"></a>最小知识原则</h2><p>最小知识原则也称为迪米特法则，即如果两个类不必彼此直接通信，那么两个类就不应该发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法，可以通过第三者转发这个调用。</p>
<p>最小知识原则强调类之间的松耦合，类之间的耦合越弱，越有利于复用。处于弱耦合的类被修改，不会对有关系的类造成波及。</p>
<h2 id="复用原则"><a href="#复用原则" class="headerlink" title="复用原则"></a>复用原则</h2><p>复用原则也称为合成/聚合复用原则。合成/聚合即在新对象中使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。</p>
<p>复用原则强调尽量使用合成/聚合，尽量不要使用继承。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之中介者模式</title>
    <url>/2019/08/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互，使各对象不需要显示地相互引用，从而使其耦合松散，且可以独立地改变它们之间的交互，属于行为型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>中介者模式由抽象中介 Mediator 、抽象同事 Colleague 、具体中介 ConcreteMediator 和多个具体同事 ConcreteColleague 组成。</p>
<p>其中 Mediator 定义一个抽象的、将消息发给 Colleague 的方法；Colleague 持有一个 Mediator 的引用，定义抽象的发送、接收消息的方法；ConcreteMediator 实现 Mediator 中定义的发送消息方法，同时持有全部的 Mediator 引用；ConcreteColleague 继承 Colleague，通过持有的 Mediator 引用实现发送、接收消息的抽象方法。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>简化同事类 Colleague 的设计和实现。</p>
<p>简化同事类 Colleague 之间的交互，降低其间的解耦性。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>中介者类中包含全部同事类之间的交互细节，可能会导致其非常复杂、难以维护。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>系统中一组对象以定义良好却复杂的方式进行通信时，可以使用中介者模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循最小知识原则（迪米特法则），违反单一职责原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        String receiver = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line">        System.out.println(receiver + <span class="string">" receive message: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueA</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueA</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator.send(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueB</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueB</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator.send(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcreteColleagueA colleagueA;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleagueB colleagueB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueA</span><span class="params">(ConcreteColleagueA colleagueA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleagueA = colleagueA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueB</span><span class="params">(ConcreteColleagueB colleagueB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleagueB = colleagueB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colleagueA == colleague) &#123;</span><br><span class="line">            colleagueB.receive(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            colleagueA.receive(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteMediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line"></span><br><span class="line">        ConcreteColleagueA colleagueA = <span class="keyword">new</span> ConcreteColleagueA(mediator);</span><br><span class="line">        ConcreteColleagueB colleagueB = <span class="keyword">new</span> ConcreteColleagueB(mediator);</span><br><span class="line"></span><br><span class="line">        mediator.setColleagueA(colleagueA);</span><br><span class="line">        mediator.setColleagueB(colleagueB);</span><br><span class="line"></span><br><span class="line">        colleagueA.send(<span class="string">"hello"</span>);</span><br><span class="line">        colleagueB.send(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之享元模式</title>
    <url>/2019/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>享元模式（Flyweight Pattern），运用共享技术有效地支持大量细粒度的对象，属于结构型模式。</p>
<a id="more"></a>
<p>程序设计中有时需要生成大量细粒度的实例来表示数据，如果这些实例除了少部分参数外都相同，可以将这部分参数移到实例外，调用方法时再传入，通过共享大幅减少实例数。</p>
<p>对象内共享的部分称为内部状态，随环境而变化、不可共享的部分称为外部状态。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>享元模式由抽象享元类（或接口）AbstractFlyweight，具体享元类 ConcreteFlyweight 和享元工厂 FlyweightFactory 组成。</p>
<p>其中 AbstractFlyweight 接受并作用于外部状态；ConcreteFlyweight 继承或实现 AbstractFlyweight，维护内部状态；FlyweightFactory 用于创建和管理 Flyweight 对象。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>通过共享大幅度减少实例的数目。</p>
<p>外部状态相对独立，而且不会影响其内部状态，使得享元对象可以在不同的环境中被共享。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>使系统更加复杂，需要分离出内部状态和外部状态。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>系统中存在大量相同或者相似的对象，造成内存的大量耗费时可以使用享元模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>无。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Website</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebsite</span> <span class="keyword">extends</span> <span class="title">Website</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebsite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"网站："</span> + name + <span class="string">" 用户："</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsiteFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Website&gt; websiteMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Website <span class="title">getWebsite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Website website = websiteMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(website)) &#123;</span><br><span class="line">            <span class="keyword">return</span> website;</span><br><span class="line">        &#125;</span><br><span class="line">        Website newWebsite = <span class="keyword">new</span> ConcreteWebsite(name);</span><br><span class="line">        websiteMap.put(name, newWebsite);</span><br><span class="line">        <span class="keyword">return</span> newWebsite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWebsiteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> websiteMap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WebsiteFactory websiteFactory = <span class="keyword">new</span> WebsiteFactory();</span><br><span class="line"></span><br><span class="line">        Website blog1 = websiteFactory.getWebsite(<span class="string">"blog"</span>);</span><br><span class="line">        blog1.use(<span class="string">"小A"</span>);</span><br><span class="line"></span><br><span class="line">        Website blog2 = websiteFactory.getWebsite(<span class="string">"blog"</span>);</span><br><span class="line">        blog2.use(<span class="string">"小B"</span>);</span><br><span class="line"></span><br><span class="line">        Website blog3 = websiteFactory.getWebsite(<span class="string">"blog"</span>);</span><br><span class="line">        blog3.use(<span class="string">"小C"</span>);</span><br><span class="line"></span><br><span class="line">        Website shopping1 = websiteFactory.getWebsite(<span class="string">"shopping"</span>);</span><br><span class="line">        shopping1.use(<span class="string">"小D"</span>);</span><br><span class="line"></span><br><span class="line">        Website shopping2 = websiteFactory.getWebsite(<span class="string">"shopping"</span>);</span><br><span class="line">        shopping2.use(<span class="string">"小E"</span>);</span><br><span class="line"></span><br><span class="line">        Website shopping3 = websiteFactory.getWebsite(<span class="string">"shopping"</span>);</span><br><span class="line">        shopping3.use(<span class="string">"小F"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"网站数量："</span> + websiteFactory.getWebsiteCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2018/08/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问，属于结构型模式。</p>
<p>客户端不直接引用一个对象，而是通过代理实现间接引用。代理在客户端和目标对象之间起到中介的作用，可以通过代理对象去掉客户端不能看到的内容和服务，也可以添加客户端需要的额外服务。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>代理模式由抽象主题、代理主题和真实主题组成。</p>
<p>其中抽象主题定义主题的公开访问接口；真实主题实现抽象主题接口，包含具体的逻辑；代理主题包含一个真实主题的引用，代理主题通过调用真实主题的方法被客户端使用。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>能够协调调用者和被调用者，降低耦合度；通过使用一个小对象来代表一个大对象，减少开销；可以控制对真实对象的使用权限；也可以对真实主题添加额外的操作。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>客户端和真实主题之间增加了代理对象，有些类型的代理可能会造成处理速度变慢。</p>
<p>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>远程代理，为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中。</p>
<p>虚拟代理，如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</p>
<p>保护代理，控制对主题的访问，可以给不同的用户提供不同级别的使用权限。</p>
<p>智能引用代理，提供一些额外的操作。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循开闭原则和复用原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"real subject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        realSubject.describe();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Subject subject = <span class="keyword">new</span> ProxySubject();</span><br><span class="line">    	subject.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2018/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式（singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点，属于创建型模式。</p>
<p>类自身负责创建和保存它的唯一实例，保证没有其他实例被创建，并且提供一个访问该实例的方法。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>单例模式仅由一个单例类组成，包含一个公有的静态实例，或者包含一个私有的静态实例并提供公开访问方法。</p>
<p>另外需要将构造方法设为私有（private），防止外部程序通过 new 创建实例。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>单例类封装了它的唯一实例，可以严格控制客户何时以及怎样访问它。</p>
<p>在系统内存中只存在一个对象，节约系统资源。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>没有抽象层，扩展有很大的困难。</p>
<p>单例类的职责过重，既是工厂又是产品。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对象需要是全局且唯一时可以使用单例模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>在一定程度上违背了单一职责原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之原型模式</title>
    <url>/2018/08/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>原型模式（Prototype），用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，属于创建型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>原型模式仅由实现了 Cloneable 接口的原型类组成，原型类通过 clone 方法拷贝原型创建新的对象。</p>
<blockquote>
<p>拷贝分为浅拷贝和深拷贝。</p>
<p>浅拷贝指的是被复制对象的所有变量都与原来的对象相同，对其他对象的引用仍然指向原来的对象。</p>
<p>深拷贝会把引用对象的变量指向复制过的新对象，而不是原有的被引用对象。</p>
<p>Java 中默认采用浅拷贝，如果要实现深拷贝，且要拷贝的原型对象中包含引用类型（不可变类型除外），需要重写克隆方法实现深拷贝。</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>当要创建的新对象实例较为复杂时，使用原型模式可以简化创建过程，提高创建效率。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>深拷贝需要对类进行通盘考虑，编写较为复杂的代码。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个类对象的创建成本较大，且需要创建跟已有对象相同或相似的新对象时，或者需要复用对象状态时，适合使用原型模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>无。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkExperience</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workDate;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkExperience</span><span class="params">(String workDate, String company)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workDate = workDate;</span><br><span class="line">        <span class="keyword">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> WorkExperience workExperience;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, WorkExperience workExperience)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.workExperience = workExperience;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", workExperience="</span> + workExperience +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.workExperience = (WorkExperience) workExperience.clone();</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	Person personA = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">10</span>, <span class="keyword">new</span> WorkExperience(<span class="string">"2000-01-01"</span>, <span class="string">"XX"</span>));</span><br><span class="line">    	Person personB = personA.clone();</span><br><span class="line">        System.out.println(personA);</span><br><span class="line">        System.out.println(personB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之命令模式</title>
    <url>/2019/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>命令模式（Command Pattern）：将一个请求封装为一个对象，从而可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作，属于行为型模式。</p>
<p>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>命令模式由抽象命令 AbstractCommand、具体命令 ConcreteCommand、调用者 Invoker 和接收者 Receiver 组成。</p>
<p>其中 AbstractCommand 用于声明执行操作的接口；ConcreteCommand 持有接收者对象，通过调用接收者来实现执行操作的接口；Invoker 触发命令的执行；Receiver 负责实际执行请求的相关操作。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>降低行为请求者和实现者间的耦合。</p>
<p>可以比较容易地设计一个命令队列。</p>
<p>方便将命令记入日志。</p>
<p>可与在接收请求时否决请求。</p>
<p>容易实现对请求的撤销和重做。</p>
<p>新的命令不影响其他类，可以很容易地加入到系统中。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>可能会导致系统中存在过多的具体命令类。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要将行为请求者和实现者解耦，或需要支持命令的排队、撤销、重做时可以使用命令模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循开闭原则、单一职责原则和最小知识原则（迪米特法则）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"action"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCommands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commands.forEach(Command::execute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line"></span><br><span class="line">        Command command1 = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        invoker.addCommand(command1);</span><br><span class="line"></span><br><span class="line">        Command command2 = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        invoker.addCommand(command2);</span><br><span class="line"></span><br><span class="line">        Command command3 = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        invoker.addCommand(command3);</span><br><span class="line"></span><br><span class="line">        invoker.executeCommands();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之备忘录模式</title>
    <url>/2019/07/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后可以将该对象恢复到原先保存的状态，属于行为型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>备忘录模式由发起人 Originator、备忘录 Memento 和管理者 Caretaker 组成。</p>
<p>其中 Originator 是持有状态的对象，可以创建备忘录 Memento 来记录状态，并可以使用备忘录恢复到之前的状态；Memento 负责存储 Originator 的内部状态；Caretaker 负责保存备忘录 Memento。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>提供了一种状态恢复的实现机制。</p>
<p>实现了信息的封装，备忘录来保存发起人的状态，使发起人复杂的内部信息对其他对象透明。</p>
<p>简化了发起人 Originator，不需要自己管理和保存内部状态的多个版本。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>会占用更多的资源，尤其在状态数据较大的情况下。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要提供状态恢复机制时，可以使用备忘录模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循最小知识原则（迪米特法则）和开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoveryByMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = memento.getStatus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"status = "</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        originator.setStatus(<span class="string">"good"</span>);</span><br><span class="line">        originator.show();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">        caretaker.setMemento(originator.createMemento());</span><br><span class="line">        originator.setStatus(<span class="string">"bad"</span>);</span><br><span class="line">        originator.show();</span><br><span class="line">        originator.recoveryByMemento(caretaker.getMemento());</span><br><span class="line">        originator.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之外观模式</title>
    <url>/2018/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，属于结构型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>外观模式由子系统角色和外观角色组成。</p>
<p>其中子系统包含一组操作，外观角色对子系统的操作进行组装，对外提供常用公共接口。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>对客户端屏蔽子系统组件，松耦合，减少客户端关联的对象，使得子系统使用起来更加容易。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不能很好地限制客户端使用子系统类，如果做太多的限制又减少了可变性和灵活性。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在层次化结构中，使用外观模式定义系统中每一层的入口。</p>
<p>为复杂子系统提供简单的、可以满足多数用户需求的接口。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循最小知识原则（迪米特法则）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemA operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemA operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemB operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubSystemB operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystemA subSystemA = <span class="keyword">new</span> SubSystemA();</span><br><span class="line">    <span class="keyword">private</span> SubSystemB subSystemB = <span class="keyword">new</span> SubSystemB();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA.operation1();</span><br><span class="line">        subSystemB.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA.operation2();</span><br><span class="line">        subSystemB.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">    	facade.operation1();</span><br><span class="line">    	facade.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂方法模式</title>
    <url>/2018/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂方法模式（FACTORY METHOD）是一种创建型设计模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类，使类的实例化延迟到其子类，是对简单工厂模式的抽象，克服了简单工厂违背开闭原则的缺点。</p>
<p>在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>抽象工厂模式由抽象产品、具体产品、抽象工厂和具体工厂组成。</p>
<p>抽象产品定义产品的接口；具体产品实现了抽象产品的接口；抽象工厂定义生产抽象产品的接口；具体工厂实现抽象工厂的接口，生产具体的产品。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>在工厂方法模式中，工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部，客户端无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>另外，系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而需要添加一个具体工厂和具体产品，扩展性非常强，完全符合开闭原则。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在添加新产品时，需要编写新的具体产品类并提供对应的具体工厂，系统中类的个数成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>希望产品的种类对客户端保持透明，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂，具体的产品对象由具体工厂类创建。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、依赖倒置原则和开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Factory factory1 = <span class="keyword">new</span> FactoryA();</span><br><span class="line">    	Product product1 = factory1.createProduct();</span><br><span class="line">    	product1.describe();</span><br><span class="line">    	Factory factory2 = <span class="keyword">new</span> FactoryB();</span><br><span class="line">    	Product product2 = factory2.createProduct();</span><br><span class="line">    	product2.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造者模式</title>
    <url>/2018/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>建造者模式（Builder）又称为生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，属于创建型模式。</p>
<p>复杂对象的组合过程被外部化到一个称作建造者的对象中，建造者返还给客户端的是一个已经建造完毕的完整产品对象，用户无须关心该对象所包含的属性以及它们的组装方式。</p>
<p>通常，Builder 解决具有大量参数的构造函数不好用的问题，解决让 Object 始终保持 valid 状态的问题。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>建造者模式由抽象建造者、具体建造者、指挥者和产品构成。</p>
<p>抽象建造者给出抽象接口，用于定义产品各个组成部分的建造及产品的返回；具体建造者实现抽象建造者接口，定义实际的建造过程及产品返回；指挥者负责通过具体建造者来创建产品对象；产品则是要建造的复杂对象。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦。</p>
<p>改变产品的内部表示只需定义一个具体建造者，无须修改原有代码，便于扩展。</p>
<p>将复杂产品的创建步骤分解在不同的方法中，创建过程更清晰、更容易控制。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果产品的内部变化复杂，可能会需要定义很多具体建造者类，导致系统变得很庞大。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>类里的成员很多，同时希望维持 object 自始至终处于 valid / 不可变状态。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则和开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; parts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPart</span><span class="params">(String part)</span> </span>&#123;</span><br><span class="line">        parts.add(part);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        parts.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderA</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.addPart(<span class="string">"X"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.addPart(<span class="string">"Y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderB</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.addPart(<span class="string">"M"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.addPart(<span class="string">"N"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">buildProduct</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        builder.buildPart2();</span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	BuilderA builderA = <span class="keyword">new</span> BuilderA();</span><br><span class="line">    	Product product1 = Director.buildProduct(builderA);</span><br><span class="line">    	product1.describe();</span><br><span class="line"></span><br><span class="line">    	BuilderB builderB = <span class="keyword">new</span> BuilderB();</span><br><span class="line">    	Product product2 = Director.buildProduct(builderB);</span><br><span class="line">    	product2.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(Integer age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person.<span class="function">PersonBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person.PersonBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PersonBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">age</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>.age, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <url>/2018/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类，属于创建型模式。</p>
<p>与工厂方法模式相比，抽象工厂模式中工厂创造的不止是一个产品，而是一个产品族。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>抽象工厂模式由一个抽象工厂、多个具体工厂、多个抽象产品和多个具体产品组成。</p>
<p>其中多个抽象产品声明一系列的产品接口；具体产品实现相应产品接口；抽象工厂声明生成一系列抽象产品的方法；具体工厂实现抽象工厂的接口，生成一系列的具体产品。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>隔离了具体产品类的生成，客户不需要知道被创建的具体产品类。</p>
<p>具体工厂实现了抽象工厂中定义的公共接口，只需改变具体工厂的实例，就可以改变一系列具体产品的生成。当一个产品族中的多个对象被设计成一起工作时，能够保证客户端始终只使用同一个产品族中的对象。</p>
<p>增加新的具体工厂和产品族很方便，无须修改已有系统。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在添加新的产品对象时，需要在抽象工厂中添加生成新产品的抽象方法，并在所有的具体工厂中实现生成新产品的方法。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>系统中有多于一个的产品族，而每次只使用其中某一产品族，且不必知道产品的具体种类。 </p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、依赖倒置原则和开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">describeA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">describeB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductB2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">ProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory1</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Factory factory = <span class="keyword">new</span> Factory1();</span><br><span class="line"><span class="comment">//    	Factory factory = new Factory2();</span></span><br><span class="line">    	ProductA productA = factory.createProductA();</span><br><span class="line">    	ProductB productB = factory.createProductB();</span><br><span class="line">    	productA.describeA();</span><br><span class="line">    	productB.describeB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之桥接模式</title>
    <url>/2019/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>桥接模式（Bridge），将抽象部分与它的实现部分分离，使它们都可以独立的变化，属于结构型模式。</p>
<p>桥接模式中，实现的系统有多个角度的分类，每种分类都有可能变化，将继承关系转换为关联关系，让各种变化分离出来，使它们独立变化，减少各种变化之间的耦合。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>桥接模式由实现类接口 Implementor、具体实现类 ConcreteImplementor、抽象类 Abstraction 和扩充抽象类 RefinedAbstraction 组成。</p>
<p>其中实现类接口定义一种变化，具体实现类为其变化的具体实现；而抽象类为持有实现类接口引用的抽象，扩充抽象类继承抽象类，通过持有实现类接口来应对变化。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>抽象接口及其实现部分分离。 </p>
<p>实现细节对客户端透明。</p>
<p>提高了系统的可扩充性，在多个变化维度中任意扩展一个维度，不需要修改原有系统。 </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加系统的理解与设计难度，需要针对抽象进行设计与编码。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个对象有多个维度的变化，需要将各种变化分离出来，使其独立变化时，可以使用桥接模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、最小知识原则（迪米特法则）、开闭原则，和复用原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImplementorColor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorRedColor</span> <span class="keyword">implements</span> <span class="title">ImplementorColor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorGreenColor</span> <span class="keyword">implements</span> <span class="title">ImplementorColor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"green"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractionShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ImplementorColor implementorColor;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractionShape</span><span class="params">(ImplementorColor implementorColor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.implementorColor = implementorColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstractionCircle</span> <span class="keyword">extends</span> <span class="title">AbstractionShape</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstractionCircle</span><span class="params">(ImplementorColor implementorColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(implementorColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        implementorColor.draw();</span><br><span class="line">        System.out.println(<span class="string">"circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ImplementorColor redColor = <span class="keyword">new</span> ConcreteImplementorRedColor();</span><br><span class="line">        ImplementorColor greenColor = <span class="keyword">new</span> ConcreteImplementorGreenColor();</span><br><span class="line">        RefinedAbstractionCircle redCircle = <span class="keyword">new</span> RefinedAbstractionCircle(redColor);</span><br><span class="line">        RefinedAbstractionCircle greenCircle = <span class="keyword">new</span> RefinedAbstractionCircle(greenColor);</span><br><span class="line">        redCircle.draw();</span><br><span class="line">        greenCircle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之模板方法模式</title>
    <url>/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>模板方法模式（Template Method Pattern）：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构而重新定义某些特定步骤，属于行为型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>模板方法模式由抽象类 AbstractClass 和实现类 ConcreteClass 组成。</p>
<p>其中 AbstractClass 给出一个顶级逻辑的骨架，逻辑的组成步骤在相应的抽象操作中，推迟到子类实现；ConcreteClass 实现父类定义的一个或多个抽象方法，从而使得顶级逻辑的实现各不相同。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>将不变的行为放在父类，去除了子类中的重复代码。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>算法骨架改变时需要修改抽象类。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当系统中算法的骨架固定，而实现可能有很多种时，可以使用模板方法模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循复用原则，违反里氏替换原则（子类影响到了父类）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTestPaper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">questionA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 + 1 = ?"</span>);</span><br><span class="line">        System.out.println(answerA());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">questionB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 - 1 = ?"</span>);</span><br><span class="line">        System.out.println(answerB());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">answerA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">answerB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTestPater</span> <span class="keyword">extends</span> <span class="title">AbstractTestPaper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">answerA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">answerB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractTestPaper testPaper = <span class="keyword">new</span> ConcreteTestPater();</span><br><span class="line">        testPaper.questionA();</span><br><span class="line">        testPaper.questionB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之状态模式</title>
    <url>/2019/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>状态模式（State Pattern）：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类，属于行为型模式。</p>
<p>状态模式描述了对象状态的变化，以及对象如何在不同状态下表现出不同的行为。通过引入了一个抽象的状态类来表示状态，每一种具体状态类都继承此类，在不同的具体状态类中实现不同状态的行为，且包括状态之间的转换。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>状态模式由抽象状态 State 、具体状态 ConcreteState 和上下文 Context 组成。</p>
<p>其中 State 定义行为接口；ConcreteState 实现 State 中定义的接口，将不同状态下的行为单独提取出来进行封装；Context 持有 State ，行为随 State 的改变而改变。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>行为封装在状态中，修改对象状态即可改变对象的行为。</p>
<p>不同状态的行为被分割开，方便增加新的状态和行为。</p>
<p>状态对象封装了状态的转换规则，从而减少巨大的条件语句块。</p>
<p>多个上下文可以共享状态对象，减少系统中对象的个数。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>结构与实现都较为复杂，使用不当会导致程序结构和代码混乱。</p>
<p>会增加系统中类和对象的个数。</p>
<p>对开闭原则的支持不够好。（对于可以切换状态的状态模式，增加新的状态类需要修改状态转换逻辑，否则无法切换到新增状态；修改状态类的行为也需修改对应类的源代码。）</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对象的行为随状态改变而改变、状态变化依靠大量的分支判断语句实现时，可以使用状态模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、依赖倒置原则和开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WORKING IN "</span> + context.getState().getClass().getSimpleName());</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WORKING IN "</span> + context.getState().getClass().getSimpleName());</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state.work(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">        context.request();</span><br><span class="line">        context.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之策略模式</title>
    <url>/2019/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>策略模式（Strategy），定义算法家族，分别封装，算法之间可以相互替换，算法的变化不影响使用算法的客户端，属于行为型模式。</p>
<p>在策略模式中，由客户端自己决定在什么情况下使用什么具体策略角色。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>策略模式由抽象策略、具体策略和上下文 context 组成。</p>
<p>其中抽象策略定义所支持算法的公共接口；具体策略封装具体的算法、行为，实现抽象策略；context 维护一个策略的引用，提供执行所引用策略的方法。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>遵循开闭原则，客户端能够在不修改原有程序的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p>
<p>可以通过继承将各算法中的公共功能提取出来。</p>
<p>减少各种算法与客户端之间的耦合。</p>
<p>避免使用多重条件判断语句。</p>
<p>简化了单元测试。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>客户端必须知道所有的策略类，并决定使用哪一个策略类（可以通过与简单工厂结合来解决）。</p>
<p>将产生很多策略类。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要在不同场景使用不同的业务规则，就可以使用策略模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、依赖倒转原则、开闭原则、最小知识原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Concrete Strategy A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Concrete Strategy B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context;</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">        context.contextInterface();</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">        context.contextInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与简单工厂结合"><a href="#与简单工厂结合" class="headerlink" title="与简单工厂结合"></a>与简单工厂结合</h3><p>单独使用策略模式，需要客户端知道所有的策略类，并决定使用哪一个策略类。</p>
<p>与简单工厂结合，可以将策略的选择过程从客户端转到工厂，即 context ，改造后的 context 和客户端如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String strategyType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"A"</span>.equals(strategyType)) &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="string">"A"</span>);</span><br><span class="line">        context.contextInterface();</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="string">"B"</span>);</span><br><span class="line">        context.contextInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之简单工厂模式</title>
    <url>/2018/08/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>简单工厂模式也叫静态工厂方法模式，属于创建型模式，但不属于 23 中 GOF 设计模式之一。</p>
<p>该模式即由一个工厂对象决定创建出哪一种产品类的实例，是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>简单工厂模式通常由一个工厂类、一个产品接口和多个实现了产品接口的具体产品类组成。</p>
<p>其中工厂类包含了必要的逻辑判断，根据客户端的选择条件动态地实例化相关的类。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>对于客户端而言，去除了对具体产品的依赖。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>由于工厂类集中了所有实例的创建逻辑，所能创建的类只能是事先考虑到的，如果需要添加新的类，必须要修改工厂类。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要在一堆产品中根据某个参数选择其中一个产品，而工厂类负责创建的产品种类较少。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责，违背开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"A"</span>.equals(type)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ProductA();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Product product1 = SimpleFactory.createProduct(<span class="string">"A"</span>);</span><br><span class="line">    	Product product2 = SimpleFactory.createProduct(<span class="string">"B"</span>);</span><br><span class="line">    	product1.describe();</span><br><span class="line">    	product2.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之组合模式</title>
    <url>/2019/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>组合模式（Composite Pattern），将对象组合成树形结构以表示 <strong>部分-整体</strong> 的层次结构，使得用户对单个对象和组合对象的使用具有一致性，属于结构型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>组合模式由抽象接口 Component 、 叶节点对象 Leaf 和枝节点对象 Composite 组成。</p>
<p>其中 Component 声明接口，也可以实现共有接口的默认行为；Leaf 实现 Component 接口，没有子节点；Composite 同样实现 Component 接口，且持有 Leaf 子节点。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>客户端可以一致地使用组合结构和单个对象，调用简单。</p>
<p>容易在组合体内加入新对象，客户端不必因为加入新对象而更修改代码。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>使设计更加抽象，对象的业务规则如果很复杂，实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象有关联。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要表示 <strong>部分-整体</strong> 的层次结构，且希望通过一种方式忽略整体与部分的差异、一致对待时，可以使用组合模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循依赖倒转原则、开闭原则，破坏接口隔离原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanyComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompanyComponent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CompanyComponent company)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CompanyComponent company)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompanyComposite</span> <span class="keyword">extends</span> <span class="title">CompanyComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;CompanyComponent&gt; companies = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCompanyComposite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CompanyComponent company)</span> </span>&#123;</span><br><span class="line">        companies.add(company);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CompanyComponent company)</span> </span>&#123;</span><br><span class="line">        companies.remove(company);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.display(prefix);</span><br><span class="line">        companies.forEach(company -&gt; company.display(prefix + <span class="string">"-"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HRDepartmentLeaf</span> <span class="keyword">extends</span> <span class="title">CompanyComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HRDepartmentLeaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompanyComponent root = <span class="keyword">new</span> ConcreteCompanyComposite(<span class="string">"北京总公司"</span>);</span><br><span class="line">        root.add(<span class="keyword">new</span> HRDepartmentLeaf(<span class="string">"总公司人力资源部"</span>));</span><br><span class="line"></span><br><span class="line">        CompanyComponent company1 = <span class="keyword">new</span> ConcreteCompanyComposite(<span class="string">"上海分公司"</span>);</span><br><span class="line">        company1.add(<span class="keyword">new</span> HRDepartmentLeaf(<span class="string">"上海分公司人力资源部"</span>));</span><br><span class="line">        root.add(company1);</span><br><span class="line"></span><br><span class="line">        CompanyComponent company2 = <span class="keyword">new</span> ConcreteCompanyComposite(<span class="string">"武汉分公司"</span>);</span><br><span class="line">        company2.add(<span class="keyword">new</span> HRDepartmentLeaf(<span class="string">"武汉分公司人力资源部"</span>));</span><br><span class="line">        root.add(company2);</span><br><span class="line"></span><br><span class="line">        root.display(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之职责链模式</title>
    <url>/2019/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>职责链模式（Chain of Responsibility Pattern），使多个对象都有机会处理请求，从而避免请求的发送者和接收者之前的耦合关系。将这些接收者对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止，属于行为型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>职责链模式由抽象处理类 Handler 和多个具体处理类 ConcreteHandler 组成。</p>
<p>其中 Handler 定义处理请求的接口；ConcreteHandler 实现处理请求的接口，处理请求或转发给其他 ConcreteHandler 。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>降低请求发送者和接收者间的耦合度。</p>
<p>可以灵活调整请求处理类的职责。</p>
<p>方便增加新的请求处理类。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不能保证请求一定被处理。</p>
<p>使用不当可能会造成循环调用。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>请求需要多个接收者对象中的一个或几个协作处理时，可以使用职责链模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、开闭原则和最小知识原则（迪米特法则）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler successorHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessorHandler</span><span class="params">(Handler successorHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successorHandler = successorHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" : "</span> + request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            successorHandler.handle(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" : "</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteHandler1 handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">        ConcreteHandler2 handler2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line"></span><br><span class="line">        handler1.setSuccessorHandler(handler2);</span><br><span class="line"></span><br><span class="line">        handler1.handle(<span class="number">50</span>);</span><br><span class="line">        handler1.handle(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之装饰模式</title>
    <url>/2018/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>装饰模式（Decorator），动态地给一个对象增加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活，属于结构型模式。</p>
<p>跟代理模式相比，装饰模式更注重动态地添加功能，被装饰对象在运行时才能确定，而代理模式更注重控制访问，客户端不关心代理类了哪个类，也不会多次嵌套。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>装饰模式由抽象组件、具体组件、抽象装饰和具体装饰组成。</p>
<p>其中抽象组件定义组件的行为；具体组件实现抽象组件的接口；抽象装饰继承或实现（抽象类）抽象组件，包含抽象组件的方法；具体装饰通过一个动态添加的抽象组件引用来完成原有操作，并在其前后增加装饰功能。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>更加灵活地扩展对象的功能。</p>
<p>使用不同具体装饰类的排列组合，可以创造出不同行为的组合。</p>
<p>解耦包含基本功能的组件和包含装饰功能的装饰类。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰类将增加系统的复杂度，加大对系统学习与理解的难度。</p>
<p>更加灵活意味着更易出错，对于多次装饰的对象，寻找错误需要逐级排查，较为烦琐。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个类需要动态添加功能，且这些功能可以相互叠加。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、开闭原则和复用原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentA</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"component A operation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"decorator A start"</span>);</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">"decorator A end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Decorator decorator = <span class="keyword">new</span> DecoratorA(<span class="keyword">new</span> ComponentA());</span><br><span class="line">        decorator.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之观察者模式</title>
    <url>/2019/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>观察者模式（Observer Pattern），又叫发布-订阅模式（Publish/Subscribe Pattern），定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，主题对象的状态发生变化时，会通知所有的观察者对象，使它们能够更新自己，属于行为型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>观察者模式由抽象主题 Subject、具体主题 ConcreteSubject、抽象观察者 Observer 和具体观察者 ConcreteObserver 组成。</p>
<p>其中 Subject 持有一组观察者，且提供可以增加和删除观察者的接口；ConcreteSubject 实现或继承 Subject ，包含被观察的状态，状态改变时通知所有登记过的观察者；Observer 定义一个接口，收到主题通知时更新自己；ConcreteObserver 实现 Observer ，在接到通知后使自身状态与主题状态相协调。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>定义了稳定的消息更新传递机制，支持广播通信。</p>
<p>在主题和观察者之间建立一个抽象的耦合，使得可以有不同的表示层作为具体观察者角色。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>主题有大量的观察者时，通知所有的观察者可能会耗时较长。</p>
<p>现实中很多情况下，不同的具体观察者没有实现同一个 Observer 。（可以通过事件委托解决）</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个对象改变将导致其他一个或多个对象也发生改变，且需要降低对象之间的耦合度时，可以使用观察者模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循最小知识原则（迪米特法则）、开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers.forEach(Observer::update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String subjectStatus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSubjectStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subjectStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubjectStatus</span><span class="params">(String subjectStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subjectStatus = subjectStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> ConcreteSubject subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String observerStatus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObserver</span><span class="params">(String name, ConcreteSubject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observerStatus = subject.getSubjectStatus();</span><br><span class="line">        System.out.println(name + <span class="string">" 状态随主题变化为 "</span> + observerStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer observer1 = <span class="keyword">new</span> ConcreteObserver(<span class="string">"observer1"</span>, subject);</span><br><span class="line">        Observer observer2 = <span class="keyword">new</span> ConcreteObserver(<span class="string">"observer2"</span>, subject);</span><br><span class="line">        subject.attach(observer1);</span><br><span class="line">        subject.attach(observer2);</span><br><span class="line">        subject.setSubjectStatus(<span class="string">"[new status]"</span>);</span><br><span class="line">        subject.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之解释器模式</title>
    <url>/2019/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>解释器模式（Interpreter Pattern），定义语言的文法，并定义一个解释器来解释语言中的句子，属于行为型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>解释器模式由上下文 Context 、抽象表达式 AbstractExpression 、终结符表达式 TerminalExpression 和非终结符表达式 NonterminalExpression 组成。</p>
<p>其中 Context 包含解释器之外的一些全局信息；AbstractExpression 声明一个抽象的解释操作；TerminalExpression 实现与文法中终结符相关的解释操作；NonterminalExpression 实现与文法中非终结符相关的解释操作。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>易于修改和扩展文法。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>复杂文法实现难度较大。</p>
<p>执行效率较低。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>发生频率较高的问题可以用简单的语言表达、文法较为简单时，可以使用解释器模式来解决该问题。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、开闭原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DictionaryContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; dictionary = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        dictionary.put(<span class="string">"today"</span>, <span class="string">"今天"</span>);</span><br><span class="line">        dictionary.put(<span class="string">"is"</span>, <span class="string">"是"</span>);</span><br><span class="line">        dictionary.put(<span class="string">"a"</span>, <span class="string">"一个"</span>);</span><br><span class="line">        dictionary.put(<span class="string">"good"</span>, <span class="string">"好"</span>);</span><br><span class="line">        dictionary.put(<span class="string">"day"</span>, <span class="string">"日子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChinese</span><span class="params">(String englishWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dictionary.get(englishWord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interpret</span><span class="params">(StringBuilder stringBuilder)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SymbolExpression</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"."</span>.equals(value)) &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordExpression</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(DictionaryContext.getChinese(word.toLowerCase()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sentence = <span class="string">"Today is a good day.Today is a good day.Today is a good day."</span>;</span><br><span class="line">        System.out.println(translate(sentence));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">translate</span><span class="params">(String sentence)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;Expression&gt; expressions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] elements = sentence.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : elements) &#123;</span><br><span class="line">            String[] words = element.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                expressions.add(<span class="keyword">new</span> WordExpression(word));</span><br><span class="line">            &#125;</span><br><span class="line">            expressions.add(<span class="keyword">new</span> SymbolExpression(<span class="string">"."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Expression expression : expressions) &#123;</span><br><span class="line">            expression.interpret(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之迭代器模式</title>
    <url>/2019/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>迭代器模式（Iterator Pattern），提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示，属于行为型模式。</p>
<p>大部分高级语言本身就已经实现了迭代器模式，如 Java 中的 foreach 会被编译器处理为 Iterator。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>迭代器模式由抽象迭代类 Iterator 、具体迭代类 ConcreteIterator 、抽象聚合类 Aggregate 和具体聚合类 ConcreteAggregate 组成。</p>
<p>其中 Iterator 定义获取下一个对象、判断是否到尾部等接口；ConcreteIterator 为 Iterator 的具体实现；Aggregate 包含一个获取 Iterator 的接口；ConcreteAggregate 实现 Aggregate 接口，包含获取 Iterator 的具体逻辑。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>存储和遍历数据的职责分离，迭代器简化了聚合类。</p>
<p>支持以不同的方式遍历一个聚合对象。</p>
<p>方便增加新的聚合类和迭代器类，无须修改原有代码。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>存储和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，一定程度上增加了系统的复杂性。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要遍历聚合对象的内容而无须关注内部表示，需要为聚合对象提供多种遍历方式，或需要为不同聚合结构提供一个统一接口时，可以使用迭代器模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循单一职责原则、开闭原则和最小知识原则（迪米特法则）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">createIterator</span><span class="params">(<span class="keyword">boolean</span> asc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIteratorAsc</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate&lt;T&gt; aggregate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIteratorAsc</span><span class="params">(ConcreteAggregate&lt;T&gt; aggregate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aggregate = aggregate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate.get(currentIndex++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentIndex &lt; aggregate.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIteratorDesc</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate&lt;T&gt; aggregate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIteratorDesc</span><span class="params">(ConcreteAggregate&lt;T&gt; aggregate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aggregate = aggregate;</span><br><span class="line">        <span class="keyword">this</span>.currentIndex = aggregate.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate.get(currentIndex--);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentIndex &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">createIterator</span><span class="params">(<span class="keyword">boolean</span> asc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> asc ? <span class="keyword">new</span> ConcreteIteratorAsc&lt;&gt;(<span class="keyword">this</span>) : <span class="keyword">new</span> ConcreteIteratorDesc&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.remove(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aggregate&lt;Integer&gt; aggregate = <span class="keyword">new</span> ConcreteAggregate&lt;&gt;();</span><br><span class="line">        aggregate.add(<span class="number">1</span>);</span><br><span class="line">        aggregate.add(<span class="number">2</span>);</span><br><span class="line">        aggregate.add(<span class="number">3</span>);</span><br><span class="line">        aggregate.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator1 = aggregate.createIterator(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator2 = aggregate.createIterator(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator2.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之访问者模式</title>
    <url>/2019/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>访问者模式（Visitor Pattern），表示一个作用于某对象结构中的各元素的操作，可以在不改变各元素的类的前提下定义作用于这些元素的新操作，属于行为型模式。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>访问者模式由抽象访问者 Visitor、具体访问者 ConcreteVisitor 、抽象元素 Element 、具体元素 ConcreteElement 和对象结构 ObjectStructure 组成。</p>
<p>其中 Element 定义一个 accept 操作，以一个访问者为参数； ConcreteElement 为 Element 的具体实现，通过传入的访问者实现 accept 操作； ObjectStructure  能够枚举所包含的元素，并提供允许访问其元素的高层接口； Visitor 为 ObjectStructure 中元素的每一个类声明 visit 操作；ConcreteVisitor 实现 Visitor 中定义的操作，每个操作实现对应 ObjectStructure 中元素的一个类。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>将数据结构和作用于结构上的操作解耦，使增加和修改访问操作变得容易。</p>
<p>将一组元素类的访问行为集中到一个访问者对象中，而非分散到各个元素类中。 </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加新的元素类很困难，每增加一个新的元素类，都需要在 Visitor 增加新的接口，并在每一个具体访问者类中增加相应的具体操作。</p>
<p>破坏元素的封装，需要暴露给访问者使用。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个对象结构中包含多个类型的对象，需要执行依赖其具体类型的操作，且数据结构相对稳定，而作用于结构上的操作需要频繁变动时，可以使用访问者模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循倾斜的开闭原则（修改访问行为遵循开闭原则，增加新元素破坏开闭原则）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visitElementA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visitElementB(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA elementA)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB elementB)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA elementA)</span> </span>&#123;</span><br><span class="line">        System.out.println(elementA.getClass().getSimpleName() + <span class="string">"被 visitElementA 访问"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB elementB)</span> </span>&#123;</span><br><span class="line">        System.out.println(elementB.getClass().getSimpleName() + <span class="string">"被 visitElementB 访问"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        elements.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        elements.forEach(element -&gt; element.accept(visitor));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line"></span><br><span class="line">        objectStructure.attach(<span class="keyword">new</span> ElementA());</span><br><span class="line">        objectStructure.attach(<span class="keyword">new</span> ElementB());</span><br><span class="line"></span><br><span class="line">        objectStructure.accept(<span class="keyword">new</span> ConcreteVisitor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配器模式</title>
    <url>/2018/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>适配器模式（Adapter），将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作，属于结构型模式。</p>
<p>适配器提供客户类需要的接口，而实现就是把客户类的请求转化为对适配者的相应接口的调用，而这个过程对客户类是透明的。</p>
<p>适配器模式分为类适配器和对象适配器，类适配器使用继承，而对象适配器使用组合。</p>
<a id="more"></a>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>适配器模式由抽象目标、适配者类和适配器类组成。</p>
<p>其中抽象目标定义客户需要的接口；适配者类提供不兼容于抽象目标的接口；适配器类通过适配者提供的方法来实现抽象目标定义的接口。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>通过引入适配器来重用现有的类，解耦目标类和适配者类。</p>
<p>客户端可以统一调用相同的接口。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>过多地使用适配器会使系统非常零乱，如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要使用一个类的功能，但是该类的接口不符合使用场景要求的接口。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>遵循开闭原则和复用原则。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象概述</title>
    <url>/2020/03/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="什么面向对象编程"><a href="#什么面向对象编程" class="headerlink" title="什么面向对象编程"></a>什么面向对象编程</h3><p>面向对象编程（OOP，Object Oriented Programming），是一种编程范式或编程风格。以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p>
<p>面向对象编程语言（OOPL，Object Oriented Programming Language），是支持类或对象，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p>
<p>一般通过面向对象编程语言来进行面向对象编程，但不用面向对象编程语言，同样可以进行面向对象编程。反过来，使用面向对象编程语言，写出来的代码不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p>
<h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><p>封装、抽象、继承、多态是面向对象的四大特性，也有另外一种说法，即只包含封装、继承和多态的三大特性，不包含抽象。</p>
<h4 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h4><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。</p>
<p>封装这个特性，需要编程语言本身提供一定的语法机制（访问权限控制）来支持，如 Java 中 private、public 等关键字。</p>
<p>如果没有封装，代码会过于灵活和不可控，属性能以各种方式被修改，散落在各处，影响可读性和可维护性。另外，通过有限的方法暴露必要的操作，也能提高类的易用性，给调用者减负，无需了解细节。</p>
<h4 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h4><p>抽象即隐藏方法具体实现，让调用者只需关心方法提供的功能，而不需了解功能呢的实现细节。</p>
<p>在面向对象编程中，通常借助编程语言提供的接口类（如 Java 中的 interface 关键字）或者抽象类（如 Java 中的 abstract 关键字）这两种语法机制，来实现抽象这一特性。</p>
<p>实际上，抽象这个特性非常容易实现，并非只能依靠接口类或者抽象类这些特殊语法机制来支持。具体实现逻辑被函数包裹，本身就是一种抽象。</p>
<p>抽象是一个非常通用的设计思想，不仅可以用在 OOP 中，也可以用来指导架构设计等。同时抽象又不需要编程语言提供特殊的语法机制来支持，没有很强的特异性，所以有时不被看作 OOP 的特性之一。</p>
<p>抽象一方面能够提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p>
<p>在定义（命名）类的方法时，也要有抽象思维，不要在方法定义中暴露太多的实现细节。</p>
<h4 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h4><p>继承用来表示类之间的 is-a 关系，从关系上可以分为单继承和多继承两种模式。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类（有菱形继承的副作用）。</p>
<p>继承这个特性，需要编程语言提供特殊的语法机制来支持，如 Java 中的 extends 关键字。</p>
<p>继承最大的一个好处是代码复用（组合也可以解决复用问题），将不同类的相同属性和方法，抽取到父类中，让子类继承父类。另外通过继承表示 is-a 关系，非常符合人类的认知。</p>
<p>过度使用继承，继承层次过深过复杂，会导致代码可读性、可维护性变差。很多人觉得继承是一种反模式。</p>
<h4 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h4><p>多态，即在实际的代码运行过程中，子类可以替换父类，调用子类的方法实现。</p>
<p>多态需要编程语言提供特殊的语法机制来实现。编程语言需要支持父类对象可以引用子类对象，支持继承，支持子类可以重写（override）父类中的方法。</p>
<p>除利用继承加方法重写这种实现方式外，还有其他两种比较常见的的实现方式，一是利用接口类语法，二是利用 duck-typing 语法。</p>
<p>多态特性能提高代码的可扩展性和复用性。</p>
<h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>面向对象编程中，抽象类和接口是两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。</p>
<h4 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h4><p>接口不能包含属性，只能声明方法，方法不包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p>
<p>抽象类不允许被实例化，只能被继承，可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，解决<strong>解耦</strong>问题，隔离接口和具体的实现，提高代码的扩展性。</p>
<p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，解决代码<strong>复用</strong>问题。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，就使用接口。</p>
<p>如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，就使用抽象类。</p>
<h3 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h3><p>基于接口而非实现编程，是一条比较抽象、泛化的设计思想，能非常有效地提高代码质量。另一个表述方式是基于抽象而非实现编程。</p>
<p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。</p>
<p>定义接口时，命名要足够通用，不能包含跟具体实现相关的字眼，仅与特定实现有关的方法也不要定义在接口中。</p>
<p>越不稳定越需要接口。而如果在实际业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那就没有必要为其设计接口，可以直接使用实现类。</p>
<h3 id="继承还是组合"><a href="#继承还是组合" class="headerlink" title="继承还是组合"></a>继承还是组合</h3><p>在面向对象编程中，通常说组合优于继承。</p>
<p>继承主要是解决复用问题，而最大的问题是，继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。</p>
<p>通过组合、接口、委托三个技术手段，完全可以替换掉继承，不用或者少用继承关系，特别是一些复杂的继承关系。</p>
<p>继承并非一无是处，继承改写成组合要做更细粒度的类的拆分，增加代码的复杂程度和维护成本。</p>
<p>如果类之间的继承结构稳定、层次浅、关系简单，就可以使用继承。还有一些特殊的场景要求必须使用继承，如不能改变函数入参类型，还想使用多态。反之就尽量使用组合来替代继承。</p>
<h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p>除面向对象外，还有面向过程编程和函数式编程两种编程范式。面向过程随着面向对象的出现，已经慢慢退出舞台，而函数式编程目前还没有被广泛接受。</p>
<h4 id="什么是面向过程编程"><a href="#什么是面向过程编程" class="headerlink" title="什么是面向过程编程"></a>什么是面向过程编程</h4><p>面向过程编程是一种编程范式或编程风格，以过程（方法、函数、操作）作为组织代码的基本单元，主要特点为数据（成员变量、属性）与方法相分离，通过拼接一组顺序执行的方法来操作数据完成一项功能。</p>
<p>面向过程编程语言最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。</p>
<h4 id="面向对象编程的优势"><a href="#面向对象编程的优势" class="headerlink" title="面向对象编程的优势"></a>面向对象编程的优势</h4><ol>
<li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。OOP 更能应对这种复杂类型的程序。</li>
<li>面向对象具有封装、抽象、继承、多态四大特性，利用这些特性可以写出更加易复用、易扩展、易维护的代码。</li>
<li>OOP 语言更加人性化、更加高级、更加智能。</li>
</ol>
<h4 id="看似而不是面向对象的代码"><a href="#看似而不是面向对象的代码" class="headerlink" title="看似而不是面向对象的代码"></a>看似而不是面向对象的代码</h4><ol>
<li>滥用 getter、setter 方法，破坏封装。</li>
<li>滥用全局变量和全局方法，方法与数据分离。Constants 类和 Utils 类最常用到。</li>
<li>定义数据和方法分离的类，如基于 MVC 三层结构做 Web 方面的后端开发（贫血模型）。</li>
</ol>
<h4 id="为什么容易写出面向过程的代码"><a href="#为什么容易写出面向过程的代码" class="headerlink" title="为什么容易写出面向过程的代码"></a>为什么容易写出面向过程的代码</h4><ol>
<li>符合人的流程化思维方式。</li>
<li>相比面向对象要更加容易。</li>
</ol>
<h4 id="是否要杜绝面向过程"><a href="#是否要杜绝面向过程" class="headerlink" title="是否要杜绝面向过程"></a>是否要杜绝面向过程</h4><p>面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。</p>
<p>不管使用哪种风格来写代码，最终目的是写出易维护、易读、易复用、易扩展的高质量代码。只要能避免面向过程编程风格的一些弊端，控制好副作用，就不用避讳在面向对象编程中写面向过程风格的代码。</p>
<h3 id="业务开发模式"><a href="#业务开发模式" class="headerlink" title="业务开发模式"></a>业务开发模式</h3><p>很多业务系统基于 MVC 三层架构来开发，其中 M 表示 Model，V 表示 View，C 表示 Controller，项目分为展示层、逻辑层和数据层。</p>
<p>Web 或 App 项目很多都是前后端分离，其中后端负责提供接口给前端调用，又分为 Repository 层、Service 层和 Controller 层。Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。</p>
<h4 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h4><p>传统开发模式中，XxxEntity 和 XxxRepository 组成数据访问层，XxxBo 和 XxxService 组成业务逻辑层，XxxVo 和 XxxController 组成接口层。</p>
<p>Bo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 Service 中。</p>
<p>这种只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。</p>
<p>贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<h4 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h4><p>充血模型（Rich Domain Model）与贫血模型相反，数据和对应的业务逻辑被封装到同一个类中，满足面向对象的封装特性，是典型的面向对象编程风格。</p>
<p>领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。DDD 在 2004 年被提出，随微服务兴起而被熟知。</p>
<p>基于充血模型的 DDD 开发模式，跟基于贫血模型的传统开发模式之间的差别，主要在 Service 层。</p>
<p>DDD 开发模式中，Service 层由 Service 类和 Domain 类组成。Domain 就相当于贫血模型中的 Bo，区别在于既包含数据，也包含业务逻辑。而 Service 类变得非常单薄，仅负责与 Repository 交互、业务聚合和一些非功能性工作（如幂等、事务、日志等）。</p>
<h4 id="传统开发模式受欢迎的原因"><a href="#传统开发模式受欢迎的原因" class="headerlink" title="传统开发模式受欢迎的原因"></a>传统开发模式受欢迎的原因</h4><p>第一，大多系统业务比较简单，不需要精心设计充血模型，贫血模型足以应付。即便使用充血模型，模型本身包含的业务逻辑也不多，领域模型也比较单薄，跟贫血模型差别不大。</p>
<p>第二，充血模型的设计要比贫血模型更有难度。</p>
<p>第三，思维固化，有学习和转型的成本。</p>
<h4 id="何时该使用-DDD-开发模式"><a href="#何时该使用-DDD-开发模式" class="headerlink" title="何时该使用 DDD 开发模式"></a>何时该使用 DDD 开发模式</h4><p>基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。</p>
<p>除代码层面的区别外，两种开发模式有不同的开发流程。DDD 开发模式下，需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。需求的开发基于定义好的领域模型，在应对复杂业务系统开发时更有优势。</p>
<h3 id="面向对象分析和设计"><a href="#面向对象分析和设计" class="headerlink" title="面向对象分析和设计"></a>面向对象分析和设计</h3><p>跟 OOP 经常联系在一起的还有面向对象分析（OOA）和面向对象设计（OOD）。分析、设计、编程（实现），正是面向对象软件开发要经历的三个阶段。</p>
<h4 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h4><p>业务需求一般比较明确，而针对框架、类库、组件等非业务系统的开发，其中一个难点是需求一般比较抽象和模糊，需要自己去挖掘、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。</p>
<p>需求分析的过程实际上是一个不断迭代优化的过程。不要试图一次给出一个完美的解决方案，而是先给出一个基础的方案，然后再慢慢优化，这样的思考过程更容易摆脱无从下手的窘境。</p>
<h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><p>OOA 的产出是详细具体的需求描述，而 OOD 的产出是类，主要包含以下几个部分。</p>
<p>一、划分职责、识别出有哪些类。</p>
<p>可以根据需求描述，把功能点罗列出来，然后看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。如果需求非常复杂，功能点太多，先划分模块，再在模块内部划分和识别类。</p>
<p>二、定义类及其方法和属性。</p>
<p>识别出需求描述中的动词和名次，分别作为候选的方法和属性，再进行过滤筛选。</p>
<p>三、定义类与类之间的交互关系。</p>
<p>四、将类组装起来并提供执行入口。</p>
<hr>
<p>本篇文章是在学习极客时间 - 设计模式之美课程后的总结。可以扫描文章尾部的二维码，到专栏进行系统学习。</p>
<p><img src="https://blog.ulyssesss.com/assets/img/design-pattern.jpeg" alt="设计模式之美"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>运动饮食1:9</title>
    <url>/2020/01/08/%E8%BF%90%E5%8A%A8%E9%A5%AE%E9%A3%9F1-9/</url>
    <content><![CDATA[<p>本篇文章为阅读《运动饮食1:9》一书所做的简要笔记，记录减肥相关的知识点。</p>
<p>运动是必要的，但仅凭运动无法实现减肥的目的，关键在于改变饮食习惯。</p>
<a id="more"></a>
<h3 id="迈开腿不如管住嘴"><a href="#迈开腿不如管住嘴" class="headerlink" title="迈开腿不如管住嘴"></a>迈开腿不如管住嘴</h3><h4 id="运动减肥"><a href="#运动减肥" class="headerlink" title="运动减肥"></a>运动减肥</h4><p>要想减肥，必须保证消耗的卡路里小于摄入的卡路里，瘦不下来就是吃的太多。</p>
<p>饮食习惯是造成肥胖的主要原因，仅凭运动想把吃进去的能量消耗掉，是不切实际的。</p>
<p>运动会产生成就感，会产生变瘦的错觉，更会解放食欲。</p>
<p>跑步 30 分钟大约只消耗 300 千卡能量，一个甜面包就能补回来，而 1 千克脂肪含 7200 千卡能量。</p>
<p>高强度运动和为了减肥而进行的短期运动，消耗的能量大多来自于肝脏和肌肉中的糖原，而非脂肪。糖分被消耗掉之后，身体需要恢复到正常状态，所以对糖分的需求就更高。</p>
<h4 id="有氧运动"><a href="#有氧运动" class="headerlink" title="有氧运动"></a>有氧运动</h4><p>有氧运动即运动强度较低、持续时间较长、全身主要肌群共同参与的运动，氧气的利用率越高有氧性越高。反之，短期内的高强度运动称为无氧运动。</p>
<p>最容易燃烧脂肪的有氧运动，所消耗的能量也仅有一半来自脂肪，另一半来自于糖分。</p>
<p>长时间运动，脑内会分泌一种叫做内啡肽的神经传导物质，使人亢奋。</p>
<h4 id="基础代谢"><a href="#基础代谢" class="headerlink" title="基础代谢"></a>基础代谢</h4><p>基础代谢指一个人一天什么都不做，仅维持生命所要消耗的能量。</p>
<p>基础代谢有一个普遍观点，通过肌肉训练增加肌肉量，进而提高基础代谢，成为易瘦体质。但基础代谢中，肌肉仅占 18 % ，内脏消耗占 80 % 。增加 1 千克肌肉仅能将基础代谢提升 15 ~ 45 千卡。</p>
<p>普通女性基础代谢约为 1200 千卡，男性 1500 千卡，加上运动代谢的能量，女性一天约消耗 1800 千卡，男性约为 2400 千卡。</p>
<h3 id="危险食物"><a href="#危险食物" class="headerlink" title="危险食物"></a>危险食物</h3><h4 id="碳水化合物"><a href="#碳水化合物" class="headerlink" title="碳水化合物"></a>碳水化合物</h4><p>三大营养素：蛋白质、脂肪和碳水化合物。</p>
<p>碳水化合物，即平时所说的糖，米饭、面条、面包是碳水化合物的典型代表。几乎所有肥胖的人都摄入了过量的碳水化合物。</p>
<p>糖以血糖形式遍布全身，血液中血糖浓度称为血糖值，在消化吸收糖分后会上升。血糖上升会导致胰岛素的分泌，从而使血糖下降至正常水平。</p>
<p>GI 值（Glycemic Index）表示血糖值上升时糖分吸收的速度。食用后血糖值立刻上升的为高 GI 食品，上升慢的为 低 GI 食品。</p>
<p>食用高 GI 食品，会使大脑认为血糖上升过快，迅速分泌胰岛素，反而更加想吃东西。</p>
<p>减少糖的摄入量，确实有减肥的效果，但容易反弹。因为断糖会出现倦怠等不适应症状，大多数人通常只能坚持两个月。</p>
<p>减肥要尽可能选择低 GI 的碳水，而不是简单地断糖。尽量避免摄入经过深加工的糖以及液体化的糖，自然食品中的糖不用过于敏感地排斥。</p>
<h4 id="垃圾食品"><a href="#垃圾食品" class="headerlink" title="垃圾食品"></a>垃圾食品</h4><p>垃圾食品，指含有极高的卡路里，缺少维生素和矿物质，含有很多吸收速度极快的碳水和对身体有害的脂肪，以及大量添加剂的食物。如炸薯条、汉堡、薯片、爆米花，速食点心、面包、蛋糕和冰淇淋也属于垃圾食品。</p>
<p>垃圾食品中存在反式脂肪酸，一种为了延长保质期而人工合成的脂肪酸，典型代表为人造黄油。摄入反式脂肪酸会给消化器官造成极大负担，甚至引发疾病。</p>
<blockquote>
<p>美国作为垃圾食品大国，已经严禁使用反式脂肪酸了，可见其危害的严重性。</p>
<p>中国也要求在食品说明书上表明反式脂肪酸的含量。</p>
</blockquote>
<p>垃圾食品中另一个危险的东西是 AGEs，即晚期糖基化终末产物，由过量的糖和蛋白质通过热结合产生，如蛋糕烤熟后暗橙色的物质。血糖与肌肉和皮肤等蛋白质结合也会产生 AGEs 。</p>
<p>现代科学认为，AGEs 是导致黄褐斑、皱纹以及皮肤松弛的原因，还可能引发白内障和心脏病。糖化 = 细胞老化。</p>
<h4 id="加工食品"><a href="#加工食品" class="headerlink" title="加工食品"></a>加工食品</h4><p>超市里的巧克力不是真正的巧克力，成分最多的是砂糖，很多无添加、低盐也是惯用幌子，都必须进行防腐加工。24 小时便利店中任何时候都可以吃到东西的状态本身就是不正常的。</p>
<p>零卡路里饮料会使味觉以及精神层面对甜味变得迟钝，使肥胖风险增加 6 倍。</p>
<p>浓缩蔬菜汁和果汁中天然营养素很少，且无食物纤维导致容易摄入过量的糖，绝不是健康饮品。</p>
<p>一定要买加工食品，请买贵 3 倍的食物。</p>
<h3 id="饮食习惯"><a href="#饮食习惯" class="headerlink" title="饮食习惯"></a>饮食习惯</h3><h4 id="N-C-比"><a href="#N-C-比" class="headerlink" title="N/C 比"></a>N/C 比</h4><p>你现在的身体状态，是你选择、摄取、吸收的食物所表现出来的结果。</p>
<p>食物中除蛋白质、脂肪、碳水化合物这三种含卡路里的营养素外，还有矿物质营养素和维生素。</p>
<p>食物中矿物质营养素和维生素含量与总卡路里含量的比率，称为 N/C 比，Nutrient value / Calorie。</p>
<p>维生素和矿物质对代谢非常重要，是脂肪燃烧不可缺少的营养成分。高 N/C 比食物减肥法，是最有效的减肥方式。</p>
<h4 id="高-N-C-比食物"><a href="#高-N-C-比食物" class="headerlink" title="高 N/C 比食物"></a>高 N/C 比食物</h4><p>绿色蔬菜，指胡萝卜、南瓜、番茄、青椒、菠菜等深颜色的蔬菜，有助于减肥。</p>
<p>裙带菜、海带等海藻类，和芝麻、核桃等种子类食物，含适量的镁、钙、锌、铁等矿物质，还有丰富的维生素。种子类食物中还含有优质的脂肪。</p>
<p>蘑菇，含丰富的维生素，卡路里含量很低。</p>
<p>芋头类，如甘薯、芋头、山药，虽然属于碳水化合物，但维生素丰富，且含有很多食物纤维，适合作为减肥食品。</p>
<p>三大营养素中蛋白质最容易摄取不足，应从豆类和鱼类中主动摄取。肉类也可以吃，但不应该作为主要的蛋白质摄取源，控制在两成左右。</p>
<p>唯一对减肥有益的动物蛋白就是鱼类，含 DHA 和 EPA 等不容易产生体脂肪的优质油，且富含矿物质和植物性食物很难提供的 B 族维生素。</p>
<p>吃了低 N/C 比的食物后，应利用高 N/C 比食物进行中和，保证总体平衡，是减肥的关键。</p>
<h4 id="脂肪"><a href="#脂肪" class="headerlink" title="脂肪"></a>脂肪</h4><p>脂肪是仅次于碳水化合物的肥胖原因，而完全不摄入脂肪，会导致肌肤干燥、头发失去光泽等问题。</p>
<p>脂肪分解后产生脂肪酸，分为饱和脂肪酸（脂）和不饱和脂肪酸（油）。</p>
<p>饱和脂肪酸在常温下成块状，加热后仍能保持某种形状。这种物质很难被消化，过量摄取会导致血液黏稠，甚至导致血栓。</p>
<p>不饱和脂肪酸分为 ω-3 、ω-6 和 ω-9 几种。其中 ω-3 和 ω-6 人体无法合成，必须通过食物获取。</p>
<p>ω-3 具有抗炎症、疏通血管等作用，在鱼类和坚果类中含量较高，大多人体内缺乏这种脂肪酸，应积极摄取。</p>
<p>ω-6 和饱和脂肪酸一样会使血液黏稠，还可能使体内炎症恶化，过量摄入甚至引起脑梗、心肌梗塞和癌症等，并且被认为是导致遗传性皮炎和花粉症等过敏症状的原因。应尽量减少大豆油、菜籽油和葵花油等的摄入。</p>
<p>ω-3 和 ω-6 的理想状态为 1:4 ，但现代人摄入比例为 1:10 到 1:50 。</p>
<p>实际上人体存在瘦素（Leptin）这种激素，在脂肪增加时自动分泌，ω-3 摄入不足和过量摄入 ω-6 和反式脂肪酸会阻碍瘦素分泌。</p>
<p>ω-9 人体可以合成，没必要通过食物摄取，但可以为减少 ω-6 而适当用 ω-9（橄榄油、芝麻油）代替。</p>
<h4 id="酒"><a href="#酒" class="headerlink" title="酒"></a>酒</h4><p>酒精虽然含卡路里，但大多在身体吸收前燃烧掉，也就是说仅凭酒精是不会使人变胖，不过酒中除了酒精还有糖。</p>
<p>酒分为红酒、啤酒等酿造酒和烧酒、威士忌、白兰地等蒸馏酒。</p>
<p>酿造酒是谷物和果汁等经过酒精发酵的产物，含大量的糖分；而蒸馏酒是酿造酒蒸馏后，将酒精等挥发成分浓缩的产物，糖分已被去除。喝过量的酿造酒，其中的糖会造成肥胖。</p>
<p>酒和加工食品一样，越便宜的酒里面不纯物质越多，会给肝脏造成负担，所以不要喝便宜货。</p>
<p>酒也会增加食欲，使人更容易吸收脂肪。</p>
<p>肝脏分解酒精会消耗维生素和矿物质，而这些都是燃烧脂肪必需的营养素，需要注意补充这些营养素。</p>
<h4 id="断食"><a href="#断食" class="headerlink" title="断食"></a>断食</h4><p>以健康为目的、以低卡路里高营养的发酵饮品为主食的断食有助于减肥。</p>
<p>血糖一旦降低就进食，会使身体燃烧脂肪提高血糖值的能力退化，适当断食会改变这种情况，打开燃烧脂肪的开关。</p>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><p>如果只为了减肥，每周 1 到 2 次的运动就足以使身体发生改变，也没有必要特意去健身房。</p>
<p>散步是很好的运动方式，每天走 8000 步以上，就是很客观的运动量了。无法满足每日步数，可以每周找两天走 30 到 60 分钟。</p>
<p>倒立是另一项推荐的运动，有抗衰老、消除浮肿等作用。如果平时缺乏运动，可以借助墙壁进行倒立，尽量不要勉强。开始倒立时，血液聚集在头部会使脸变红，但如果每天坚持倒立，身体会逐渐适应。</p>
<p>减肥只要进行散步和倒立这样的运动就足够了。健美的体型需要通过运动获得，但减肥主要通过改善饮食习惯来实现。</p>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>减肥</tag>
      </tags>
  </entry>
</search>
